{
  "title": "如何在指针中隐藏数据？",
  "cells": [
    {
      "type": "text",
      "data": "<div><div id=\"nei\" style=\"box-sizing: border-box; margin: 0px; padding: 0px; color: rgb(69, 69, 69); font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 21px;\"><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">编写 C 语言代码时，指针无处不在。我们可以稍微额外利用指针，在它们内部暗中存储一些额外信息。为实现这一技巧，我们利用了数据在内存中的自然对齐特性。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">内存中的数据并非保存在任意地址。处理器通常按照其字大小相同的块读取内存数据；那么考虑到效率因素，编译器会按照块大小的整数倍对内存中的实体进行地址对齐。因此在32位的处理器上，一个4字节整型数据肯定存放在内存地址能被4整除的地方。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">下面，假设系统中整型数据和指针大小均为 4 字节。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">现在有一个指向整型的指针。如上所述，整型数据可以存放在内存地址0×1000或者0×1004或者0×1008，但是决不会存放在 0×1001或者0×1002或者0×1003或者其他不能被4整除的任何地址。所有是4整数倍的二进制数都是以00结尾。实际上，这意味着对于所有指向 整型的指针，它的最后两位总是0。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">那么有2比特没有承载任何信息。此处的技巧是将我们的数据放置到这两个比特中，在需要时使用，并在通过指针解引用来访问内存前删除它们。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">由于C标准对指针位操作的支持不是很好，所以我们将指针保存为一个无符号整型数据。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">下面是一段简短的简单代码片段。完整的代码查看github代码仓库中的&nbsp;<a target=\"_blank\" href=\"http://github.com/arjun024/hide-data-in-ptr\" rel=\"nofollow,noindex\" style=\"box-sizing: border-box; color: rgb(202, 12, 22); text-decoration: none; margin: 0px; padding: 0px; outline: none; background-position: initial initial; background-repeat: initial initial;\">hide-data-in-ptr</a>&nbsp;。</p><pre style=\"box-sizing: border-box; font-family: 'Courier New'; font-size: 12px; white-space: pre-wrap; padding: 5px; margin: 5px 8px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;\">void put_data(int *p, unsigned int data)\n{\n  assert(data &lt; 4);\n  *p |= data;\n}\n\nunsigned int get_data(unsigned int p)\n{\n  return (p &amp; 3);\n}\n\nvoid cleanse_pointer(int *p)\n{\n  *p &amp;= ~3;\n}\n\nint main(void)\n{\n  unsigned int x = 701;\n  unsigned int p = (unsigned int) &amp;x;\n\n  printf(\"Original ptr: %un\", p);\n\n  put_data(&amp;p, 3);\n\n  printf(\"ptr with data: %un\", p);\n  printf(\"data stored in ptr: %un\", get_data(p));\n\n  cleanse_pointer(&amp;p);\n\n  printf(\"Cleansed ptr: %un\", p);\n  printf(\"Dereferencing cleansed ptr: %un\", *(int*)p);\n\n  return 0;\n}</pre><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">代码输出如下:</p><pre style=\"box-sizing: border-box; font-family: 'Courier New'; font-size: 12px; white-space: pre-wrap; padding: 5px; margin: 5px 8px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;\">Original ptr:  3216722220\nptr with data: 3216722223\ndata stored in ptr: 3\nCleansed ptr:  3216722220\nDereferencing cleansed ptr: 701</pre><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">我们可以在指针中存储任何可以用两个比特位表示的数据。使用put_data()函数，设置指针的最低两位为要存储的数据。该数据可以使用get_data()函数获取。此处除了最后两位所有的位都被覆盖为零，于是我们隐藏的数据就显示出来。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">cleanse_pointer()函数将最低两位置零，保证指针安全地解引用。注意虽然有些CPU像Intel允许我们访问未对齐内存地址，但其余CPU像ARM会出现访问错误。所以，要牢记在解引用前保证指针指向已对齐内存地址。</p><h4 style=\"box-sizing: border-box; font-family: 'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun; font-weight: 100; color: inherit; margin: 0.8em 0px; font-size: 1em; padding: 0px;\">这在实际中有应用吗？</h4><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">是的，有应用。查看Linux内核中红黑树的实现（&nbsp;<a target=\"_blank\" href=\"http://github.com/torvalds/linux/blob/master/include/linux/rbtree.h\" rel=\"nofollow,noindex\" style=\"box-sizing: border-box; color: rgb(202, 12, 22); text-decoration: none; margin: 0px; padding: 0px; outline: none; background-position: initial initial; background-repeat: initial initial;\">链接</a>&nbsp;）。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">树的结点定义如下：</p><pre style=\"box-sizing: border-box; font-family: 'Courier New'; font-size: 12px; white-space: pre-wrap; padding: 5px; margin: 5px 8px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;\">struct rb_node {\n  unsigned long  __rb_parent_color;\n  struct rb_node *rb_right;\n  struct rb_node *rb_left;\n} __attribute__((aligned(sizeof(long))));</pre><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">此处unsigned long __rb_parent_color存储了如下信息：</p><ol style=\"box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 50px; list-style-position: initial; list-style-image: initial;\"><li style=\"box-sizing: border-box; margin: 0px; padding: 0px; list-style: decimal;\">父节点的地址</li><li style=\"box-sizing: border-box; margin: 0px; padding: 0px; list-style: decimal;\">结点的颜色</li></ol><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">色彩的表示用0代表红色，1代表黑色。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">和前面的例子一样，该数据隐藏在父指针“无用的”比特位中。</p><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\">下面看一下父指针和色彩信息是如何获取的：</p><div style=\"box-sizing: border-box; margin: 0px; padding: 0px;\"><pre style=\"box-sizing: border-box; font-family: 'Courier New'; font-size: 12px; white-space: pre-wrap; padding: 5px; margin: 5px 8px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;\">/* in rbtree.h */\n#define rb_parent(r)   ((struct rb_node *)((r)-&gt;__rb_parent_color &amp; ~3))</pre><pre style=\"box-sizing: border-box; font-family: 'Courier New'; font-size: 12px; white-space: pre-wrap; padding: 5px; margin: 5px 8px; line-height: 1.42857; color: rgb(51, 51, 51); word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;\">/* in rbtree_augmented.h */\n#define __rb_color(pc)     ((pc) &amp; 1)\n#define rb_color(rb)       __rb_color((rb)-&gt;__rb_parent_color)</pre></div><p style=\"box-sizing: border-box; margin: 10px auto; padding: 0px;\"><a target=\"_blank\" class=\"keylink\" href=\"http://www.ahlinux.com/start/base/6833.html\" style=\"box-sizing: border-box; color: rgb(202, 12, 22); text-decoration: none; margin: 0px; padding: 0px; outline: none; background-position: initial initial; background-repeat: initial initial;\">内存</a>中每一比特都很珍贵，砸门永远不要浪费。——（本文作者）</p><div><br></div></div><ul class=\"l_text clear_div\" style=\"box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 40px; list-style-position: initial; list-style-image: initial; color: rgb(69, 69, 69); font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 21px;\"></ul></div>"
    }
  ]
}
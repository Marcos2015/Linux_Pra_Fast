{
  "title": "详解C中volatile关键字",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); line-height: 1.7; font-size: 14px; font-family: arial;\"><p style=\"margin: 10px auto; font-family: verdana; line-height: 22px;\">&nbsp;volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。下面举例说明。在DSP开发中，经常需要等待某个事件的触发，所以经常会写出这样的程序：<br>short flag;<br>void test()<br>{<br>do1();<br>while(flag==0);<br>do2();<br>}</p><p style=\"margin: 10px auto; font-family: verdana; line-height: 22px;\">&nbsp; &nbsp; 这段程序等待内存变量flag的值变为1(怀疑此处是0,有点疑问,)之后才运行do2()。变量flag的值由别的程序更改，这个程序可能是某个硬件中断服务程序。例如：如果某个按钮按下的话，就会对DSP产生中断，在按键中断程序中修改flag为1，这样上面的程序就能够得以继续运行。但是，编译器并不知道flag的值会被别的程序修改，因此在它进行优化的时候，可能会把flag的值先读入某个寄存器，然后等待那个寄存器变为1。如果不幸进行了这样的优化，那么while循环就变成了死循环，因为寄存器的内容不可能被中断服务程序修改。为了让程序每次都读取真正flag变量的值，就需要定义为如下形式：<br>volatile short flag;<br>&nbsp; &nbsp; 需要注意的是，没有volatile也可能能正常运行，但是可能修改了编译器的优化级别之后就又不能正常运行了。因此经常会出现debug版本正常，但是release版本却不能正常的问题。所以为了安全起见，只要是等待别的程序修改某个变量的话，就加上volatile关键字。<br><br><strong>volatile的本意是“易变的”</strong><br>&nbsp; &nbsp; &nbsp; 由于访问寄存器的速度要快过RAM，所以编译器一般都会作减少存取外部RAM的优化。比如：<br>static int i=0;<br>int main(void)<br>{<br>...<br>while (1)<br>{<br>if (i) do_something();<br>}<br>}<br>/* Interrupt service routine. */<br>void ISR_2(void)<br>{<br>i=1;<br>}<br>&nbsp; &nbsp; 程序的本意是希望ISR_2中断产生时，在main当中调用do_something函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致do_something永远也不会被调用。如果变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。<br>&nbsp; &nbsp; 一般说来，volatile用在如下的几个地方：<br>1、中断服务程序中修改的供其它程序检测的变量需要加volatile；<br>2、多任务环境下各任务间共享的标志应该加volatile；<br>3、存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；<br>另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了。<br><strong>二、volatile 的含义</strong><br>&nbsp; &nbsp; &nbsp;volatile总是与优化有关，编译器有一种技术叫做<strong>数据流分析</strong>，分析程序中的变量在哪里赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化，进一步可以死代码消除。但有时这些优化不是程序所需要的，这时可以用volatile关键字禁止做这些优化，volatile的字面含义是易变的，它有下面的作用：&nbsp;<br>&nbsp;1 不会在两个操作之间把volatile变量缓存在寄存器中。在多任务、中断、甚至setjmp环境下，变量可能被其他的程序改变，编译器自己无法知道，volatile就是告诉编译器这种情况。<br>2 不做常量合并、常量传播等优化，所以像下面的代码：&nbsp;<br>volatile int i = 1;&nbsp;<br>if (i &gt; 0) ...&nbsp;<br>if的条件不会当作无条件真。&nbsp;<br>3 对volatile变量的读写不会被优化掉。如果你对一个变量赋值但后面没用到，编译器常常可以省略那个赋值操作，然而对Memory Mapped IO的处理是不能这样优化的。&nbsp;<br>&nbsp; &nbsp; 前面有人说volatile可以保证对内存操作的原子性，这种说法不大准确，其一，x86需要LOCK前缀才能在SMP下保证原子性，其二，RISC根本不能对内存直接运算，要保证原子性得用别的方法，如atomic_inc。&nbsp;<br>&nbsp; &nbsp; 对于jiffies，它已经声明为volatile变量，我认为直接用jiffies++就可以了，没必要用那种复杂的形式，因为那样也不能保证原子性。&nbsp;<br>&nbsp; &nbsp; 你可能不知道在Pentium及后续CPU中，下面两组指令&nbsp;<br>inc jiffies&nbsp;<br>;;&nbsp;<br>mov jiffies, %eax&nbsp;<br>inc %eax&nbsp;<br>mov %eax, jiffies&nbsp;<br>作用相同，但一条指令反而不如三条指令快。<br><strong>三、编译器优化 → C关键字volatile → memory破坏描述符zz</strong></p><p style=\"margin: 10px auto; font-family: verdana; line-height: 22px;\">&nbsp; &nbsp; “memory”比较特殊，可能是内嵌汇编中最难懂部分。为解释清楚它，先介绍一下编译器的优化知识，再看C关键字volatile。最后去看该描述符。&nbsp;<br>1、编译器优化介绍&nbsp;<br>&nbsp; &nbsp; &nbsp;内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。另外在现代CPU中指令的执行并不一定严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。以上是硬件级别的优化。再看软件一级的优化：一种是在编写代码时由程序员优化，另一种是由编译器进行优化。编译器优化常用的方法有：<strong>将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重新排序读写指令。</strong>对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier），linux 提供了一个宏解决编译器的执行顺序问题。&nbsp;<br>void Barrier(void)&nbsp;<br>&nbsp; &nbsp; &nbsp;这个函数通知编译器插入一个内存屏障，但对硬件无效，编译后的代码会把当前CPU寄存器中的所有修改过的数值存入内存，需要这些数据的时候再重新从内存中读出。&nbsp;<br>2、C语言关键字volatile&nbsp;<br>&nbsp; &nbsp; &nbsp;C语言关键字volatile（注意它是用来修饰变量而不是上面介绍的__volatile__）表明某个变量的值可能在外部被改变，因此对这些变量的存取不能缓存到寄存器，每次使用时需要重新存取。该关键字在多线程环境下经常使用，因为在编写多线程的程序时，同一个变量可能被多个线程修改，而程序通过该变量同步各个线程，例如：&nbsp;<br>DWORD __stdcall threadFunc(LPVOID signal)&nbsp;<br>{&nbsp;<br>int* intSignal=reinterpret_cast&lt;int*&gt;(signal);&nbsp;<br>*intSignal=2;&nbsp;<br>while(*intSignal!=1)&nbsp;<br>sleep(1000);&nbsp;<br>return 0;&nbsp;<br>}&nbsp;<br>&nbsp; &nbsp; &nbsp;该线程启动时将intSignal 置为2，然后循环等待直到intSignal 为1 时退出。显然intSignal的值必须在外部被改变，否则该线程不会退出。但是实际运行的时候该线程却不会退出，即使在外部将它的值改为1，看一下对应的伪汇编代码就明白了：&nbsp;<br>mov ax,signal&nbsp;<br>label:&nbsp;<br>if(ax!=1)&nbsp;<br>goto label&nbsp;<br>&nbsp; &nbsp; &nbsp;对于C编译器来说，它并不知道这个值会被其他线程修改。自然就把它cache在寄存器里面。记住，C 编译器是没有线程概念的！这时候就需要用到volatile。volatile 的本意是指：这个值可能会在当前线程外部被改变。也就是说，我们要在threadFunc中的intSignal前面加上volatile关键字，这时候，编译器知道该变量的值会在外部改变，因此每次访问该变量时会重新读取，所作的循环变为如下面伪码所示：&nbsp;<br>label:&nbsp;<br>mov ax,signal&nbsp;<br>if(ax!=1)&nbsp;<br>goto label&nbsp;<br>3、Memory&nbsp;<br>&nbsp; &nbsp; &nbsp; 有了上面的知识就不难理解Memory修改描述符了，Memory描述符告知GCC：&nbsp;<br>1）不要将该段内嵌汇编指令与前面的指令重新排序；也就是在执行内嵌汇编代码之前，它前面的指令都执行完毕&nbsp;<br>2）不要将变量缓存到寄存器，因为这段代码可能会用到内存变量，而这些内存变量会以不可预知的方式发生改变，因此GCC插入必要的代码先将缓存到寄存器的变量值写回内存，如果后面又访问这些变量，需要重新访问内存。&nbsp;<br>&nbsp; &nbsp; &nbsp;如果汇编指令修改了内存，但是GCC 本身却察觉不到，因为在输出部分没有描述，此时就需要在修改描述部分增加“memory”，告诉GCC 内存已经被修改，GCC 得知这个信息后，就会在这段指令之前，插入必要的指令将前面因为优化Cache 到寄存器中的变量值先写回内存，如果以后又要使用这些变量再重新读取。&nbsp;<br>&nbsp; &nbsp; &nbsp;使用“volatile”也可以达到这个目的，但是我们在每个变量前增加该关键字，不如使用“memory”方便。</p></div><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span title=\"neteasefooter\" style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span id=\"netease_mail_footer\"><div id=\"netease_mail_footer\"><div style=\"border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); padding: 10px 5px; color: rgb(102, 102, 102); line-height: 22px;\">来自网易手机号码邮箱<a id=\"mobile_set\" sys=\"1\" log=\"1\" logid=\"free_sms_20120504\" href=\"http://shouji.163.com/\" target=\"_blank\" style=\"color: rgb(0, 0, 255);\">了解更多</a></div></div></span></span>"
    }
  ]
}
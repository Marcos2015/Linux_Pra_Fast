{
  "title": "C语言返璞归真之修改const常量和使用变量定义数组长度",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); line-height: 1.7; font-size: 14px; font-family: arial;\"><div class=\"content-head clearfix\" style=\"zoom: 1; color: rgb(69, 69, 69); font-family: tahoma, helvetica, arial; font-size: 12px; line-height: normal;\"><h2 class=\"title content-title\" style=\"margin: 0px 0px 10px; padding: 0px; font-size: 20px; font-family: tahoma, helvetica, 'microsoft yahei', arial; color: rgb(58, 58, 58); font-weight: normal; float: left;\"><span style=\"color: rgb(69, 69, 69); font-family: tahoma, helvetica, arial; font-size: 14px;\">首先要说，c语言是对汇编的简单封装，c语言的标准不能囊括所有程序员尝试的奇怪行为，</span><br></h2></div><div id=\"content\" class=\"content mod-cs-content text-content clearfix\" style=\"zoom: 1; width: 758px; overflow: hidden; line-height: 1.5; margin: 7px 0px 10px; color: rgb(69, 69, 69); font-family: tahoma, helvetica, arial;\">标准之外的事情，那就没准了<br>所以这里说的两种情况也是编译器相关的，如同i+++i 和++i++ 一样是没有实际意义的东西<br>可以拿来忽悠忽悠菜鸟，装成一副大牛的样子<br><strong>工作还是要守规矩，不要写天书</strong>，没事别跟编译器较劲，稳定压倒一切<br><br>网上流传一种修改常量的说法<br><br>#include &lt;stdio.h&gt;<br>int main(int argc, char* argv[])<br>{<br>const long lng=10;<br>long *p1=(long *)&amp;lng;<br>long *p2=p1;<br>*p1=1000;<br>printf(\"%d %d %d\\n\",lng,*p1,*p2);<br>printf(\"%p %p %p\\n\",&amp;lng,p1,p2);<br>return 0;<br>}<br><br><br>第一行打印出来是 10 1000 1000<br>有人说这表示const常量能被修改，有人说这只能算半修改，原来的常量值根本没变<br>看第二行打印：<br>0xbfbc0b58 0xbfbc0b58 0xbfbc0b58<br>TMD是同一个地址，既然是同一地址，为什么打出来不一样的值？<br>直接打印地址所存的值<br>printf(\"%d\\n\",*((long *)0xbfbc0b58));<br>得到1000<br><br>就是说， long *p1=(long *)&amp;lng;<br>表面上给了他们相同的指针（这个const常量在函数体内），但是const常量是保存在数据段（只读）的<br>这个地址0xbfbc0b58查内存文件得知是属于堆栈段<br>也就是说，虽然地址相同，但是访问时直接使用常量的符号名访问，读取的是数据段<br>通过指针访问，读取到的是堆栈段<br><br>以上代码，如果把const long lng=10;放在全局变量位置，<br>那就会产生一个段错误，在windows下就是一个经典的错误框：xxxx内存不能write<br>此时 long *p1=(long *)&amp;lng; 就真正得到了数据段的指针，const常量还是不能修改的<br><br>const提供了一种保护机制，能在编译阶段阻止一些mud的举动，但是变成汇编成二进制之后就不复存在<br><br><br><br><br><br><br><br>然后再来吹吹如何使用变量定义数组长度<br>这个每个人第一次学C语言开始就知道是错误的<br>因为变量值在编译阶段是未知的，如果编译阶段就要决定数组大小时，变量自然是不行的（const常量试了也不行）<br>可是这样的规定也会封杀编译时不需要决定数组大小的情况<br>比如定义一个全局的大数组并赋初值，再定义一个局部的大数组，比较一下生成的可执行文件大小就有所发现<br><br>局部数组存在于堆栈段（堆栈只有栈的意思，没有堆的意思）中，不会在编译阶段就需要把它的大小确定下来，<br>所以局部数组不能用变量定义大小的话总是一种遗憾，缺乏一点灵活度<br>当然，如果给了这点灵活度，往往会带来更大的问题，使用者会<br>char str[i];之后，改变了i的值，却仍然认为str的大小是最初的i。<br><br>所以VC是封的死死的，但是gcc加上 -std c89 和 -ansi 选项之后仍然能通过以下代码，<br>姑且认为Linux程序员需要更多的智慧<br><br>#include &lt;stdio.h&gt;&nbsp;<br><br>int main(int argc, char* argv[])&nbsp;<br>{&nbsp;<br>int i=100;<br>char p[i][i];<br>return 0;&nbsp;<br>}&nbsp;<br><br>进程堆栈的大小是有限的，Linux默认是8MB，不要定义巨大的局部数组。如果需要超大空间存数据，应该向数据段或堆段要；如果要的很频繁，最好向数据段要，同时注意程序的可重入性。</div></div><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span title=\"neteasefooter\" style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span id=\"netease_mail_footer\"><div id=\"netease_mail_footer\"><div style=\"border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); padding: 10px 5px; color: rgb(102, 102, 102); line-height: 22px;\">来自网易手机号码邮箱<a id=\"mobile_set\" sys=\"1\" log=\"1\" logid=\"free_sms_20120504\" href=\"http://shouji.163.com/\" target=\"_blank\" style=\"color: rgb(0, 0, 255);\">了解更多</a></div></div></span></span>"
    }
  ]
}
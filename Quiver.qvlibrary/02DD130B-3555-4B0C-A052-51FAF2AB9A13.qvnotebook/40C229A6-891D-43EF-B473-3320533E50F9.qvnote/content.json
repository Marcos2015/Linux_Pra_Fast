{
  "title": "C中的volatile用法",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); line-height: 1.7; font-size: 14px; font-family: arial;\"><h1 class=\"postTitle\" style=\"margin: 10px 0px; padding: 0px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(221, 221, 221); font-size: 14px; font-family: verdana, Arial, Helvetica, sans-serif; line-height: 24px;\">volatile 影响编译器编译的结果,指出，volatile 变量是随时可能发生变化的，与volatile变量有关的运算，不要进行编译优化，以免出错，（VC++ 在产生release版可执行码时会进行编译优化，加volatile关键字的变量有关的运算，将不进行编译优化。）。&nbsp;<br></h1><div class=\"postBody\" style=\"margin: 0px; padding: 0px; line-height: 1.8; color: rgb(51, 51, 51); font-family: verdana, Arial, Helvetica, sans-serif;\"><div id=\"cnblogs_post_body\" style=\"margin: 0px; padding: 0px;\"><p style=\"margin: 10px auto; padding: 0px;\">例如：&nbsp;<br style=\"margin: 0px; padding: 0px;\">volatile int i=10;&nbsp;<br style=\"margin: 0px; padding: 0px;\">int j = i;&nbsp;<br style=\"margin: 0px; padding: 0px;\">...&nbsp;<br style=\"margin: 0px; padding: 0px;\">int k = i;&nbsp;<br style=\"margin: 0px; padding: 0px;\">volatile 告诉编译器i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的可执行码会重新从i的地址读取数据放在k中。&nbsp;<br style=\"margin: 0px; padding: 0px;\">而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在k中。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问，不会出错。</p><p style=\"margin: 10px auto; padding: 0px;\">/**********************</p><p style=\"margin: 10px auto; padding: 0px;\">一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：&nbsp;<br style=\"margin: 0px; padding: 0px;\">1) 并行设备的硬件寄存器（如：状态寄存器）&nbsp;<br style=\"margin: 0px; padding: 0px;\">2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)&nbsp;<br style=\"margin: 0px; padding: 0px;\">3) 多线程应用中被几个任务共享的变量&nbsp;<br style=\"margin: 0px; padding: 0px;\">回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。&nbsp;<br style=\"margin: 0px; padding: 0px;\">1)一个参数既可以是const还可以是volatile吗？解释为什么。&nbsp;<br style=\"margin: 0px; padding: 0px;\">2); 一个指针可以是volatile 吗？解释为什么。&nbsp;<br style=\"margin: 0px; padding: 0px;\">3); 下面的函数有什么错误：&nbsp;<br style=\"margin: 0px; padding: 0px;\">int square(volatile int *ptr)&nbsp;<br style=\"margin: 0px; padding: 0px;\">{&nbsp;<br style=\"margin: 0px; padding: 0px;\">return *ptr * *ptr;&nbsp;<br style=\"margin: 0px; padding: 0px;\">}&nbsp;<br style=\"margin: 0px; padding: 0px;\">下面是答案：&nbsp;<br style=\"margin: 0px; padding: 0px;\">1)是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。&nbsp;<br style=\"margin: 0px; padding: 0px;\">2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。&nbsp;<br style=\"margin: 0px; padding: 0px;\">3) 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：&nbsp;<br style=\"margin: 0px; padding: 0px;\">int square(volatile int *ptr)&nbsp;<br style=\"margin: 0px; padding: 0px;\">{&nbsp;<br style=\"margin: 0px; padding: 0px;\">int a,b;&nbsp;<br style=\"margin: 0px; padding: 0px;\">a = *ptr;&nbsp;<br style=\"margin: 0px; padding: 0px;\">b = *ptr;&nbsp;<br style=\"margin: 0px; padding: 0px;\">return a * b;&nbsp;<br style=\"margin: 0px; padding: 0px;\">}&nbsp;<br style=\"margin: 0px; padding: 0px;\">由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：&nbsp;<br style=\"margin: 0px; padding: 0px;\">long square(volatile int *ptr)&nbsp;<br style=\"margin: 0px; padding: 0px;\">{&nbsp;<br style=\"margin: 0px; padding: 0px;\">int a;&nbsp;<br style=\"margin: 0px; padding: 0px;\">a = *ptr;&nbsp;<br style=\"margin: 0px; padding: 0px;\">return a * a;&nbsp;<br style=\"margin: 0px; padding: 0px;\">}&nbsp;<br style=\"margin: 0px; padding: 0px;\">位操作（Bit manipulation）</p><p style=\"margin: 10px auto; padding: 0px;\">//*********************</p><p style=\"margin: 10px auto; padding: 0px;\">嵌入式编程中经常用到 volatile这个关键字，在网上查了下他的用法可以归结为以下两点：</p><p style=\"margin: 10px auto; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">一：告诉compiler不能做任何优化</strong></p><p style=\"margin: 10px auto; padding: 0px;\">&nbsp;&nbsp; 比如要往某一地址送两指令：&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; int *ip =...; //设备地址&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; *ip = 1; //第一个指令&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; *ip = 2; //第二个指令&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; 以上程序compiler可能做优化而成：&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; int *ip = ...;&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; *ip = 2;&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; 结果第一个指令丢失。如果用volatile, compiler就不允许做任何的优化，从而保证程序的原意：&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; volatile int *ip = ...;&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; *ip = 1;&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; *ip = 2;&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; 即使你要compiler做优化，它也不会把两次付值语句间化为一。它只能做其它的优化。这对device driver程序员很有用。</p><p style=\"margin: 10px auto; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">二：表示用volatile定义的变量会在程序外被改变,每次都必须从内存中读取，而不能把他放在cache或寄存器中重复使用。</strong></p><p style=\"margin: 10px auto; padding: 0px;\">&nbsp;&nbsp; 如&nbsp;&nbsp; volatile char a;&nbsp;&nbsp;&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=0;&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(!a){&nbsp;<br style=\"margin: 0px; padding: 0px;\">//do some things;&nbsp;&nbsp;&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doother();&nbsp;<br style=\"margin: 0px; padding: 0px;\">&nbsp;&nbsp; 如果没有 volatile doother()不会被执行</p></div></div></div><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span title=\"neteasefooter\" style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span id=\"netease_mail_footer\"><div id=\"netease_mail_footer\"><div style=\"border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); padding: 10px 5px; color: rgb(102, 102, 102); line-height: 22px;\">来自网易手机号码邮箱<a id=\"mobile_set\" sys=\"1\" log=\"1\" logid=\"free_sms_20120504\" href=\"http://shouji.163.com/\" target=\"_blank\" style=\"color: rgb(0, 0, 255);\">了解更多</a></div></div></span></span>"
    }
  ]
}
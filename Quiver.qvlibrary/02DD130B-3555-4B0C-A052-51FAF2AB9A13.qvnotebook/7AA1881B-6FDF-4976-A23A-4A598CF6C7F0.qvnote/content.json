{
  "title": "C 如何编译出一个不需要操作系统的程序？",
  "cells": [
    {
      "type": "text",
      "data": "<div>作者：ivan lam<br>链接：https://www.zhihu.com/question/49580321/answer/287194405<br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><br><div><div class=\"RichContent-inner\" data-reactid=\"237\"><span class=\"RichText CopyrightRichText-richText\" itemprop=\"text\" data-reactid=\"238\"><p>很多答案都完整介绍了很多编译、链接、库、加载和装载知识，写得太全了，搞得没有直接回应原来的问题。</p><p><b>原问题：C代码，怎 么编译，不需要操作系统支持就可以运行</b></p><p><br></p><p>其实什么不能调用库，不依赖系统调用，都不是题主关注，题主关注的是二进制格式。</p><p>题主其实是知道：C代码经过编译和链接两个阶段，就会生成可执行文件，Linux平台是ELF格式可执行文件，而Window下是PE格式。这两种格式有一个特点是有个文件头，需要OS在加载可执行文件时做解析工作，根据格式要求一步步找到代码段，并copy到相应的虚拟地址空间上，再跳到_start地址上执行，最后运行到main函数，才算是真正运行到开发人员编写的代码。</p><p>如果没有OS支持，ELF/PE格式的二进制文件肯定是无法运行的。而专门在裸机上运行的格式是binary格式（<i>可能这个称呼不标准，欢迎大家指正</i>）。这种格式特点是没有额外的代码杂音，即你写什么样的代码，就生成对应的汇编指令，不增一分也不减一分，没有任何文件头描述，<b>第0节字开始就是指令。</b></p><p>下面我们来实验一下裸机运行程序的编译、链接和运行过程。在网上找了个<a href=\"https://link.zhihu.com/?target=http%3A//blog.csdn.net/trochiluses/article/details/8971117\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">boot例子</a>, 并将它修改成gcc汇编器认识的语法格式。我们这里使用汇编来做例子，为什么使用汇编而不用C，后面有解释。</p><p>代码如下：</p><div class=\"highlight\"><pre><code class=\"language-nasm\"><span class=\"nf\">.globl</span> <span class=\"nv\">_start</span>\n\t<span class=\"nf\">.code16</span>\n\n<span class=\"nl\">_start:</span>\n\t<span class=\"nf\">mov</span>     <span class=\"o\">%</span><span class=\"nb\">cs</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"nb\">ax</span>  \n\t<span class=\"nf\">mov</span>     <span class=\"o\">%</span><span class=\"nb\">ax</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"nb\">ds</span>  \n\t<span class=\"nf\">mov</span>     <span class=\"o\">%</span><span class=\"nb\">ax</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"nb\">es</span>  \n\t<span class=\"nf\">call</span>    <span class=\"nb\">Disp</span><span class=\"nv\">Str</span>                 <span class=\"err\">#</span> <span class=\"err\">调用显示字符串例程</span>  \n<span class=\"err\">1:</span>\n\t<span class=\"nf\">jmp</span>     <span class=\"mb\">1b</span>                      <span class=\"err\">#</span> <span class=\"err\">无限循环</span>  \n<span class=\"nl\">DispStr:</span>  \n\t<span class=\"nf\">mov</span>     <span class=\"kc\">$</span><span class=\"nv\">BootMessage</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"nb\">ax</span>\n\t<span class=\"nf\">mov</span>     <span class=\"o\">%</span><span class=\"nb\">ax</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"nb\">bp</span>                <span class=\"err\">#</span> <span class=\"nb\">ES</span><span class=\"p\">:</span><span class=\"nb\">BP</span> <span class=\"err\">=</span> <span class=\"err\">串地址</span>  \n\t<span class=\"nf\">mov</span>     <span class=\"kc\">$</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"nb\">cx</span>                <span class=\"err\">#</span> <span class=\"nb\">CX</span> <span class=\"err\">=</span> <span class=\"err\">串长度</span>  \n\t<span class=\"nf\">mov</span>     <span class=\"kc\">$</span><span class=\"mh\">0x1301</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"nb\">ax</span>            <span class=\"err\">#</span> <span class=\"nb\">AH</span> <span class=\"err\">=</span> <span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"nb\">AL</span> <span class=\"err\">=</span> <span class=\"mh\">01h</span>  \n\t<span class=\"nf\">mov</span>     <span class=\"kc\">$</span><span class=\"mh\">0x000c</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"nb\">bx</span>            <span class=\"err\">#</span> <span class=\"err\">页号为</span><span class=\"mi\">0</span><span class=\"p\">(</span><span class=\"nb\">BH</span> <span class=\"err\">=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"err\">黑底红字</span><span class=\"p\">(</span><span class=\"nb\">BL</span> <span class=\"err\">=</span> <span class=\"mh\">0Ch</span><span class=\"p\">,</span><span class=\"err\">高亮</span><span class=\"p\">)</span>  \n\t<span class=\"nf\">mov</span>     <span class=\"kc\">$</span><span class=\"mh\">0x00</span><span class=\"p\">,</span> <span class=\"o\">%</span><span class=\"nb\">dl</span>  \n\t<span class=\"nf\">int</span>     <span class=\"kc\">$</span><span class=\"mh\">0x10</span>                   <span class=\"err\">#</span> <span class=\"mh\">10h</span> <span class=\"err\">号中断</span>  \n\t<span class=\"nf\">ret</span>  \n\n<span class=\"nl\">BootMessage:</span>\n\t<span class=\"nf\">.ascii</span> <span class=\"s\">\"Hello, OS world!\"</span>  \n\t<span class=\"nf\">.org</span>\t<span class=\"mi\">510</span>                      <span class=\"err\">#</span> <span class=\"err\">填充剩下的空间，使生成的二进制代码恰好为</span><span class=\"mi\">512</span><span class=\"err\">字节</span>\n\t<span class=\"nf\">.word</span>\t<span class=\"mh\">0xaa55</span>                   <span class=\"err\">#</span> <span class=\"err\">引导扇区标志</span>\n</code></pre></div><p>重要的事情来了，也就是题主关心的，先是编译，然后再链接成binary二进制。</p><p><b>编译：</b></p><blockquote>gcc -Wall -g -m32 -c -o boot.o boot.s</blockquote><p><b>链接成binary二进制格式boot.bin</b></p><blockquote>ld -m elf_i386 --oformat binary -N -e _start -Ttext 0x7c00 -o boot.bin boot.o</blockquote><p>请注意，这里关键一步是ld生成了binary格式（<b>--oformat binary选项指定生成binary格式，当然前面有答主也提到这关键一步，但没有重点强调，我想这是题主最为关心的问题）。</b>值得注意的是，程序的起始地址为0x7C00，是因为X86机器对boot程序的约定，BIOS会将它搬移到0x7C00这个址址并执行，所以要将_start地址设置为0x7C00才能运行。</p><p>这里生成的boot.bin就是一个标准的引导扇区，可以将它写到floppy的第0号扇区，即可运行。为了方例演示，这里使用 qemu＋kvm来展示它的运行过程。</p><p><b>执行以下命令：</b></p><blockquote>qemu-system-i386 -enable-kvm -fda boot.bin</blockquote><p>即可看到系统从floppy引导，并将boot.s程序运行成功：</p><figure><noscript>&lt;img src=\"https://pic2.zhimg.com/50/v2-cd636c7ee5ca33f29290b102bb1b1fdd_hd.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"768\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic2.zhimg.com/v2-cd636c7ee5ca33f29290b102bb1b1fdd_r.jpg\"&gt;</noscript><img src=\"quiver-image-url/946512F023823E2ADF201013F223FFC6.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"768\" class=\"origin_image zh-lightbox-thumb lazy\" data-original=\"https://pic2.zhimg.com/v2-cd636c7ee5ca33f29290b102bb1b1fdd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/50/v2-cd636c7ee5ca33f29290b102bb1b1fdd_hd.jpg\" width=\"720\" height=\"405\"></figure><p>在对话窗左上角黑底红字的<b>“hello, OS world!”</b>就是boot.s程序的输出。</p><p><br></p><p><b>为什么是汇编，而不是C代码</b></p><p>回过头再看这个问题，其实写C代码，也是可以先编译，再链接成binary二进制的。但问题是：C语言编写的代码是以函数为最小单位，每个函数生成的指令都有一个prologue指令给函数建立栈帧。但在裸机环境下，栈空间都还没有开辟，所以无法运行成功。 </p><p>同时，作为整个系统上的第一个软件（主机上的BIOS不算），必须遵守一系列的硬件约定，比如上面的boot.s代码必须搬到0x7C00地址运行，满足这样约定下C语言是很难实现的。所以现代OS的boot和loader都是先运行汇编代码，建立好相应的运行环境之后，才调用C语言编写的代码。</p><p><br></p><p><b>千里之行，始于足下</b></p><p>不管多么复杂的OS，不管它主要的二进制使用何种压缩格式，还是ELF格式，甚至支持可动态加载内核模块（比如Linux的Loadable Kernel Module)，都是是前面使用建立好了相应的运行环境，才能做得如此的出神入化。而C语言编写的代码，它的运行环境，无一例外是需要一段汇编给它建立环境才可以运行的，这就是为什么操作系统编写离不开汇编的一个原因。</p><p><br></p><p>参考：</p><p>[1] <a href=\"https://link.zhihu.com/?target=https%3A//sourceware.org/binutils/docs/as/Org.html%23Org\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gas下的.org用法说明</a></p></span><!-- react-empty: 239 --></div><div data-reactid=\"240\"><div class=\"ContentItem-time\" data-reactid=\"241\"><a target=\"_blank\" href=\"/question/49580321/answer/287194405\" data-reactid=\"242\"><span data-tooltip=\"发布于 2018-01-01\" data-reactid=\"243\"><!-- react-text: 244 -->编辑于 <!-- /react-text --><!-- react-text: 245 -->2018-01-02</span></a></div></div></div></div>"
    }
  ]
}
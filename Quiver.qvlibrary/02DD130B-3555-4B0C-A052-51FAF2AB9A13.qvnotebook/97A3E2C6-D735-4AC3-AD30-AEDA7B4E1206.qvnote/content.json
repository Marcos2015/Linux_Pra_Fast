{
  "title": "生成不重复的随机数的思路",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">通常的生成随机数的做法是不考虑重复的，因为即使重复也属于概率意义上的正常情况。但某些情况下需要不重复的随机数据，怎么办呢?</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">我想从大方向上来说，应该只有两个方法。要么牺牲时间要么牺牲空间。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">下面均以在101~200的范围内(设为b[100]，它实际上是附加空间)，从中产生10个不重复的随机数(设为a[10])。</p><h4 style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">牺牲时间为代价</h4><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">这种方法不需要附加空间b数组。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">要产生一定范围内不可重复的随机数，把曾经生成的随机数保存起来作为历史数据。产生一个新的随机数后在历史数据搜索，若找到就重新产生一个新的再重复数据搜索；否则就认为已经找到了一个新的不同随机数。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">可以预见，每个新产生的随机数都要与前面所有的数比较。若重复，舍弃，再产生;否则，产生下一个。平均耗时n的平方量级。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">粗看起来，上面的程序似乎没有什么问题，在执行过程中程序也能够通过。但，仔细分析我们就会发现问题出在一个新产生的随机数是否已经存在的 判定上。既然是随机数，那么从数学的角度来说在概率上，每次产生的随机数 r就有可能相同，尽管这种可能性很小，但确是一个逻辑性与正确性的问题。因此，每次产生的新的随机数r都有可能是数组random的前i-1个数中的某一 个，也就是说程序在运行过程中由此可能会导致死循环!</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">有人可能会争辩说，这种概率很小嘛，几乎为零。的确，但我要问，算法的五大特性是什么，其中两大特性就是:确定性和有穷性。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">所以，怎么解决?牺牲空间。</p><h4 style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">牺牲空间为代价</h4><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">以下方法需要附加空间b数组。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">将范围数组b[100](b[i]=100+i，不妨设数组下标从1开始)的每个元素设置一个标志位flag。初始均为flag=0;若某元素被选入到a数组中，则flag=1;显然，以后再选到重复元素可以立刻判定是否已选。这不正是以空间换时间吗?</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">但是仍然有一个很严重的问题，在小规模输入下，无疑它的表现是不错的。但现在举一个失败的例子。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">在1~65536之间，选择65500个不重复的随机数。看看后面的随机数，比如第65500个数(最后一个)，它要在剩下的36个数中选择才会有flag=0(根本不知道这36个数是什么);哼哼，概率36/65536。越到后面，随机数越难产生，空间也换不了时间。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">改进:先在1~65536之间随机选取36个数，删除。将剩下的65500个数依次赋值给a[65500]，然后打乱顺序即可。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">当范围数组与目标数组的大小非常接近时，上述算法非常有效，建议采用。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">仍以最开始的那个例子来说，初始数组b[i]=100+i，a数组空。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">每次随机生成数组b的一个下标subscript，然后取出它所对应的数据a[subscript]，记下来。然后将数组b的最后一个数 b[length]放到下标subscript的位置，同时将数组a长度减1。尽管前若干次生成的下标subscript随机数有可能相同，但，因为每一 次都把最后一个数填到取出的位置，因此，相同下标subscript对应的数却绝不会相同，每一次取出的数都不会一样，这样，就保证了算法的确定性、有效 性、有穷性。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">以生成1-10之间的10个不重复的随机数为例，介绍生成不重复的随机数的一些方法。</p><h4 style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">通过while循环来实现</h4><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">通过while循环不停的生成随机数，直到生成一个不重复的为止，这种方法比较容易想到，但是效率也比较低下，实例代码如下：</p><pre class=\"brush: java;\" style=\"color: rgb(0, 0, 0); font-size: 14px;\">static void Main(string[] args)\n{\n\tint[] result = new int[10];\n\tint tmp = -1;\n\tRandom random = new Random();\n\tbool repeat = false;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n  \t\trepeat = true;\n \t\twhile (repeat)\n       \t{\n     \t\trepeat = false;\n        \ttmp = random.Next(1, 11);\n         \tfor (int j = 0; j &lt; i; j++)\n           \t{\n           \t\tif (tmp == result[j])\n            \t{\n                \trepeat = true;\n                 \tbreak;\n          \t\t}\n     \t\t}\n\t\t}\n\t\tresult[i] = tmp;\n   \t}\n\tfor (int i = 0; i &lt; 10; i++)\n\t\tConsole.WriteLine(result[i].ToString());                \n}\n</pre><h4 style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">通过for循环来实现</h4><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">方法1使用了多处循环嵌套，效率十分低下，所以我应用一定的技巧来减少循环嵌套，来达到提高程序效率的目的。主要思路是如果检测到重复，就把循环变量减1，这样来重新进行一次循环，重新生成一个随机数，直到生成一个不重复的随机数为止，实例代码如下：</p><pre class=\"brush: java;\" style=\"color: rgb(0, 0, 0); font-size: 14px;\">static void Main(string[] args)\n{\n\tint[] result = new int[10];\n\tint tmp = -1;\n\tRandom random = new Random();\n\tbool repeat = false;\n\tfor (int i = 0; i &lt; 10; i++)\n\t{\n  \t\trepeat = false;\n    \ttmp = random.Next(1, 11);\n    \tfor (int j = 0; j &lt; i; j++)\n     \t{\n          \tif (tmp == result[j])\n         \t{\n         \t\trepeat = true;\n              \tbreak;\n   \t\t\t}\n     \t}\n     \tif (!repeat)\n   \t\t{\n       \t\tresult[i] = tmp;\n    \t}\n     \telse\n      \t{\n         \ti = i - 1;//循环变量-1\n    \t}\n                \n\t}\n\tfor (int i = 0; i &lt; 10; i++)\n\t\tConsole.WriteLine(result[i].ToString());  \n}\n</pre><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">这个方法减少了一层循环嵌套，效率上有一定的改善。</p><h4 style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">通过随机排序来实现</h4><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">这种方法彻底的颠覆了方法1和2的基本思路，先初始化一个包含数字1-10的数组，然后每次循环取一个随机位置，将这个位置的元素和最后一个位置的元素交换！实例代码如下：</p><pre class=\"brush: java;\" style=\"color: rgb(0, 0, 0); font-size: 14px;\">static void Main(string[] args)\n{\n\tint[] result = new int[10];\n\tfor (int i = 0; i &lt; 10; i++)\n   \t\tresult[i] = i + 1;\n\tfor (int j = 9; j &gt; 0; j--)\n  \t{\n    \tRandom r = new Random();\n   \t\tint index = r.Next(0, j);\n     \tint temp = result[index];\n    \tresult[index] = result[j];\n     \tresult[j] = temp;\n\t}\n \tfor (int i = 0; i &lt; 10; i++)\n\t\tConsole.WriteLine(result[i].ToString());\n}\n</pre><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">这种方法消除了循环嵌套，效率上获得了进一步的改善，但是也有一定的限制，如果要生成5组1-10之间的随机数，那这种打乱顺序的方法就无法使用了。</p><h4 style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">总结</h4><ul class=\"article\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><li>方法1效率比较低下，一般不推荐使用。</li><li>方法2比较通用，效率高于方法1，但是效率低于方法3。</li><li>方法3虽然效率比较高，但是只能应用与特定的情况下。</li></ul><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">下面的例子的主要是思路是，如果检测到已经存在该数字，则将循环数后退一个，重新生成。</p><pre class=\"brush: java;\" style=\"color: rgb(0, 0, 0); font-size: 14px;\">void static Main()\n{\n　　Random random = new Random();\n　　bool repeat = true;\n　　int temp ;\n　　int[] store = new int[10];\n　　for(int i = 0;i &lt; 10;i++)\n　　{\n　　　　temp =random.Next(1,11);\n　　　　for(int j = 0; j&lt;i;j++)\n　　　　{\n　　　　　　repeat = false ;\n　　　　　　if(temp == store[j])\n　　　　　　{\n　　　　　　　　repeat = true;\n　　　　　　　　break;\n　　　　　　}\n　　　　}\n　　　　store[i] = temp;　　　　//将不重复的值存储到定义的数组当中\n　　}\n　　for(int  i = 0;i &lt; 10;i++)\n　　{\n　　　　Console.WriteLine(\"store[{0}]为：{1}\",i,store[i]);\n　　}\n}\n</pre><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">如果所要生成的随机数比较少的话，可以将所有的先存到数组当中，然后再随机交换数组当中的数字即可：</p><pre class=\"brush: java;\" style=\"color: rgb(0, 0, 0); font-size: 14px;\">static void Main()\n{　\n　　int[] store = new store[10];　　//定义一个数组，并初始化\n　　for(int i =1;i&lt;11;i++)　　　　　　//通过循环将数组进行赋值\n　　{\n　　　　store[i-1] = i;\n　　}\n \n　　for(int j = 9;j&gt;0;j--)\n　　{\n　　　　Random r = new Random();\n　　　　int index = r.Next(0,j);　　　　//int index = r.Next(0,9);　　这个值得商榷，感觉有些问题。\n　　　　int temp = store[index]; \n　　　　store[index] = store[j];\n　　　　store[j] = temp;\n　　}\n}</pre>"
    }
  ]
}
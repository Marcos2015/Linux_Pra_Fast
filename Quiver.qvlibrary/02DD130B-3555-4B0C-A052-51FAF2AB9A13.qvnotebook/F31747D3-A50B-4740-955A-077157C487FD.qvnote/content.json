{
  "title": "C语言中volatile关键字的作用",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); line-height: 1.7; font-size: 14px; font-family: arial;\"><div class=\"article_title\" style=\"margin: 5px 0px; font-size: 20px; line-height: 30px; font-family: 'Microsoft YaHei';\"><span class=\"ico ico_type_Original\" style=\"display: inline-block; width: 19px; height: 19px; margin: 0px 2px 0px 0px; background-image: url(http://static.blog.csdn.net/images/ico_Original.gif); vertical-align: middle; background-position: 0px 0px; background-repeat: no-repeat no-repeat;\"></span><span style=\"font-family: Arial; font-size: 14px;\">一.前言</span></div><div id=\"article_content\" class=\"article_content\" style=\"margin: 20px 0px 0px; line-height: 26px; font-family: Arial;\"><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">1.编译器优化介绍：</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">由于内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。另外在现代CPU中指令的执行并不一定严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。以上是硬件级别的优化。再看软件一级的优化：一种是在编写代码时由程序员优化，另一种是由编译器进行优化。<span style=\"color: red;\">编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU</span>指令流水线，常见的是重新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier），linux 提供了一个宏解决编译器的执行顺序问题。</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">void Barrier(void)</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">这个函数通知编译器插入一个内存屏障，但对硬件无效，编译后的代码会把当前CPU寄存器中的所有修改过的数值存入内存，需要这些数据的时候再重新从内存中读出。</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">2.volatile总是与优化有关，编译器有一种技术叫做数据流分析，分析程序中的变量在哪里赋值、在哪里使用、在哪里失效，分析结果可以用于常量合并，常量传播等优化，进一步可以消除一些代码。但有时这些优化不是程序所需要的，这时可以用volatile关键字禁止做这些优化。</span></p><h2 style=\"margin: 0px; padding: 0px;\"><a name=\"t1\" style=\"color: rgb(202, 0, 0);\"></a>二.volatile详解：</h2><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">1.volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候<span style=\"color: red;\">，系统总是重新从它所在的内存读取数据</span>，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">2.看两个事例：</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\"><span style=\"color: red;\">1&gt;</span><span style=\"color: red;\">告诉compiler</span>不能做任何优化</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">比如要往某一地址送两指令：&nbsp;<br>int *ip =...; //设备地址&nbsp;<br>*ip = 1; //第一个指令&nbsp;<br>*ip = 2; //第二个指令&nbsp;<br>以上程序compiler可能做优化而成：&nbsp;<br>int *ip = ...;&nbsp;<br>*ip = 2;&nbsp;<br>结果第一个指令丢失。如果用volatile, compiler就不允许做任何的优化，从而保证程序的原意：&nbsp;<br>volatile int *ip = ...;&nbsp;<br>*ip = 1;&nbsp;<br>*ip = 2;&nbsp;<br>即使你要compiler做优化，它也不会把两次付值语句间化为一。它只能做其它的优化。</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\"><span style=\"color: red;\">2&gt;</span><span style=\"color: red;\">用volatile</span>定义的变量会在程序外被改变,每次都必须从内存中读取，而不能重复使用放在cache或寄存器中的备份。</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"color: red;\"><span style=\"font-size: 16px;\">例如：</span></span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">volatile char a;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">a=0;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">while(!a){</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">//do some things;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">}</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">doother();</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\"><span style=\"color: red;\">如果没有 volatiledoother()</span>不会被执行</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">3.下面是使用volatile变量的几个场景：</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">1&gt;中断服务程序中修改的供其它程序检测的变量需要加volatile；</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">例如:</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">static int i=0;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">int main(void)</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">{</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp; ...</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp; while (1){</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">if (i) dosomething();</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">}</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">｝</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">/* Interrupt service routine. */</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">void ISR_2(void)</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">{</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=1;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">}</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">程序的本意是希望ISR_2中断产生时，在main函数中调用dosomething函数，但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）。此例中i也应该如此说明。</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">2&gt;多任务环境下各任务间共享的标志应该加volatile</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">3&gt;存储器映射的硬件寄存器通常也要加voliate，因为每次对它的读写都可能有不同意义。</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">例如：</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">int&nbsp; *output = (unsigned&nbsp; int *)0xff800000;//定义一个IO端口；</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">int&nbsp;&nbsp; init(void)</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">{</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">&nbsp;&nbsp; &nbsp;&nbsp; for(i=0;i&lt; 10;i++){</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;*output = i;</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">}</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">}</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，所以编译器最后给你编译编译的代码结果相当于：</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">int&nbsp; init(void)</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">{</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *output = 9;</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">}</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">如果你对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许你的代码对此地址的读操作只做了一次。然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">例如：</span></p><p style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">volatile&nbsp; int&nbsp;*output=(volatile unsigned int *)0xff800000;//定义一个I/O端口</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中禁止任务调度，3中则只能依靠硬件的良好设计。</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">4.几个问题</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">&nbsp;1)一个参数既可以是const还可以是volatile吗？</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">可以的，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">2) 一个指针可以是volatile 吗？</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">可以，当一个中服务子程序修该一个指向一个buffer的指针时。</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">5.volatile的本质：</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">1&gt; 编译器的优化</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">在本次线程内, 当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值；当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致。</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">当变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致。</span></p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">当该寄存器在因别的线程等而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致。</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">2&gt;volatile应该解释为“直接存取原始内存地址”比较合适，“易变的”这种解释简直有点误导人。</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">6.下面的函数有什么错误：</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">int square(volatile int *ptr)</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">{</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">return *ptr * *ptr;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">}</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">该程序的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">int square(volatile int *ptr)</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">{</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">int a,b;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">a = *ptr;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">b = *ptr;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">return a * b;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">}</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">long square(volatile int *ptr)</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">{</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">int a;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">a = *ptr;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">return a * a;</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px; background-color: rgb(229, 229, 229);\"><span style=\"font-size: 16px;\">}</span></p><p align=\"left\" style=\"margin: 0px; padding: 0px;\"><span style=\"font-size: 16px;\">注意：频繁地使用volatile很可能会增加代码尺寸和降低性能,因此要合理的使用volatile。</span></p></div></div><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span title=\"neteasefooter\" style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span id=\"netease_mail_footer\"><div id=\"netease_mail_footer\"><div style=\"border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); padding: 10px 5px; color: rgb(102, 102, 102); line-height: 22px;\">来自网易手机号码邮箱<a id=\"mobile_set\" sys=\"1\" log=\"1\" logid=\"free_sms_20120504\" href=\"http://shouji.163.com/\" target=\"_blank\" style=\"color: rgb(0, 0, 255);\">了解更多</a></div></div></span></span>"
    }
  ]
}
{
  "title": "Cmake 设置交叉编译环境",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">我用的是合众达的dm6446.</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">一&nbsp; 首先安装CMAKE</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">下载cmake 然后解压缩，进入解压缩后的目录，依次执行</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"># ./bootstrap<br># make &amp;&amp; make install</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">安装过程需要几分钟。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">二 构建交叉编译的CMakeLists.txt</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">说明：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">&nbsp;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">设置交叉编译之前，必须在CMakeList.txt前面加上这样一句，这样CMake才会认为你是要交叉编译：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">SET(CMAKE_SYSTEM_NAME Linux)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">&nbsp;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">在通知CMake要交叉编译以后，还要告诉CMake到哪个路径下去找库文件，因为在交叉编译的时候CMake是不会自动去系统默认的目录找库文件和头文件的：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">&nbsp;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">SET(CMAKE_FIND_ROOT_PATH \"<span style=\"color: rgb(255, 0, 0);\">编译器环境路径</span>\")</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">　 　其中的第一行，是告诉CMake查找的根目录是什么。后面分别是告诉CMake怎么查找编译时候的工具程序的位置、库的位置和头文件的位置。设置为 NEVER表示不查找，设置为ONLY表示只在CMAKE_FIND_ROOT_PATH设定的目录下查找，设置为BOTH（这是默认选项）表示既可以在 系统目录下查找，也可以在CMAKE_FIND_ROOT_PATH下查找。因为咱们是交叉编译，所以后两项的设置了ONLY，对于编译时调用工具，一般 来说是需要在系统目录下查找的，不过我不需要所以设置为NEVER。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">　　然后，设置编译器：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">&nbsp;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">SET(CMAKE_C_COMPILER \"<span style=\"color: rgb(255, 0, 0);\">编译器环境路径</span>\")</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">　　直接把编译器的路径设置过去就可以了，CMAKE_C_COMPILER是C语言编译器，CMAKE_CXX_COMPILE是C++语言编译器。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">&nbsp;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">所以 在工程主CMakeLists.txt 中<span style=\"color: rgb(255, 0, 0);\"><strong>首先</strong></span>加入如下：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">SET(CMAKE_SYSTEM_NAME Linux)&nbsp;<br>SET(TOOLCHAIN_DIR \"/opt/mv_pro_4.0/montavista/pro/devkit/arm/v5t_le\")<br>SET(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN_DIR})<br>SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)<br>SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)<br>SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 0px; padding-top: 0px;\">SET(CMAKE_C_COMPILER ${TOOLCHAIN_DIR}/bin/arm_v5t_le-gcc)<br>SET(CMAKE_CXX_COMPILER ${TOOLCHAIN_DIR}/bin/arm_v5t_le-g++)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">三 生成可调试版本的程序</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">1使用CMAKE编译确实很方便。但CMAKE默认编译出来的程序不带有符号文件，用GDB无法调试。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">2 要编译时产生符号文件供调试，调用CMAKE时，带上 -DCMAKE_BUILD_TYPE=Debug</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">例如：在build文件中输入：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">cmake .. -DCMAKE_BUILD_TYPE=Debug</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">这样产生的makefile文件make生成的可执行文件就带有调试信息，供gdb和gdbserver使用了。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">*****另外有另一种更好的方法是在工程主CMakeLists.txt中的PROJECT语句后加入一句</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">SET(CMAKE_BUILD_TYPE Debug)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">CMake 中有一个变量 CMAKE_BUILD_TYPE ,可以的取值是 Debug Release RelWithDebInfo 和 MinSizeRel。当这个变量值为 Debug 的时候,CMake 会使用变量 CMAKE_CXX_FLAGS_DEBUG 和 CMAKE_C_FLAGS_DEBUG 中的字符串作为编译选项生成 Makefile ,当这个变量值为 Release 的时候,工程会使用变量 CMAKE_CXX_FLAGS_RELEASE 和 CMAKE_C_FLAGS_RELEASE 选项生成 Makefile。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><strong>CMake 需要重点记住的命令和量</strong></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">一&nbsp; MESSAGE 命令</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">MESSAGE(STATUS \"THIS IS A BINARY DIR\" ${HELLO_BINARY_DIR})</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">STATUS 表示将要输出前缀为“--”的信息，可以替换为</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">FATAL_ERROR:立即终止CMake过程</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">SEND_ERROR:产生错误，生成过程被跳过</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">二 IF 与ELSEIF 、ELSE、ENDIF</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">示例：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">IF(表达式)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">ELSEIF(表达式)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">ELSE(表达式)</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">ENDIF</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br></p><div class=\"linux3\" style=\"font-family: Arial; font-size: 14px;\"><ins data-adsbygoogle-status=\"done\" class=\"adsbygoogle\" data-ad-client=\"ca-pub-5195587195407606\" data-ad-slot=\"7284216523\" style=\"display: inline-block; width: 336px; height: 280px;\"><br><ins id=\"aswift_1_expand\" style=\"display: inline-table; border: none; height: 280px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 336px;\"></ins></ins></div>"
    }
  ]
}
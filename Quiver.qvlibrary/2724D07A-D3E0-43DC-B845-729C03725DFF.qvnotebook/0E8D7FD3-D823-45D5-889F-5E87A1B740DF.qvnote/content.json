{
  "title": "Boost.Asio学习之Proactor模式简介",
  "cells": [
    {
      "type": "text",
      "data": "<article style=\"box-sizing: inherit; outline: 0px; position: relative; padding-top: 16px; color: rgb(51, 51, 51); font-family: &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><div id=\"article_content\" class=\"article_content csdn-tracking-statistics\" data-pid=\"blog\" data-mod=\"popu_307\" data-dsm=\"post\" style=\"box-sizing: inherit; outline: 0px; padding: 0px; margin: 0px; word-break: break-all;\"><div class=\"markdown_views\" style=\"box-sizing: inherit; outline: 0px; padding: 0px; margin: 0px; font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; word-break: break-all;\"><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">之前了解过的muduo、Nginx都是Reactor&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">最近开始学Boost.Asio使用的Proactor模式</p><h1 id=\"一reactor简介\" style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 28px; color: rgb(79, 79, 79); line-height: 36px; word-break: break-all;\"><a name=\"t0\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; word-break: break-all;\"></a><span style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">（一）Reactor简介</span></h1><h2 id=\"11-reactor模式结构\" style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 24px; color: rgb(79, 79, 79); line-height: 32px; word-break: break-all;\"><a name=\"t1\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; word-break: break-all;\"></a>1.1 Reactor模式结构</h2><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\"><img src=\"quiver-image-url/BC2003AE15DDEBAD96B970FE17EE8146.png\" alt=\"这里写图片描述\" title=\"\" style=\"box-sizing: border-box; outline: 0px; margin: 24px 0px; word-break: break-all; cursor: zoom-in;\" width=\"1487\" height=\"714\"></p><h2 id=\"12-reactor包含如下角色\" style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 24px; color: rgb(79, 79, 79); line-height: 32px; word-break: break-all;\"><a name=\"t2\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; word-break: break-all;\"></a>1.2 Reactor包含如下角色</h2><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">1.Handle 句柄：用来标识socket连接或是打开文件；</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">2.Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">3.Event Handler：事件处理接口</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">4.Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">5.Reactor：反应器，定义一个接口，实现以下功能：</p><blockquote style=\"box-sizing: border-box; outline: 0px; padding: 16px; margin-bottom: 24px; border-left-width: 8px; border-left-color: rgb(221, 223, 228); background-color: rgb(238, 240, 244); overflow: auto; word-wrap: normal; word-break: break-all; background-position: initial initial; background-repeat: initial initial;\"><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px; color: rgb(153, 153, 153); line-height: 22px; text-align: justify; word-break: break-all;\">1）供应用程序注册和删除关注的事件句柄；&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">2）运行事件循环；&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">3）有就绪事件到来时，分发事件到之前注册的回调函数上处理；</p></blockquote><hr style=\"box-sizing: border-box; outline: 0px; margin-top: 24px; margin-bottom: 24px; border-style: none none solid; border-bottom-width: 1px; border-bottom-color: rgb(221, 221, 221); word-break: break-all;\"><h1 id=\"二proactor设计模式在boostasio上的实现\" style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 28px; color: rgb(79, 79, 79); line-height: 36px; word-break: break-all;\"><a name=\"t3\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; word-break: break-all;\"></a><span style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">（二）Proactor设计模式在Boost.Asio上的实现</span></h1><h2 id=\"21-proactor模式结构\" style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 24px; color: rgb(79, 79, 79); line-height: 32px; word-break: break-all;\"><a name=\"t4\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; word-break: break-all;\"></a>2.1 Proactor模式结构</h2><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\"><img src=\"quiver-image-url/878361863C047DAEE53A372DCADEE2D0.png\" alt=\"这里写图片描述\" title=\"\" style=\"box-sizing: border-box; outline: 0px; margin: 24px 0px; word-break: break-all; cursor: zoom-in;\" width=\"958\" height=\"729\"><br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">1.Asynchronous Operation&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">异步操作，例如异步读或者异步写。</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">2.Asynchronous Operation Processor&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">异步操作处理器，负责执行异步操作，并且将事件放入完成事件队列。</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">3.Completion Event Queue&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">将完成的事件缓冲直到异步事件解复用器从中将事件取出。</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">4.Completion Handler&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">完成事件接口，处理异步事件的结果，一般由boost::bind创建的函数对象</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">5.Asynchronous Event Demultiplexer&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">阻塞等待事件完成队列中完成事件的发生，并将其返回给其调用者。</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">6.Proactor&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">调用Asynchronous Event Demultiplexer，分派与事件相关的处理程序（例如调用函数对象）。io_service就是这个抽象的一种表现形式。</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">7.Initiator&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">应用程序中启动异步操作的代码。</p><h2 id=\"22-proactor优点\" style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 24px; color: rgb(79, 79, 79); line-height: 32px; word-break: break-all;\"><a name=\"t5\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; word-break: break-all;\"></a>2.2 Proactor优点</h2><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">1.可移植性&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">可以依赖系统的异步I/O来实现，例如Windows下有实现IOCP。如果系统不支持异步I/O也可以通过同步Reactor来实现</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">2.并发中解耦线程&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">通过异步来解决耗时操作，应用程序不必通过增加线程数目来增加并发能力。</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">3.性能和可扩展性&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">Thread-per-Connection将降低系统性能，因为它增加了上下文切换、同步和数据转移操作。</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">4.简化应用程序同步&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">异步操作完成的回调可以编写在单线程环境中，应用程序的实现几乎可以忽略同步问题。</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">5.异步函数组合&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">多个异步操作可以通过链表的形式组合在一个更高层次封装的函数中，用操作完成处理函数来启动下一个异步操作。通过组合成新的操作的方式，支持特定的协议。</p><h2 id=\"23-proactor缺点\" style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 24px; color: rgb(79, 79, 79); line-height: 32px; word-break: break-all;\"><a name=\"t6\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; word-break: break-all;\"></a>2.3 Proactor缺点</h2><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">设计复杂&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">占用内存</p><hr style=\"box-sizing: border-box; outline: 0px; margin-top: 24px; margin-bottom: 24px; border-style: none none solid; border-bottom-width: 1px; border-bottom-color: rgb(221, 221, 221); word-break: break-all;\"><h1 id=\"三proactor与reactor的对比\" style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 28px; color: rgb(79, 79, 79); line-height: 36px; word-break: break-all;\"><a name=\"t7\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; word-break: break-all;\"></a><span style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">（三）Proactor与Reactor的对比</span></h1><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">简单理解两者的区别：&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">可以看出，两个模式的相同点，都是对某个IO事件的事件通知(即告诉某个模块，这个 IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下 (Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。</p><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\">使用Proactor框架和Reactor框架都可以极大的简化网络应用的开发，但它们的重点却不同。&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\">Reactor框架中用户定义的操作是在实际操作之前调用的。比如你定义了操作是要 向一个SOCKET写数据，那么当该SOCKET可以接收数据的时候，你的操作就会被调用；而Proactor框架中用户定义的操作是在实际操作之后调用 的。比如你定义了一个操作要显示从SOCKET中读入的数据，那么当读操作完成以后，你的操作才会被调用。</p><hr style=\"box-sizing: border-box; outline: 0px; margin-top: 24px; margin-bottom: 24px; border-style: none none solid; border-bottom-width: 1px; border-bottom-color: rgb(221, 221, 221); word-break: break-all;\"><h1 id=\"四参考\" style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 28px; color: rgb(79, 79, 79); line-height: 36px; word-break: break-all;\"><a name=\"t8\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; word-break: break-all;\"></a>（四）参考</h1><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 0px 0px 16px; font-size: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all;\"><a href=\"http://www.boost.org/doc/libs/1_61_0/doc/html/boost_asio/overview/core/async.html\" target=\"_blank\" style=\"box-sizing: border-box; outline: 0px; color: rgb(103, 149, 181); text-decoration: none; cursor: pointer; word-break: break-all;\">http://www.boost.org/doc/libs/1_61_0/doc/html/boost_asio/overview/core/async.html</a>&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\"><a href=\"https://segmentfault.com/a/1190000002715832\" target=\"_blank\" style=\"box-sizing: border-box; outline: 0px; color: rgb(103, 149, 181); text-decoration: none; cursor: pointer; word-break: break-all;\">https://segmentfault.com/a/1190000002715832</a>&nbsp;<br style=\"box-sizing: border-box; outline: 0px; word-break: break-all;\"><a href=\"http://speakingbaicai.blog.51cto.com/5667326/1109406\" target=\"_blank\" style=\"box-sizing: border-box; outline: 0px; color: rgb(103, 149, 181); text-decoration: none; cursor: pointer; word-break: break-all;\">http://speakingbaicai.blog.51cto.com/5667326/1109406</a></p></div></div></article><div class=\"article-bar-bottom\" style=\"box-sizing: inherit; outline: 0px; padding: 0px 0px 16px; margin: 36px 0px 0px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(227, 227, 227); color: rgb(51, 51, 51); font-family: &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, sans-serif; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><div class=\"article-copyright\" style=\"box-sizing: inherit; outline: 0px; padding: 0px; margin: 0px; font-size: 12px; color: rgb(153, 153, 153);\">版权声明：本文为博主原创文章，未经博主允许不得转载。\thttps://blog.csdn.net/zhangxiao93/article/details/54094006</div></div>"
    }
  ]
}
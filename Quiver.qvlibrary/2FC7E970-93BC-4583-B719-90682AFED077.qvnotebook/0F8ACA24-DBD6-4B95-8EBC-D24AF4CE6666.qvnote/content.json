{
  "title": "C++静态库与动态库深入研究",
  "cells": [
    {
      "type": "text",
      "data": "<header class=\"article-header\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; border-bottom-style: solid; border-bottom-width: 1px; border-bottom-color: rgb(238, 238, 238); padding-bottom: 15px; margin-bottom: 15px;\"><h1 class=\"article-title\" style=\"margin: 0px 0px 15px; padding: 0px; font-size: 22px; color: rgb(59, 141, 209); text-align: center;\"><span style=\"font-size: 14px;\">这次分享的宗旨是——让大家学会创建与使用静态库、动态库，知道静态库与动态库的区别，知道使用的时候如何选择。这里不深入介绍静态库、动态库的底层格式，内存布局等，有兴趣的同学，推荐一本书《</span><span class=\"wp_keywordlink\" style=\"font-size: 14px;\"><a href=\"http://www.codeceo.com/\" title=\"程序员\" target=\"_blank\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer;\">程序员</a></span><span style=\"font-size: 14px;\">的自我修养——链接、装载与库》。</span><br></h1></header><div class=\"article-entry\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 25px; word-break: break-all; word-wrap: break-word;\"><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px;\">什么是库</h2><p style=\"margin: 0px 0px 15px; padding: 0px;\">库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">所谓静态、动态是指链接。回顾一下，将一个程序编译成可执行程序的步骤：</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/65CB6F5D910B2F3D87E218969EA4768B.jpg\" alt=\"\" width=\"554\" height=\"263\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px;\">静态库</h2><p style=\"margin: 0px 0px 15px; padding: 0px;\">之所以成为【静态库】，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">静态库对函数库的链接是放在编译时期完成的。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">程序在运行时与函数库再无瓜葛，移植方便。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\">下面编写一些简单的四则运算C++类，将其编译成静态库给他人用，头文件如下所示：</p><pre class=\"brush: cpp; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">#pragma once\nclass StaticMath\n{\npublic:\n    StaticMath(void);\n    ~StaticMath(void);\n\n    static double add(double a, double b);//加法\n    static double sub(double a, double b);//减法\n    static double mul(double a, double b);//乘法\n    static double div(double a, double b);//除法\n\n    void print();\n};</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">inux下使用ar工具、Windows下vs使用lib.exe，将目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索。一般创建静态库的步骤如图所示：</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/CF874B4BE9F33501C0EF23AEC07547AF.jpg\" alt=\"\" width=\"484\" height=\"316\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">Linux下创建与使用静态库</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">Linux静态库命名规则</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">Linux静态库命名规范，必须是”lib[your_library_name].a”：lib为前缀，中间是静态库名，扩展名为.a。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">创建静态库（.a）</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">通过上面的流程可以知道，Linux创建静态库过程如下：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">首先，将代码文件编译成目标文件.o（StaticMath.o）</li></ul><pre class=\"brush: shell; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">g++ -c StaticMath.cpp</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">注意带参数-c，否则直接编译为可执行文件</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">然后，通过ar工具将目标文件打包成.a静态库文件</li></ul><pre class=\"brush: shell; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">ar -crv libstaticmath.a StaticMath.o</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\"><span style=\"font-family: 微软雅黑;\">生成静态库</span><span style=\"font-family: Calibri;\"><strong style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px;\">libstaticmath</span></strong><strong style=\"margin: 0px; padding: 0px;\"><span style=\"margin: 0px; padding: 0px;\">.a</span></strong></span><span style=\"font-family: 微软雅黑;\">。</span></p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/C89B668D9931132890C0FC715741DE28.jpg\" alt=\"\" width=\"415\" height=\"135\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">大一点的项目会编写makefile文件（CMake等等工程管理工具）来生成静态库，输入多个命令太麻烦了。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">使用静态库</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">编写使用上面创建的静态库的测试代码：</p><pre class=\"brush: cpp; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">#include \"StaticMath.h\"\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    double a = 10;\n    double b = 2;\n\n    cout &lt;&lt; \"a + b = \" &lt;&lt; StaticMath::add(a, b) &lt;&lt; endl;\n    cout &lt;&lt; \"a - b = \" &lt;&lt; StaticMath::sub(a, b) &lt;&lt; endl;\n    cout &lt;&lt; \"a * b = \" &lt;&lt; StaticMath::mul(a, b) &lt;&lt; endl;\n    cout &lt;&lt; \"a / b = \" &lt;&lt; StaticMath::div(a, b) &lt;&lt; endl;\n\n    StaticMath sm;\n    sm.print();\n\n    system(\"pause\");\n    return 0;\n}</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">Linux下使用静态库，只需要在编译的时候，指定静态库的搜索路径（-L选项）、指定静态库名（不需要lib前缀和.a后缀，-l选项）。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"># g++ TestStaticLibrary.cpp -L../StaticLibrary -lstaticmath</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/834D827B11372C70AD20FA98CE1A4AB8.jpg\" alt=\"\" width=\"415\" height=\"116\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-L：表示要连接的库所在目录</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-l：指定链接时需要的动态库，编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a或.so来确定库的名称。</li></ul><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px;\">Windows下创建与使用静态库</h2><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">创建静态库（.lib</strong>）</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">如果是使用VS命令行生成静态库，也是分两个步骤来生成程序：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">首先，通过使用带编译器选项 /c 的 Cl.exe 编译代码 (cl /c StaticMath.cpp)，创建名为“StaticMath.obj”的目标文件。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">然后，使用库管理器 Lib.exe 链接代码 (lib StaticMath.obj)，创建静态库StaticMath.lib。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\">当然，我们一般不这么用，使用VS工程设置更方便。创建win32控制台程序时，勾选静态库类型；打开工程“属性面板”→”配置属性”→”常规”，配置类型选择静态库。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/E698EE93D82B1DA26CF97831B14E3136.jpg\" alt=\"\" width=\"415\" height=\"269\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">Build项目即可生成静态库。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">使用静态库</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">测试代码Linux下面的一样。有3种使用方法：</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">方法一：</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">在VS中使用静态库方法：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">工程“属性面板”→“通用属性”→“框架和引用”→”添加引用”，将显示“添加引用”对话框。 “项目”选项卡列出了当前解决方案中的各个项目以及可以引用的所有库。 在“项目”选项卡中，选择 StaticLibrary。 单击“确定”。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/00758147FD021584540577837766F585.jpg\" alt=\"\" width=\"415\" height=\"273\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">添加StaticMath.h 头文件目录，必须修改包含目录路径。打开工程“属性面板”→”配置属性”→“C/C++”→” 常规”，在“附加包含目录”属性值中，键入StaticMath.h 头文件所在目录的路径或浏览至该目录。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/D6ACE7F6F343D1C093EB3E4145351BB3.jpg\" alt=\"\" width=\"415\" height=\"269\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">编译运行OK。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/4D217326331FC47E55B8621ED9C05CAC.jpg\" alt=\"\" width=\"345\" height=\"158\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">如果引用的静态库不是在同一解决方案下的子工程，而是使用第三方提供的静态库lib和头文件，上面的方法设置不了。还有2中方法设置都可行。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">方法二：</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">打开工程“属性面板”→”配置属性”→ “链接器”→ ”命令行”，输入静态库的完整路径即可。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/18BC28BBCA56E5012323B4291B3F4BED.jpg\" alt=\"\" width=\"415\" height=\"269\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">方法三：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">“属性面板”→”配置属性”→“链接器”→”常规”，附加依赖库目录中输入，静态库所在目录；</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">“属性面板”→”配置属性”→“链接器”→”输入”，附加依赖库中输入静态库名StaticLibrary.lib。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/8C26D17F4F1B5E7ECA075532AC7C6824.jpg\" alt=\"\" width=\"415\" height=\"269\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px;\">动态库</h2><p style=\"margin: 0px 0px 15px; padding: 0px;\">通过上面的介绍发现静态库，容易使用和理解，也达到了代码复用的目的，那为什么还需要动态库呢？</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">为什么还需要动态库？</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">为什么需要动态库，其实也是静态库的特点导致。</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">空间浪费是静态库的一个问题。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/1987FBFB77BC3F2255475E964E63729A.jpg\" alt=\"\" width=\"483\" height=\"413\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\">动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/CACC65FEBB6C36155DAC962EB5F96DA0.jpg\" alt=\"\" width=\"459\" height=\"404\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">动态库特点总结：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">动态库把对一些库函数的链接载入推迟到程序运行的时期。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">可以实现进程之间的资源共享。（因此动态库也称为共享库）</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">将一些程序升级变得简单。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\">Window与Linux执行文件格式不同，在创建动态库的时候有一些差异。</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">在Windows系统下的执行文件格式是PE格式，动态库需要一个DllMain函数做出初始化的入口，通常在导出函数的声明时需要有_declspec(dllexport)关键字。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">Linux下gcc编译的执行文件默认是ELF格式，不需要初始化入口，亦不需要函数做特别的声明，编写比较方便。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\">与创建静态库不同的是，不需要打包工具（ar、lib.exe），直接使用编译器即可创建动态库。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">Linux下创建与使用动态库</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">linux动态库的命名规则</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">动态链接库的名字形式为 libxxx.so，前缀是lib，后缀名为“.so”。</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">针对于实际库文件，每个共享库都有个特殊的名字“soname”。在程序启动后，程序通过这个名字来告诉动态加载器该载入哪个共享库。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">在文件系统中，soname仅是一个链接到实际动态库的链接。对于动态库而言，每个库实际上都有另一个名字给编译器来用。它是一个指向实际库镜像文件的链接文件（lib+soname+.so）。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">创建动态库（.so）</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">编写四则运算动态库代码：</p><pre class=\"brush: cpp; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">#pragma once\nclass DynamicMath\n{\npublic:\n        DynamicMath(void);\n        ~DynamicMath(void);\n\n        static double add(double a, double b);\n        static double sub(double a, double b);\n        static double mul(double a, double b);\n        static double div(double a, double b);\n        void print();\n};</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">首先，生成目标文件，此时要加编译器选项-fpic</p><pre class=\"brush: shell; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">g++ -fPIC -c DynamicMath.cpp</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">然后，生成动态库，此时要加链接器选项-shared</li></ul><pre class=\"brush: shell; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">g++ -shared -o libdynmath.so DynamicMath.o</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">-shared指定生成动态链接库。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/AF26F00E4CFFB915D363E253B8BE679D.jpg\" alt=\"\" width=\"415\" height=\"132\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">其实上面两个步骤可以合并为一个命令：</p><pre class=\"brush: shell; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">g++ -fPIC -shared -o libdynmath.so DynamicMath.cpp</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">使用动态库</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">编写使用动态库的测试代码：</p><pre class=\"brush: cpp; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">#include \"../DynamicLibrary/DynamicMath.h\"\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    double a = 10;\n    double b = 2;\n\n    cout &lt;&lt; \"a + b = \" &lt;&lt; DynamicMath::add(a, b) &lt;&lt; endl;\n    cout &lt;&lt; \"a - b = \" &lt;&lt; DynamicMath::sub(a, b) &lt;&lt; endl;\n    cout &lt;&lt; \"a * b = \" &lt;&lt; DynamicMath::mul(a, b) &lt;&lt; endl;\n    cout &lt;&lt; \"a / b = \" &lt;&lt; DynamicMath::div(a, b) &lt;&lt; endl;\n\n    DynamicMath dyn;\n    dyn.print();\n    return 0;\n}</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">引用动态库编译成可执行文件（跟静态库方式一样）：</p><pre class=\"brush: shell; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">g++ TestDynamicLibrary.cpp -L../DynamicLibrary -ldynmath</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">然后运行：./a.out，发现竟然报错了！！！</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/8B68E3A86D24528E1D3DA76EEC272922.jpg\" alt=\"\" width=\"415\" height=\"105\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">可能大家会猜测，是因为动态库跟测试程序不是一个目录，那我们验证下是否如此：</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/19CFF4BCAD45FDF19C5B1DA4E4C08190.jpg\" alt=\"\" width=\"415\" height=\"84\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">发现还是报错！！！那么，在执行的时候是如何定位共享库文件的呢？</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">1) 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader)。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">2) 对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib 目录找到库文件后将其载入内存。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">如何让系统能够找到它：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下：</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">1. 编辑/etc/ld.so.conf文件，加入库文件所在目录的路径</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">2. 运行ldconfig ，该命令会重建/etc/ld.so.cache文件</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\">我们将创建的动态库复制到/usr/lib下面，然后运行测试程序。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/DA13856FC0509E1AFAE76800B3EE236E.jpg\" alt=\"\" width=\"414\" height=\"102\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px;\">Windows下创建与使用动态库</h2><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">创建动态库（.dll）</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">与Linux相比，在Windows系统下创建动态库要稍微麻烦一些。首先，需要一个DllMain函数做出初始化的入口（创建win32控制台程序时，勾选DLL类型会自动生成这个文件）：</p><pre class=\"brush: cpp; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">// dllmain.cpp : Defines the entry point for the DLL application.\n#include \"stdafx.h\"\n\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">通常在导出函数的声明时需要有_declspec(dllexport)关键字：</p><pre class=\"brush: cpp; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">#pragma once\nclass DynamicMath\n{\npublic:\n    __declspec(dllexport) DynamicMath(void);\n    __declspec(dllexport) ~DynamicMath(void);\n\n    static __declspec(dllexport) double add(double a, double b);//加法\n    static __declspec(dllexport) double sub(double a, double b);//减法\n    static __declspec(dllexport) double mul(double a, double b);//乘法\n    static __declspec(dllexport) double div(double a, double b);//除法\n\n    __declspec(dllexport) void print();\n};</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">生成动态库需要设置工程属性，打开工程“属性面板”→”配置属性”→”常规”，配置类型选择动态库。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/680077C7EBF89E2D21CDD1FC63A21021.jpg\" alt=\"\" width=\"415\" height=\"269\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">Build项目即可生成动态库。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">使用动态库</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">创建win32控制台测试程序：</p><pre class=\"brush: cpp; gutter: true\" style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251);\">#include \"stdafx.h\"\n#include \"DynamicMath.h\"\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    double a = 10;\n    double b = 2;\n\n    cout &lt;&lt; \"a + b = \" &lt;&lt; DynamicMath::add(a, b) &lt;&lt; endl;\n    cout &lt;&lt; \"a - b = \" &lt;&lt; DynamicMath::sub(a, b) &lt;&lt; endl;\n    cout &lt;&lt; \"a * b = \" &lt;&lt; DynamicMath::mul(a, b) &lt;&lt; endl;\n    cout &lt;&lt; \"a / b = \" &lt;&lt; DynamicMath::div(a, b) &lt;&lt; endl;\n\n    DynamicMath dyn;\n    dyn.print();\n\n    system(\"pause\");\n    return 0;\n}</pre><p style=\"margin: 0px 0px 15px; padding: 0px;\">方法一：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">工程“属性面板”→“通用属性”→“框架和引用”→”添加引用”，将显示“添加引用”对话框。“项目”选项卡列出了当前解决方案中的各个项目以及可以引用的所有库。 在“项目”选项卡中，选择 DynamicLibrary。 单击“确定”。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/125295B0EC8A452403BF8A82EF9431E3.jpg\" alt=\"\" width=\"415\" height=\"272\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">添加DynamicMath.h 头文件目录，必须修改包含目录路径。打开工程“属性面板”→”配置属性”→“C/C++”→” 常规”，在“附加包含目录”属性值中，键入DynamicMath.h 头文件所在目录的路径或浏览至该目录。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/4B977C5C15F2C9C4338B0E723E73DDE7.jpg\" alt=\"\" width=\"415\" height=\"268\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">编译运行OK。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/F922DAE670AB6A07CD0B1CEBB3EC8AD1.jpg\" alt=\"\" width=\"320\" height=\"137\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">方法二：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">“属性面板”→”配置属性”→“链接器”→”常规”，附加依赖库目录中输入，动态库所在目录；</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/18848CC721E6406D392F53B9467A419D.jpg\" alt=\"\" width=\"415\" height=\"269\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">“属性面板”→”配置属性”→“链接器”→”输入”，附加依赖库中输入动态库编译出来的DynamicLibrary.lib。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/08157F7AB3C98EBE990E110D7D0D6D24.jpg\" alt=\"\" width=\"415\" height=\"269\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">这里可能大家有个疑问，动态库怎么还有一个DynamicLibrary.lib文件？即无论是静态链接库还是动态链接库，最后都有lib文件，那么两者区别是什么呢？其实，两个是完全不一样的东西。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/F26BDA0C855DF10B8BA3B33A47688143.jpg\" alt=\"\" width=\"415\" height=\"191\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">StaticLibrary.lib的大小为190KB，DynamicLibrary.lib的大小为3KB，静态库对应的lib文件叫静态库，动态库对应的lib文件叫【导入库】。实际上静态库本身就包含了实际执行代码、符号表等等，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。</p><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px;\">动态库的显式调用</h2><p style=\"margin: 0px 0px 15px; padding: 0px;\">上面介绍的动态库使用方法和静态库类似属于隐式调用，编译的时候指定相应的库和查找路径。其实，动态库还可以显式调用。【在C语言中】，显示调用一个动态库轻而易举！</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">在Linux下显式调用动态库</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">#include &lt;dlfcn.h&gt;，提供了下面几个接口：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">void * dlopen( const char * pathname, int mode )：函数以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">void* dlsym(void* handle,const char* symbol)：dlsym根据动态链接库操作句柄(pHandle)与符号(symbol)，返回符号对应的地址。使用这个函数不但可以获取函数地址，也可以获取变量地址。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">int dlclose (void *handle)：dlclose用于关闭指定句柄的动态链接库，只有当此动态链接库的使用计数为0时,才会真正被系统卸载。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">const char *dlerror(void)：当动态链接库操作函数执行失败时，dlerror可以返回出错信息，返回值为NULL时表示操作函数执行成功。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">在Windows下显式调用动态库</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">应用程序必须进行函数调用以在运行时显式加载 DLL。为显式链接到 DLL，应用程序必须：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">调用 LoadLibrary（或相似的函数）以加载 DLL 和获取模块句柄。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">调用 GetProcAddress，以获取指向应用程序要调用的每个导出函数的函数指针。由于应用程序是通过指针调用 DLL 的函数，编译器不生成外部引用，故无需与导入库链接。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">使用完 DLL 后调用 FreeLibrary。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">显式调用C++动态库注意点</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">对C++来说，情况稍微复杂。显式加载一个C++动态库的困难一部分是因为C++的name mangling；另一部分是因为没有提供一个合适的API来装载类，在C++中，您可能要用到库中的一个类，而这需要创建该类的一个实例，这不容易做到。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">name mangling可以通过extern “C”解决。C++有个特定的关键字用来声明采用C binding的函数：extern “C” 。用 extern “C”声明的函数将使用函数名作符号名，就像C函数一样。因此，只有非成员函数才能被声明为extern “C”，并且不能被重载。尽管限制多多，extern “C”函数还是非常有用，因为它们可以象C函数一样被dlopen动态加载。冠以extern “C”限定符后，并不意味着函数中无法使用C++代码了，相反，它仍然是一个完全的C++函数，可以使用任何C++特性和各种类型的参数。</p><p style=\"margin: 0px 0px 15px; padding: 0px;\">另外如何从C++动态库中获取类，附上几篇相关文章，但我并不建议这么做：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">《LoadLibrary调用DLL中的Class》：<a href=\"http://www.cppblog.com/codejie/archive/2009/09/24/97141.html\">http://www.cppblog.com/codejie/archive/2009/09/24/97141.html</a></li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">《C++ dlopen mini HOWTO》：<a href=\"http://blog.csdn.net/denny_233/article/details/7255673\">http://blog.csdn.net/denny_233/article/details/7255673</a></li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\">“显式”使用C++动态库中的Class是非常繁琐和危险的事情，因此能用“隐式”就不要用“显式”，能静态就不要用动态。</p><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px;\">附件：Linux下库相关命令</h2><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">g++(gcc)编译选项</strong></p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-shared ：指定生成动态链接库。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-static ：指定生成静态链接库。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-fPIC ：表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码， 念上就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-L. ：表示要连接的库所在的目录。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-l：指定链接时需要的动态库。编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a/.so来确定库的名称。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-Wall ：生成所有警告信息。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-ggdb ：此选项将尽可能的生成gdb 的可以使用的调试信息。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-g ：编译器在编译的时候产生调试信息。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-c ：只激活预处理、编译和汇编,也就是把程序做成目标文件(.o文件) 。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">-Wl,options ：把参数(options)传递给链接器ld 。如果options 中间有逗号,就将options分成多个选项,然后传递给链接程序。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">nm命令</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">有时候可能需要查看一个库中到底有哪些函数，nm命令可以打印出库中的涉及到的所有符号。库既可以是静态的也可以是动态的。nm列出的符号有很多，常见的有三种：</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">一种是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">一种是库中定义的函数，用T表示，这是最常见的；</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">一种是所谓的弱态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\">$nm libhello.h</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><strong style=\"margin: 0px; padding: 0px;\">ldd命令</strong></p><p style=\"margin: 0px 0px 15px; padding: 0px;\">ldd命令可以查看一个可执行程序依赖的共享库，例如我们编写的四则运算动态库依赖下面这些库：</p><p style=\"margin: 0px 0px 15px; padding: 0px;\"><img class=\"alignnone\" src=\"quiver-image-url/7C9ADE47D286DDF1FFECEDB9F263831E.jpg\" alt=\"\" width=\"415\" height=\"85\" style=\"margin: 0px auto; padding: 5px; border: 1px solid rgb(230, 230, 230); max-width: 628px; display: block;\"></p><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px;\">总结</h2><p style=\"margin: 0px 0px 15px; padding: 0px;\">二者的不同点在于代码被载入的时刻不同。</p><ul style=\"margin: 0px 0px 16px 26px; padding: 0px; list-style: none;\"><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库，因此体积较大。</li><li style=\"margin: 0px 0px 10px; padding: 0px 0px 0px 20px; background-image: url(data:image/gif;base64,R0lGODlhDQAFAKIAAKOjo6GhoampqYSEhJWVlZ2dnZmZmXx8fCH5BAAAAAAALAAAAAANAAUAAAMVKLfcB6PIScsZJuttLvlgSByK4wQJADs=); background-position: 0px 10px; background-repeat: no-repeat no-repeat;\">动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在，因此代码体积较小。</li></ul><p style=\"margin: 0px 0px 15px; padding: 0px;\">动态库的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。带来好处的同时，也会有问题！如经典的DLL Hell问题，关于如何规避动态库管理问题，可以自行查找相关资料。</p><a id=\"soft-link\" name=\"soft-link\" style=\"color: rgb(0, 136, 219); cursor: pointer;\"></a><div class=\"bd_ad_bottom\" style=\"margin: 20px 0px;\"><div class=\"sogou_ads\" style=\"float: left; margin-right: 40px;\"></div><div class=\"baidu_ads\" style=\"float: left;\"></div><div style=\"clear: both;\"></div></div><div style=\"margin-top: 10px; margin-bottom: 10px;\"></div></div><footer class=\"article-footer\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin-bottom: 15px;\"><div class=\"share\" style=\"overflow: hidden; margin-top: -4px; float: right; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; font-size: 12px; line-height: normal;\"><div id=\"bdshare\" class=\"bdshare_t bds_tools get-codes-bdshare\" style=\"z-index: 999999; padding-bottom: 2px; float: left; zoom: 1;\"><span class=\"share-tit\" style=\"float: left; padding-top: 5px;\">分享到：</span><a class=\"bds_qzone\" title=\"分享到QQ空间\" href=\"http://www.codeceo.com/article/cpp-sll-dll.html#\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer; display: block; font-family: 宋体, Arial; height: 16px; float: left; padding-top: 6px; padding-bottom: 3px; padding-left: 22px; background-image: url(http://bdimg.share.baidu.com/static/images/is.png?cdnversion=20131219); background-position: 0px -75px !important; background-repeat: no-repeat no-repeat;\"></a><a class=\"bds_tqq\" title=\"分享到腾讯微博\" href=\"http://www.codeceo.com/article/cpp-sll-dll.html#\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer; display: block; font-family: 宋体, Arial; height: 16px; float: left; padding-top: 6px; padding-bottom: 3px; padding-left: 22px; background-image: url(http://bdimg.share.baidu.com/static/images/is.png?cdnversion=20131219); background-position: 0px -235px !important; background-repeat: no-repeat no-repeat;\"></a><a class=\"bds_tsina\" title=\"分享到新浪微博\" href=\"http://www.codeceo.com/article/cpp-sll-dll.html#\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer; display: block; font-family: 宋体, Arial; height: 16px; float: left; padding-top: 6px; padding-bottom: 3px; padding-left: 22px; background-image: url(http://bdimg.share.baidu.com/static/images/is.png?cdnversion=20131219); background-position: 0px -115px !important; background-repeat: no-repeat no-repeat;\"></a><a class=\"bds_renren\" title=\"分享到人人网\" href=\"http://www.codeceo.com/article/cpp-sll-dll.html#\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer; display: block; font-family: 宋体, Arial; height: 16px; float: left; padding-top: 6px; padding-bottom: 3px; padding-left: 22px; background-image: url(http://bdimg.share.baidu.com/static/images/is.png?cdnversion=20131219); background-position: 0px -195px !important; background-repeat: no-repeat no-repeat;\"></a><a class=\"bds_kaixin001\" title=\"分享到开心网\" href=\"http://www.codeceo.com/article/cpp-sll-dll.html#\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer; display: block; font-family: 宋体, Arial; height: 16px; float: left; padding-top: 6px; padding-bottom: 3px; padding-left: 22px; background-image: url(http://bdimg.share.baidu.com/static/images/is.png?cdnversion=20131219); background-position: 0px -275px !important; background-repeat: no-repeat no-repeat;\"></a><a class=\"bds_tqf\" title=\"分享到腾讯朋友\" href=\"http://www.codeceo.com/article/cpp-sll-dll.html#\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer; display: block; font-family: 宋体, Arial; height: 16px; float: left; padding-top: 6px; padding-bottom: 3px; padding-left: 22px; background-image: url(http://bdimg.share.baidu.com/static/images/is.png?cdnversion=20131219); background-position: 0px -315px !important; background-repeat: no-repeat no-repeat;\"></a><span class=\"bds_more\" style=\"display: block; font-family: 宋体, Arial; height: 16px; float: left; cursor: pointer; padding-top: 6px; padding-bottom: 3px; padding-left: 22px; background-image: url(http://bdimg.share.baidu.com/static/images/is.png?cdnversion=20131219) !important; background-position: 0px 5px !important; background-repeat: no-repeat no-repeat !important;\">更多</span><a class=\"shareCount\" href=\"http://www.codeceo.com/article/cpp-sll-dll.html#\" title=\"累计分享0次\" style=\"color: rgb(69, 69, 69); text-decoration: none; cursor: pointer; display: block; height: 16px; float: left; padding: 0px 0px 0px 5px; margin: 5px 0px 0px; text-align: center; width: 37px; overflow: hidden; line-height: 16px; font-family: 宋体 !important; background-image: url(http://bdimg.share.baidu.com/static/images/sc.png?cdnversion=20120720) !important; background-position: 0px -30px !important; background-repeat: no-repeat no-repeat !important;\">0</a></div></div></footer>"
    }
  ]
}
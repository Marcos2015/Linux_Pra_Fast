{
  "title": "可以在构造函数中使用 this 指针吗？",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); line-height: 1.7; font-size: 14px; font-family: arial;\"><span style=\"color: rgb(128, 0, 128);\"><p class=\"MsoNormal\" align=\"left\" style=\"margin-bottom: 10pt;\"><span style=\"color: rgb(128, 0, 128); font-size: 16pt; font-family: 'Hiragino Sans GB W3';\">某些人认为不应该在构造函数中使用</span><span lang=\"EN-US\" style=\"color: rgb(128, 0, 128); font-size: 13pt; font-family: 'Heiti SC Light';\">this</span><span style=\"color: rgb(128, 0, 128); font-size: 16pt; font-family: 'Heiti SC Light';\">指针，因为这时</span><span lang=\"EN-US\" style=\"color: rgb(128, 0, 128); font-size: 13pt; font-family: 'Heiti SC Light';\">this</span><span style=\"color: rgb(128, 0, 128); font-size: 16pt; font-family: 'Heiti SC Light';\">对象还没有完全形成。然后，只要你小心，是可以在构造函数（在函数体甚至在初始化列表中）使用</span><span lang=\"EN-US\" style=\"color: rgb(128, 0, 128); font-size: 13pt; font-family: 'Heiti SC Light';\">this</span><span style=\"color: rgb(128, 0, 128); font-size: 16pt; font-family: 'Heiti SC Light';\">的。</span><br></p><span style=\"color: rgb(128, 0, 128);\"></span><p class=\"MsoNormal\" align=\"left\" style=\"margin-bottom: 10pt;\"><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">以下是始终可行的：构造函数的函数体（或构造函数所调用的函数）能可靠地访问基类中声明的数据成员和／或构造函数所属类声明的数据成员。这是因为所有这些数据成员被保证在构造函数函数体开始执行时已经被完整的建立。</span><span lang=\"EN-US\" style=\"font-size: 16pt; font-family: Arial; color: rgb(178, 178, 178);\"><o:p></o:p></span></p><span style=\"color: rgb(128, 0, 128);\"></span><p class=\"MsoNormal\" align=\"left\" style=\"margin-bottom: 10pt;\"><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">以下是始终不可行的：构造函数的函数体（或构造函数所调用的函数）不能向下调用被派生类</span><span style=\"font-size: 16pt; font-family: Arial; color: rgb(128, 0, 128);\">&nbsp;</span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">重定义的虚函数。如果你的目的是得到派生类重定义的函数，那么你将无功而返。注意，无论你如何调用虚成员函数：显式使用</span><span lang=\"EN-US\" style=\"font-size: 13pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">this</span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">指针（如，</span><span lang=\"EN-US\" style=\"font-size: 13pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">this-&gt;method()</span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">），隐式的使用</span><span lang=\"EN-US\" style=\"font-size: 13pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">this</span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">指针（如，</span><span lang=\"EN-US\" style=\"font-size: 13pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">method()</span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">），或甚至在</span><span lang=\"EN-US\" style=\"font-size: 13pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">this</span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">对象上调用其他函数来调用该虚成员函数，你都不会得到派生类的重写函数。这是底线：即使调用者正在构建一个派生类的对象，在基类的构造函数执行期间，对象还不是一个派生类的对象。</span><span lang=\"EN-US\" style=\"font-size: 16pt; font-family: Arial; color: rgb(178, 178, 178);\"><o:p></o:p></span></p><span style=\"color: rgb(128, 0, 128);\"></span></span><p class=\"MsoNormal\"><span style=\"color: rgb(128, 0, 128);\"><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">以下是有时可行的：如果传递</span><span lang=\"EN-US\" style=\"font-size: 16pt; font-family: Arial; color: rgb(128, 0, 128);\">&nbsp;</span><span lang=\"EN-US\" style=\"font-size: 13pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">this</span><span lang=\"EN-US\" style=\"font-size: 13pt; font-family: Arial; color: rgb(128, 0, 128);\">&nbsp;</span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">对象的任何一个数据成员给另一个数据成员的初始化程序，你必须确保该数据成员已经被初始化。好消息是你能使用一些不依赖于你所使用的编译器的显著的语言规则，来确定那个数据成员是否已经（或者还没有）被初始化。坏消息是你必须知道这些语言规则（例如，基类子对象首先被初始化（如果有多重和／或虚继承，则查询这个次序！），然后类中定义的数据成员根据在类中声明的次序被初始化）。如果你不知道这些规则，则不要从</span><span lang=\"EN-US\" style=\"font-size: 13pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">this</span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">对象传递任何数据成员（不论是否显式的使用了</span><span lang=\"EN-US\" style=\"font-size: 13pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">this</span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(128, 0, 128);\">关键字）给任何其他数据成员的初始化程序！如果你知道这些规则，则需要小心。</span></span><span style=\"font-size: 16pt; font-family: 'Heiti SC Light'; color: rgb(178, 178, 178);\"></span><span lang=\"EN-US\"><o:p></o:p></span></p></div><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span title=\"neteasefooter\" style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span id=\"netease_mail_footer\"><div id=\"netease_mail_footer\"><div style=\"border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); padding: 10px 5px; color: rgb(102, 102, 102); line-height: 22px;\">来自网易手机号码邮箱<a id=\"mobile_set\" sys=\"1\" log=\"1\" logid=\"free_sms_20120504\" href=\"http://shouji.163.com/\" target=\"_blank\" style=\"color: rgb(0, 0, 255);\">了解更多</a></div></div></span></span>"
    }
  ]
}
{
  "title": "C++ 能否成为你新的脚本语言？",
  "cells": [
    {
      "type": "text",
      "data": "<h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px; font-family: 'microsoft yahei'; line-height: 25px;\">一些背景</h2><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">第一个我真正喜爱的编程语言是 C。我花了不少时间才找到它：当我还是一个孩子，我就开始在珍贵的ZX Spectrum上使用 Z80 汇编。那些日子是你能够真正掌握你的电脑的时候，你不需要苹果，谷歌，微软或者其他任何人的允许就能写一个程序。我在漂亮的128K ZX Spectrum +2上学习了在超出 CPU 寻址空间时对内存块分页。直到我进入大学，我才拥有一台 IBM PC 机 。我玩遍了电子表格，试图修复现存的 Fortran 程序，用土耳其字符给键盘驱动打补丁，还学了点 Pascal 语言。之后，在我就职于土耳其中央银行期间，我又学习了 SQL 和 APL。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">我一直对 C 语言有所耳闻，但我一直没有接触到一款C语言编译器。直到我到康奈尔大学拥有了一个Unix 账号之后，我编译了我人生中的第一个 hello.c 文件，不久之后，我有了第一台电脑……我在 DOS 分区上安装了 DJGPP 编译器，构建了我人生中第一个 Linux 内核（我第一个发行版是 Debian），并且开始学习 C 语言。Plauger 的 “Standard C Library”&nbsp;是我最喜欢的书。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">当我开始享受用 C 编程的时候，C++ 已经广泛应用超过十年了。所以，我下一步使用 C++ 看起来是很自然的一步了。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">除了……好吧，除了 C++ 是一片混乱。那段时间，所有人都被继承层次深深吸引了，每个人都在编写精心设计的字符串类。大多数硬盘都太慢，不能再有限的时间内编译出可靠的 C++ 库（好吧，我有点夸张了），大部分 CPU 都在试图实例化模板中融化了，大部分人，那些假装 C++&nbsp;<span class=\"wp_keywordlink\"><a href=\"http://www.codeceo.com/\" title=\"程序员\" target=\"_blank\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer;\">程序员</a></span>的 C 程序员们，差点就把 malloc 的返回值给扔了。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">在那时，我正忙于试图建立定制化的网络经济实验，看起来 Java 似乎很有优势。至少，它不需要麻烦地拼凑出一个对话框。产生少量的 socket 连接，并且使你的应用编译和运行在多种多样的系统上。当然，AWT 和 Swing 都很丑陋且笨重，但对我的目的来说，那没关系。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">但是，仅仅是因为不能在实验室之外运行我的实验（因为在实验室已经配置了所有电脑，java应用程序运行不会有问题）。所以我快速的把FreeBSD部署到了一台拥有100Mhz奔腾处理器，16Mb内存，在角落里收集灰尘的机器上，并搭建了一个拥有perl模块（mod_perl）的Apache服务器，然后就能工作了。那就是我爱上Perl的时候。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">那份爱完全起源于实用的原因，我并不是认为Perl特别的完美，并且那时候我认为包括其他许多语言都不是很完美，他们中的每一个都有自己的瑕疵。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">Perl总是能减少我必须解决的特别问题的工作的数量，有些是因为语言特性，但大部分是因为<span style=\"font-family: 'Microsoft YaHei', Verdana, sans-serif, 宋体; font-size: 13.3333330154419px; line-height: 21.3333320617676px; background-color: rgb(246, 246, 246);\">&nbsp;</span>CPAN<span style=\"line-height: 21.3333320617676px; background-color: rgb(246, 246, 246);\">。</span></p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">举例来说，作为一个 Perl 程序员，解析 HTML 作为 HTML 是一个解决方案。我必须决定，要么就构造整个树， 或者使用流化的方式。在某些情况下，前者是具有优势的，但后者的好处是可以使内存的需求降至最低，即使是在这个年代，如果你处理 HTML 文档以兆字节方式还是可以奏效的。不论哪种方式，这些工具都不会在无效的 HTML 上被卡住，并在非 XML 的有效 HTML 上运作良好。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">还有，Perl 提供可移植性。如果我不需要操作系统特定的功能，不用任何修改地方，我的 perl 代码就可以运行。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">当我写了一些类，并为它们做了封装，也不会有复杂的架构。</p><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px; font-family: 'microsoft yahei'; line-height: 25px;\">C++ 涅槃</h2><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">在过去的数年，C++如获新生。许多聪明人已经开始意识到须要向C++程序员提供同时涵盖<span style=\"font-family: 微软雅黑, Verdana, sans-serif, 宋体; line-height: 21px; background-color: rgb(246, 246, 246);\">&nbsp;</span><a href=\"https://github.com/cplusplus/draft\" rel=\"nofollow\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer;\">work of the ISO committee</a>和<span style=\"font-family: 微软雅黑, Verdana, sans-serif, 宋体; line-height: 21px; background-color: rgb(246, 246, 246);\">&nbsp;</span><a href=\"http://www.boost.org/\" rel=\"nofollow\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer;\">boost</a>的构建模块。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">在真实环境下，仍然有90%的菜鸟生成C++程序员就是没有意识到new是一个合法符号的C程序员。在这方面，C++与Perl非常相似：大部分人写过Perl代码的人也没有意识到Perl不是C、Java、Python、shell、Awk或者其他你可以列举的语言。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">但是，当你看到新C++标准中的新东西，以及编译器不断实现浙西特性的新闻时，我们无法抑制住内心的兴奋和好奇。</p><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px; font-family: 'microsoft yahei'; line-height: 25px;\">单词计算练习</h2><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">这是一个简单的练习，使用 C++ 或者 Perl 并且不依赖外部库，所以这是一个很好的起点。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">这是 Perl 版本，供您参考：</p><pre style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251); color: rgb(68, 68, 68);\">#!/usr/bin/env&nbsp;perl\n\nuse&nbsp;strict;\nuse&nbsp;warnings;\n\nrun(/@ARGV);\n\nsub&nbsp;run&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;$argv&nbsp;=&nbsp;shift;\n&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;@counts;\n\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;my&nbsp;$file&nbsp;(&nbsp;@$argv&nbsp;)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;$count&nbsp;=&nbsp;-1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eval&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$count&nbsp;=&nbsp;word_count($file);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;or&nbsp;warn&nbsp;\"$@\";\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;@counts,&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file&nbsp;=&gt;&nbsp;$file,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word_count&nbsp;=&gt;&nbsp;$count,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;my&nbsp;$result&nbsp;(@counts)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;\"%s:&nbsp;%d&nbsp;words/n\",&nbsp;$result-&gt;{file},&nbsp;$result-&gt;{word_count};\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nsub&nbsp;word_count&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;$file&nbsp;=&nbsp;shift;\n&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;%words;\n\n&nbsp;&nbsp;&nbsp;&nbsp;open&nbsp;my&nbsp;$fh,&nbsp;'&lt;',&nbsp;$file\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;die&nbsp;\"Cannot&nbsp;open&nbsp;'$file':&nbsp;$!\";\n\n&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(my&nbsp;$line&nbsp;=&nbsp;&lt;$fh&gt;)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;@words&nbsp;=&nbsp;split&nbsp;'&nbsp;',&nbsp;$line;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$words{&nbsp;$_&nbsp;}&nbsp;+=&nbsp;1&nbsp;for&nbsp;@words;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;close&nbsp;$fh;\n\n&nbsp;&nbsp;&nbsp;&nbsp;my&nbsp;$word_count;\n&nbsp;&nbsp;&nbsp;&nbsp;$word_count&nbsp;+=&nbsp;$_&nbsp;for&nbsp;values&nbsp;%words;\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$word_count;\n}</pre><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">而且，这是我最大的付出在转化 Perl 到现代风格的 C++ 上面。我没有尝试写特别搞笑的代码：只是和 Perl 一样，我把重点放在写代码上面，使得我感到非常自然，同时确保两个程序都做大致相同的事情。</p><pre style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251); color: rgb(68, 68, 68);\">#include&nbsp;&lt;cerrno&gt;\n#include&nbsp;&lt;cstdio&gt;\n#include&nbsp;&lt;cstdlib&gt;\n#include&nbsp;&lt;fstream&gt;\n#include&nbsp;&lt;iostream&gt;\n#include&nbsp;&lt;numeric&gt;\n#include&nbsp;&lt;unordered_map&gt;\n#include&nbsp;&lt;string&gt;\n#include&nbsp;&lt;vector&gt;\n\nusing&nbsp;std::accumulate;\nusing&nbsp;std::cerr;\nusing&nbsp;std::cout;\nusing&nbsp;std::endl;\nusing&nbsp;std::ifstream;\nusing&nbsp;std::make_pair;\nusing&nbsp;std::pair;\nusing&nbsp;std::strerror;\nusing&nbsp;std::string;\nusing&nbsp;std::unordered_map;\nusing&nbsp;std::vector;\n\nint&nbsp;word_count(const&nbsp;char&nbsp;*const&nbsp;file)&nbsp;noexcept(false);\n\nint&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;&nbsp;pair&lt;string,&nbsp;int&gt;&nbsp;&gt;&nbsp;counts&nbsp;{};\n\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(auto&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;argc;&nbsp;i&nbsp;+=&nbsp;1)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts.push_back(make_pair(argv[i],&nbsp;word_count(argv[i])));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(const&nbsp;string&amp;&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cerr&nbsp;&lt;&lt;&nbsp;e&nbsp;&lt;&lt;&nbsp;endl;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counts.push_back(make_pair(argv[i],&nbsp;-1));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(auto&amp;&nbsp;result&nbsp;:&nbsp;counts)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;result.first&nbsp;&lt;&lt;&nbsp;\":&nbsp;\"&nbsp;&lt;&lt;&nbsp;result.second&nbsp;&lt;&lt;&nbsp;\"&nbsp;words\"&nbsp;&lt;&lt;&nbsp;endl;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;\n}\n\nint\nword_count(const&nbsp;char&nbsp;*const&nbsp;file)&nbsp;noexcept(false)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;errno&nbsp;=&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;ifstream&nbsp;fp(file);\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Does&nbsp;fp.fail()&nbsp;preserve&nbsp;errno?\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;save_errno&nbsp;=&nbsp;errno;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fp.fail())&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(\"Cannot&nbsp;open&nbsp;'\"&nbsp;+&nbsp;string(file)&nbsp;+&nbsp;\"':&nbsp;\"&nbsp;+&nbsp;strerror(save_errno));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;unordered_map&lt;string,&nbsp;int&gt;&nbsp;word_count&nbsp;{};\n&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;word;\n\n&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(fp&nbsp;&gt;&gt;&nbsp;word)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word_count[word]&nbsp;+=&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;fp.close();\n\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;accumulate(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word_count.cbegin(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word_count.cend(),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[](int&nbsp;sum,&nbsp;auto&amp;&nbsp;el)&nbsp;{&nbsp;return&nbsp;sum&nbsp;+=&nbsp;el.second;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;);\n}</pre><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">20 行代码用于 #include 和 using 声明可能看起来有点多，但是我抬眼 using namespace std，也讨厌不断地输入 std::… 更多的是因为我喜欢较短的代码行。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">首先要注意的是没有看得见的显式的内存分配。容器集装箱管理自己的内存。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">第二，这是一个大问题：我们有自动导入（<span style=\"margin: 0px; padding: 0px;\">autovivification</span>）！</p><pre style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251); color: rgb(68, 68, 68);\">unordered_map&lt;string,&nbsp;int&gt;&nbsp;word_count&nbsp;{};\nstring&nbsp;word;\n\nwhile&nbsp;(fp&nbsp;&gt;&gt;&nbsp;word)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;word_count[word]&nbsp;+=&nbsp;1;\n}</pre><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">第三，我们有 lambda 表达式：</p><pre style=\"margin: 15px auto; padding: 10px 15px; word-break: break-all; font-size: 12px; line-height: 20px; font-family: 'courier new'; border-width: 1px 1px 1px 4px; border-style: solid; border-color: rgb(221, 221, 221); background-color: rgb(251, 251, 251); color: rgb(68, 68, 68);\">return&nbsp;accumulate(\n&nbsp;&nbsp;&nbsp;&nbsp;word_count.cbegin(),\n&nbsp;&nbsp;&nbsp;&nbsp;word_count.cend(),\n&nbsp;&nbsp;&nbsp;&nbsp;0,\n&nbsp;&nbsp;&nbsp;&nbsp;[](int&nbsp;sum,&nbsp;auto&amp;&nbsp;el)&nbsp;{&nbsp;return&nbsp;sum&nbsp;+=&nbsp;el.second;&nbsp;}\n);</pre><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">在这背后，accumulate&nbsp;将内部变量初始化为 0，并调用一个匿名函数，其最后一个参数指定为当前值，以及word_count的下一个元素。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">现在，我不得不承认，我不知道这些特性是如何实现的，但是 Microsoft Visual C++ 2015 RC 成功运行了，微软似乎终于赶上了在该领域的最新发展。</p><h2 style=\"margin: 30px 0px 14px; padding: 0px 0px 5px; color: rgb(34, 34, 34); border-bottom-color: rgb(238, 238, 238); border-bottom-width: 1px; border-bottom-style: solid; font-size: 18px; font-family: 'microsoft yahei'; line-height: 25px;\">现在的情况</h2><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">然而，一切都不乐观。尽管&nbsp;<a href=\"http://www.boost.org/doc/libs/1_58_0/?view=categorized\" rel=\"nofollow\" target=\"_blank\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer;\">boost libraries</a>&nbsp;填补了许多空白，而且标准库提供了令人印象深刻的构件，但是也很难战胜 Perl 和 CPAN 结合带来的那种编写可在任何地方完美运行的可移植代码的便利性。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">例如，我能找到一个平台无关的库，可以让我在不需要 Excel 的情况下解析或创建 Excel 文件吗？这个库能够用 clang、g++ 和 cl 轻易地编译出来吗？好像不太可能。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">我真的非常感谢标准委员会的人们的辛勤工作，和那些开发编译器，众多库的人们。它们让我不必在编写 C++ 程序时辛苦的思考。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">这让我在真正控制我的计算机时还能感觉舒适。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">在这里，我真的非常感谢。</p><p style=\"font-size: 14px; margin: 0px 0px 15px; padding: 0px; color: rgb(68, 68, 68); font-family: 'microsoft yahei'; line-height: 25px;\">你可以在<a href=\"http://www.reddit.com/r/cpp/comments/369lcn/can_c_become_your_new_scripting_language/\" rel=\"nofollow\" target=\"_blank\" style=\"color: rgb(0, 136, 219); text-decoration: none; cursor: pointer;\">/r/cpp</a>评论本文。</p>"
    }
  ]
}
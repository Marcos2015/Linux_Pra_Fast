{
  "title": "C++基础之this指针的详解",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); line-height: 1.7; font-size: 14px; font-family: arial;\"><br><dl class=\"box_body\" id=\"fontzoom\" style=\"border-width: 0px; padding: 0px 20px 20px; margin: 0px; list-style: none; float: left; width: 630px; color: rgb(51, 51, 51); line-height: 28px; font-family: 宋体;\"><dd id=\"Article\" style=\"border-width: 0px; padding: 0px; margin: 0px; list-style: none;\"><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">关于C++中的this指针，建议大家看看这篇文章，《C++中的this指针》，供参考。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　this指针是一个特殊的指针，当类的某个非静态的成员函数在执行时，就会存在this指针。它指向类的一个对象，且这个对象的某个成员函数正在被调用。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　this指针的名字始终是this，而且总是作为隐含参数传递给每一个被声明的成员函数，例如：</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\"><img src=\"quiver-image-url/CF97A9B40F4FB279675EB97ABF35510F.jpg\" style=\"border-width: 0px; padding: 0px; margin: 0px; list-style: none; width: 570px; height: 24px;\" width=\"427\" height=\"18\">　　实际<a href=\"http://www.2cto.com/kf\" target=\"_blank\" class=\"keylink\" style=\"color: rgb(51, 51, 51); text-decoration: none;\">编程</a>时函数的声明不需要包含这个参数。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">&nbsp;</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　当程序中调用某个对象的成员函数时，编译器会把该对象的地址加入到参数列表中，感觉上就好象函数采用了上面所示的声明，并且是用如下方式来调用的：</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\"><img src=\"quiver-image-url/E492D14960BC4F453EEDE4A131396AE9.jpg\" style=\"border-width: 0px; padding: 0px; margin: 0px; list-style: none; width: 571px; height: 28px;\" width=\"428\" height=\"21\">　　静态成员函数不存在this指针。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">&nbsp;</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　当调用某个对象的成员函数时，编译器把对象的地址传递给this指针，然后再调用该函数。因此，成员函数你对任何成员的调用实际上都隐式地使用了this指针。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　1.以this指针作为返回值</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　使this指针可以允许成员函数返回调用对象给调用者。前面的程序中重载赋值运算符没有返回值，因此不能用如下的形式对字符串进行赋值：</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\"><img src=\"quiver-image-url/824C6E57EA85FEE13B50C1BD6E05B30A.jpg\" style=\"border-width: 0px; padding: 0px; margin: 0px; list-style: none; width: 584px; height: 32px;\" width=\"438\" height=\"24\">　　为了使重载的类赋值机制也能这样方便，必须让赋值函数返回赋值的结果，在这里就是目标对象。当赋值函数执行时，其返回值也恰好是this指针所指的内容。下面的程序对前面那个程序进行了修改，让重载赋值运算符返回了一个Date对象的引用。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\"><img src=\"quiver-image-url/D25F621B7A8BDCD5FE24A42352C65EFE.jpg\" style=\"border-width: 0px; padding: 0px; margin: 0px; list-style: none; height: 560px; width: 555.3177257525084px;\" width=\"593\" height=\"598\"></p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\"><img src=\"quiver-image-url/75E411471F57C3660524663A1B9C772C.jpg\" style=\"border-width: 0px; padding: 0px; margin: 0px; list-style: none; height: 560px; width: 578.7654320987655px;\" width=\"586\" height=\"567\"></p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">&nbsp;</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　2.在链表中使用this指针</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　在应用程序中，如果数据结构里有指向自身类型的成员，那么使用this指针会提供更多的方便。下面的程序中建立了一个类ListEntry的链表。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\"><img src=\"quiver-image-url/16DCB3C380CA5409CAB30119A6565CF8.jpg\" style=\"border-width: 0px; padding: 0px; margin: 0px; list-style: none; height: 560px; width: 546.9767441860465px;\" width=\"588\" height=\"602\"></p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\"><img src=\"quiver-image-url/15DB286531941CCA16ED46F499079056.jpg\" style=\"border-width: 0px; padding: 0px; margin: 0px; list-style: none; width: 603px; height: 233px;\" width=\"603\" height=\"233\">　　程序运行时，会提示输入一串姓名，当输入完毕后，键入\\\"end\\\"，然后程序会逆序显示刚才输入的所有姓名。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">&nbsp;</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　程中ListEntry类含有一个字符串和一个指向前一个表项的指针。构造函数从对中获取内存分配给字符串，并把字符串的内容拷贝到内存，然后置链接指针为NULL。析构函数将释放字符串所占用的内存。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　成员函数PrevEntry()返回指向链表前一个表项的指针。另一个成员函数显示当前的表项内容。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　成员函数AddEntry()，它把this指针拷贝给参数的preventry指针，即把当前表项的地址赋值给下一个表项的链接指针，从而构造了一个链表。它并没有改变调用它的listEntry对象的内容，只是把该对象的地址赋给函数的参数所引用的那个ListEntry对象的preventry指针，尽管该函数不会修改对象的数据，但它并不是常量型。这是因为，它拷贝对象的地址this指针的内容给一个非长常量对象，而编译器回认为这个非常量对象就有可能通过拷贝得到的地址去修改当前对象的数据，因此AddEntry()函数在声明时不需要用const。</p><p style=\"border-width: 0px; padding: 0px; margin: 0px 0px 8px; list-style: none; text-indent: 2em;\">　　希望通过以上内容的介绍，能够给你带来帮助。</p></dd></dl></div><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><br>"
    }
  ]
}
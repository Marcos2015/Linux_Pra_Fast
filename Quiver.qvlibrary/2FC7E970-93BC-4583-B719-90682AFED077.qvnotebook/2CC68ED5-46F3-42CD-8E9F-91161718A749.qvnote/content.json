{
  "title": "C++的输入输出流和缓冲区",
  "cells": [
    {
      "type": "text",
      "data": "<embed id=\"xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd\" type=\"application/thunder_download_plugin\" height=\"0\" width=\"0\"><table class=\"wenzhangcss\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"padding: 0px 26px; line-height: 1.5; min-height: 245px; font-size: 16px; color: rgb(68, 68, 68); word-wrap: break-word; font-family: Arial, Helvetica, sans-serif; text-align: center; height: auto !important;\"><tbody><tr><td align=\"left\"></td></tr><tr><td align=\"left\" valign=\"top\" width=\"670px\" style=\"height: 200px;\"><span id=\"articlecontent\"><table><tbody><tr><td width=\"670px\" style=\"position: relative;\"><div class=\"article_title\"><h3><span class=\"link_title\"><a href=\"http://blog.csdn.net/fwh20/article/details/7376766\" style=\"color: rgb(61, 107, 167); text-decoration: none;\">C++的输入输出流和缓冲区&nbsp;</a></span></h3></div><div id=\"article_content\" class=\"article_content\"><div id=\"article_content\" class=\"article_content\"><p>一、 C++ 输入输出的含义&nbsp;</p><p><strong>&nbsp;&nbsp;&nbsp;</strong>以前所用到的输入和输出，都是以终端为对象的，即从键盘输入数据，运行结果输出到显示器屏幕上。从操作系统的角度看，每一个与主机相连的输入输出设备都被看作一个文件。程序的输入指的是从输入文件将数据传送给程序，程序的输出指的是从程序将数据传送给输出文件。C++的输入与输出包括以下3方面的内容：</p><p><strong>&nbsp;&nbsp; 1、对系统指定的标准设备的输入和输出</strong>。<strong>简称标准I/O。（设备）</strong></p><p><strong>&nbsp;&nbsp; 2、以外存磁盘(或光盘)文件为对象进行输入和输出。简称文件I/0。（文件）</strong></p><p><strong>&nbsp;&nbsp; 3、对内存中指定的空间进行输入和输出</strong>。<strong>简称串I/O。（内存）</strong></p><p><strong>&nbsp;&nbsp;</strong>C++采取不同的方法来实现以上3种输人输出。 为了实现数据的有效流动，C++系统提供了庞大的I/O类库，调用不同的类去实现不同的功能。</p><p>二、 C++的I/O对C的发展—类型安全和可扩展性&nbsp;</p><p><strong>C语言中I/O存在问题：</strong><br><strong>&nbsp;&nbsp;</strong><strong>1、在C语言中，用prinff和scanf进行输入输出，往往不能保证所输入输出的数据是可靠的、安全的。</strong>学过C语言的读者可以分析下面的用法：想用格式符％d输出一个整数，但不小心错用了它输出单精度变量和字符串，会出现什么情况?假定所用的系统int型占两个字节。</p><blockquote><p>printf(\"%d\"，i)；&nbsp;<strong>//i为整型变量，正确，输出i的值<br></strong>printf(\"%d\"，f)；&nbsp;<strong>//f为单精度变量，输出变量中前两个字节的内容<br></strong>printf(\"%d\",\"C++\")；<strong>//输出字符串\"C++”的起始地址</strong></p></blockquote><p><strong>&nbsp;&nbsp;</strong>编译系统认为以上语句都是合法的，而不对数据类型的合法性进行检查，显然所得到的结果不是人们所期望的。<br><strong>&nbsp;&nbsp; 2、在用scanf输入时，有时出现的问题是很隐蔽的</strong>。如</p><blockquote><p>scanf(\"%d\"，&amp;i)；&nbsp;<strong>//正确，输入一个整数，赋给整型变量i<br></strong>scanf(\"%d\",i)；&nbsp;<strong>//漏写&amp;</strong></p></blockquote><p><strong>&nbsp;&nbsp;</strong>假如已有声明语句\"int i=1\"，定义i为整型变量，其初值为1。编译系统不认为上面的scanf语句出错，而是将输入的值存放到地址为000001的内存单元中，这个错误可能产生严重的后果。</p><p><strong>注意：</strong>C++为了与C兼容，保留了用printf和scanf进行输出和输入的方法，以便使过去所编写的大量的C程序仍然可以在C++的环境下运行，但是希望读者在编写新的C++程序时不要用C的输入输出机制，而要用C++自己特有的输入输出方法。在C++的输入输出中，编译系统对数据类型进行严格的检查，凡是类型不正确的数据都不可能通过编译。因此C++的I/0操作是类型安全(typesafe)的。</p><p><strong>&nbsp;&nbsp;3、用printf和scanf可以输出和输入标准类型(如:int，float，double，char)的数据，但无法输出用户自己声明的类型(如数组、结构体、类)的数据。</strong>在C++中，会经常遇到对类对象的输入输出，显然无法使用printf和scanf来处理。C++的I／O操作是可扩展的，不仅可以用来输入输出标准类型的数据，也可以用于用户自定义类型的数据。C++对标准类型的数据和对用户声明类型数据的输入输出，采用同样的方法处理。显然，在用户声明了一个新类后，是无法用printf和scanf函数直接输出和输入这个类的对象的。<br><br><strong>解决办法：<br>&nbsp;&nbsp;</strong>可扩展性是C++输入输出的重要特点之一，它能提高软件的重用性，加快软件的开发过程。<br><strong>&nbsp;&nbsp;</strong>C++通过I/O类库来实现丰富的I/0功能。这样使C++的输入输出明显地优于C语言中的pfintf和scanf，但是也为之付出了代价，C++的I/O系统变得比较复杂，要掌握许多细节。在本章中只能介绍其基本的概念和基本的操作，有些具体的细节可在日后实际深入应用时再进一步掌握。</p><p>三、 C++的输入输出流&nbsp;</p><p><strong>&nbsp;&nbsp;</strong>输入和输出是数据传送的过程，数据如流水一样从一处流向另一处。C++形象地将此过程称为流(stream)。C++的输入输出流是指由若干字节组成的字节序列，这些字节中的数据按顺序从一个对象传送到另一对象。流表示了信息从源到目的端的流动。在输入操作时，字节流从输入设备(如键盘、磁盘)流向内存，在输出操作时，字节流从内存流向输出设备(如屏幕、打印机、磁盘等)。流中的内容可以是ASCII字符、二进制形式的数据、图形图像、数字音频视频或其他形式的信息。</p><p><strong>&nbsp;&nbsp;<span style=\"color: rgb(255, 0, 0);\">实际上，在内存中为每一个数据流开辟一个内存缓冲区，用来存放流中的数据。当用cout和插入运算符“&lt;&lt;”向显示器输出数据时，先将这些数据送到程序中的输出缓冲区保存，直到缓冲区满了或遇到endl，就将缓冲区中的全部数据送到显示器显示出来。在输入时，从键盘输入的数据先放在键盘缓冲区中，当按回车键时，键盘缓冲区中的数据输入到程序中的输入缓冲区，形成cin流，然后用提取运算符“&gt;&gt;”从输入缓冲区中提取数据送给程序中的有关变量。总之，流是与内存缓冲区相对应的，或者说，缓冲区中的数据就是流。</span></strong></p><p><strong>&nbsp;&nbsp;</strong>在C++中，输入输出流被定义为类。C++的I/0库中的类称为流类(streamclass)。用流类定义的对象称为流对象。</p><p><strong>&nbsp;&nbsp;</strong>前面曾多次说明，cout和cin并不是C++语言中提供的语句，它们是iostream类的对象，在未学习类和对象时，在不致引起误解的前提下，为叙述方便，把它们称为cout语句和cin语句。正如C++并未提供赋值语句，只提供赋值表达式，在赋值表达式后面加分号就成了C++的语句，为方便起见，我们习惯称之为赋值语句。又如，在C语言中常用printf和scanf进行输出和输入，printf和scanf是C语言库函数中的输入输出函数，一般也习惯地将由printf和scanf函数构成的语句称为printf语句和scanf语句。在使用它们时，对其本来的概念要有准确的理解。<br><br><strong>1．iostream类库中有关的类<br>&nbsp;&nbsp;</strong>C++编译系统提供了用于输人输出的iostream类库。iostream这个单词是由3个部分组成的，即i-o-stream，意为输入输出流。在iostream类库中包含许多用于输入输出的类。</p><p><strong>&nbsp;&nbsp;</strong>ios是抽象基类，由它派生出istream类和ostream类，两个类名中第1个字母i和。分 别代表输入(mput)和输出(output)。istream类支持输入操作，ostream类支持输出操作， iostream类支持输入输出操作。iostream类是从istream类和ostream类通过多重继承而派生的类。</p><p align=\"left\"><strong>&nbsp;&nbsp;</strong>C++对文件的输人输出需要用ifstream和ofstream类，两个类名中第1个字母i和o分别代表输入和输出，第2个字母f代表文件(file)。ifstream支持对文件的输入操作，ofstream支持对文件的输出操作。类ifstream继承了类istream，类ofstream继承了类ostream，类fstream继承了类iostream。</p><p align=\"left\"><strong>&nbsp;&nbsp;</strong>由图3可以看到：由抽象基类ios直接派生出4个派生类，即istream，ostream，fstreambase和strstreambase。其中fstreambase是文件流类基类，由它再派生出ifs~eam，ofstream和fstream。strstreambase是字符串流类基类，由它再派生出lstrstream，ostrsCeam和swsWeam类。<br><strong>&nbsp;&nbsp;</strong>I/0类库中还有其他一些类，但是对于一般用户来说，以上这些已能满足需要了。如果想深入了解类库的内容和使用，可参阅所用的C++系统的类库手册。在本章将陆续介绍有关的类。</p><p><strong>2、与iostream类库有关的头文件<br>&nbsp;&nbsp;</strong>iostream类库中不同的类的声明被放在不同的头文件中，用户在自己的程序中用 #include命令包含了有关的头文件就相当于在本程序中声明了所需要用到的类。可以换一种说法：头文件是程序与类库的接口，iostream类库的接口分别由不同的头文件来实现。常用的有</p><blockquote><p>●iostream 包含了对(标准)输入输出流进行操作所需的基本信息。<br>●fstream 用于用户管理的文件的I/0操作。<br>●sbsbeam 用于字符串流I/0。<br>●stdiostream 用于混合使用C和C++的I/0机制时，例如想将C程序转变为C++程序。<br>●iomamp 在使用格式化I/0时应包含此头文件。&nbsp;</p></blockquote><p><strong>3、在iostream头文件中定义的流对象<br>&nbsp;&nbsp;</strong>在iostream头文件中定义的类有:ios，istream，ostream，iostream，istream_withassign，stream_withassign，iostream_withassign等。<br><strong>&nbsp;&nbsp;</strong>iostream包含了对输入输出流进行操作所需的基本信息。因此大多数C++程序都包括iostream。在iostream头文件中不仅定义了有关的类，还定义了4种流对象，</p><p><strong>&nbsp;&nbsp;</strong>cin是istream的派生类istream_withassign的对象，它是从标准输入设备(键盘)输入到内存的数据流，称为cin流或标准输入流。cout是ostream的派生类ostream_withassign的对象，它是从内存输入到标准输出设备(显示器)的数据流，称为cout流或标准输出流。cerr和clog作用相似，均为向输出设备(显示器)输出出错信息。因此用键盘输入时用cin流，向显示器输出时用cout流。向显示器输出出错信息时用cerr和clog流。</p><p><strong>&nbsp;&nbsp;</strong>在iostream头文件中定义以上4个流对象用以下的形式(以cout为例)：</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>osteeam cout(stdout)；</p><p><strong>&nbsp;&nbsp;</strong>在定义cout为ostream流类对象时，把标准输出设备stdout作为参数，这样它就与标准输出设备(显示器)联系起来，如果有</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;3；<strong>//就会在显示器的屏幕上输出3。</strong></p><p><strong>4．在iostream头文件中重载运算符</strong></p><p><strong>&nbsp;&nbsp;</strong>“&lt;&lt;”和“&gt;&gt;”本来在C++中是被定义为左位移运算符和右位移运算符的，由于在iosreeam头文件中对它们进行了重载，使它们能用作标准类型数据的输入和输出运算符。所以，在用它们的程序中必须用#include命令把ostream包含到程序中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;#include&lt;iostream&gt;&nbsp;</p><p><strong>&nbsp;&nbsp;</strong>在istream和ostream类(这两个类都是在头文件iostream中声明的)中分别有一组成员函数对位移运算符“&lt;&lt;”和“&gt;&gt;”进行重载，以便能用它输入或输出各种标准数据类型的数据。对于不同的标准数据类型要分别进行重载，如</p><blockquote><blockquote><p>ostream operator&lt;&lt;(int)；&nbsp;<strong>//用于向输出流插入一个int数据<br></strong>ostream operator&lt;&lt;(float)；<strong>//用于向输出流插入一个float数据<br></strong>ostream operator&lt;&lt;(char)；&nbsp;<strong>//用于向输出流插入一个char数据<br></strong>ostream operator&lt;&lt;(char *)&nbsp;<strong>//用于向输出流插入一个字符串数据</strong></p></blockquote></blockquote><p><strong>&nbsp;&nbsp;</strong>等。如果在程序中有下面的表达式：<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>cout&lt;&lt;\"C++\"；<br>&nbsp;&nbsp;</strong>根据第5章所介绍的知识，上面的表达式相当于&nbsp;<strong>cout.operator&lt;&lt;(\"C++\")<br>&nbsp;&nbsp;</strong>”C++”的值是其首字节地址，是字符型指针(char *)类型，因此选择调用上面最后一个运算符重载函数，通过重载函数的函数体，将字符串插入到cout流中，函数返回流对象cout。<br><strong>&nbsp;&nbsp;</strong>在istream类中已将运算符“&gt;&gt;”重载为对以下标准类型的提取运算符：char，signed char，unsigned char，short，unsigned short，int，unsigned int，long，unsigned long，float， double，longdouble，char*，signedchar*，unsignedchar*等。<br><strong>&nbsp;&nbsp;</strong>在ostream类中将“&lt;&lt;”重载为插入运算符，其适用类型除了以上的标准类型外，还增加了一个void。类型。<br><strong>&nbsp;&nbsp;</strong>如果想将“&lt;&lt;”和“&gt;&gt;”用于自己声明的类型的数据，就不能简单地采用包含iostream头文件来解决，必须自己用第5章介绍的方法对“&lt;&lt;”和“&gt;&gt;”进行重载。<br><strong>&nbsp;&nbsp;</strong>怎样理解运算符“&lt;&lt;”和“&gt;&gt;”的作用呢?有一个简单而形象的方法：它们指出了数据移动的方向，例如:<strong>&nbsp;&nbsp;</strong>&gt;&gt;a&nbsp;<strong>&nbsp;&nbsp;// 箭头方向表示把数据放入a中。<br></strong>而:&nbsp;<strong>&nbsp;&nbsp;</strong>&lt;&lt;a<strong>&nbsp;&nbsp;// 箭头方向表示从a中拿出数据。</strong></p><p><strong>标准输出流</strong>：标准输出流是流向标准输出设备(显示器)的数据。</p><p>四、cout，cerr和clog流&nbsp;</p><p>ostream类定义了3个输出流对象，即cout，cerr，clog。分述如下。&nbsp;</p><p><strong>1、cout流对象<br>&nbsp;&nbsp;</strong>cout是console output的缩写，意为在控制台(终端显示器)的输出。&nbsp;</p><p><strong>&nbsp;&nbsp; 1、cout不是C++预定义的关键字，它是ostream流类的对象，在iostream中定义</strong>。顾名思义，流是流动的数据，cout流是流向显示器的数据。cout流是容纳数据的载体，它并不是一个运算符。人们关心的是cout流中的内容，也就是向显示器输出什么。<br><br><strong>&nbsp;&nbsp; 2、用\"cout&lt;&lt;”输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数据的类型，并根据其类型选择调用与之匹配的运算符重载函数。<br>&nbsp;&nbsp;</strong>这个过程都是自动的，用户不必干预。如果在C语言中用prinf函数输出不同类型的数据，必须分别指定相应的输出格式符，十分麻烦，而且容易出错。C++的I/0机制对用户来说，显然是方便而安全的。<br><strong>&nbsp;&nbsp; 3、cout流在内存中对应开辟了一个缓冲区，用来存放流中的数据</strong>。当向cout流插人一个endl时，不论缓冲区是否已满，都支即输出流中所有数据，然后插入一个换行符，并刷新流(清空缓冲区)。注意如果插入一个换行符，'\\n'(如coot&lt;&lt;a&lt;&lt;'\\n'；)，则只输出a和换行，而不刷新cout流(但并不是所有编译系统都体现出这一区别)。<br><strong>&nbsp;&nbsp; 4、在iostream中只对“&lt;&lt;”和“&gt;&gt;”运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出进行重载。</strong>如果用户声明了新的类型，并希望用“&lt;&lt;”和“&gt;&gt;”运算符对其进行输入输出，应该按照第5章介绍的方法，对“&lt;&lt;”和“&gt;&gt;”运算符另作重载。</p><p><strong>2、cerr流对象<br>&nbsp;&nbsp;</strong>cerr流对象是标准出错流。cerr流已被指定为与显示器关联。cerr的作用是向标准出错设备(standard error device)输出有关出错信息。cerr是console error的缩写，意为“在控制台(显示器)显示出错信息”。cerr与标准输出流cout的作用和用法差不多。但有一点不同：cout流通常是传送到显示器输出，但也可以被重定向输出到磁盘文件，而cerr流中的信息只能在显示器输出。当调试程序时，往往不希望程序运行时的出错信息被送到其他文件，而要求在显示器上及时输出，这时应该用cerr。cerr流中的信息是用户根据需要指定的。</p><p><strong>例1 有一元二次方程ax2+bx+c=0,其一般解为 x、1、2= ……但若a=0，或b^2-4ac&lt;0时，用此公式出错。<br>&nbsp;&nbsp; 编程序，从键盘输入a，b，c的值，求x1和x2。如果a=0或b^2-4ac&lt;0，输出出错信息。可写出以下程序</strong>：</p><blockquote><p>#include &lt;iostream&gt;<br>#include &lt;math.h&gt;<br>using namespace std;<br>int main()<br>{<strong>&nbsp;</strong>float a,b,c,disc;<br><strong>&nbsp;&nbsp;</strong>cout&lt;&lt;\"please input a,b,c:\";<br><strong>&nbsp;&nbsp;</strong>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><strong>&nbsp;&nbsp;</strong>if (a==0)<br><strong>&nbsp;&nbsp;&nbsp;</strong>cerr&lt;&lt;\"a is equal to zero,error!\"&lt;&lt;endl;<strong>//将出错信息插入cerr,屏幕输出<br>&nbsp;&nbsp;</strong>else<br><strong>&nbsp;&nbsp;</strong>if ((disc=b*b-4*a*c)&lt;0)<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>cerr&lt;&lt;\"disc=b*b-4*a*c&lt;0\"&lt;&lt;endl;<strong>//将出错信息插入cerr流，屏幕输出<br>&nbsp;&nbsp;</strong>else<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>{cout&lt;&lt;\"x1=\"&lt;&lt;(-b+sqrt(disc))/(2*a)&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"x2=\"&lt;&lt;(-b-sqrt(disc))/(2*a)&lt;&lt;endl; }<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>return 0; }</p><p><strong>运行情况如下：<br>&nbsp;&nbsp;</strong>①Please input a,b,c；0 2 3／<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>a is equal to zero，error!<br><strong>&nbsp;&nbsp;</strong>②please input a，b，c：<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>disc=b*b-4*a*c&lt;O<br><strong>&nbsp;&nbsp;</strong>③please input a，b，c; 1 2.5 1.5<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>x1=-1<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>x2=-1.5</p></blockquote><p><strong>3．clog流对象<br>&nbsp;&nbsp;</strong>clog流对象也是标准出错流，它是console log的缩写。它的作用和cerr相同，都是在终端显示器上显示出错信息。它们之间只有一个微小的区别：ccrr是不经过缓冲区，直接向显示器上输出有关信息，而clog中的信息存放在缓冲区中，缓冲区满后或遇endl时向显示器输出。</p><p>五、格式输出&nbsp;</p><p><strong>&nbsp;&nbsp;</strong>在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以下六进制或八进制形式输出一个整数，对输出的小数只保留两位小数等；有两种方法可以达到此目的。一种是使用控制符；另一种是使用流对象的有关成员函数。分别叙述如下：</p><p><strong>1、 用控制符控制输出格式</strong></p><p><strong>应当注意:</strong>这些控制符是在头文件iomanip中定义的，因而程序中应当包含头文件iomanip。通过下面的例子可以了解使用它们的方法，</p><blockquote><p><strong>例2 用控制符控制输出格式</strong>，<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;&nbsp;<strong>//不要忘记包含此头文件<br></strong>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>int a;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"input a:\";<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin&gt;&gt;a;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"dec:\"&lt;&lt;dec&lt;&lt;a&lt;&lt;endl;<strong>//以上进制形式输出整数<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"hex:\"&lt;&lt;hex&lt;&lt;a&lt;&lt;endl;&nbsp;<strong>//以十六进制形式输出整数a<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"oct:\"&lt;&lt;setbase(8)&lt;&lt;a&lt;&lt;endl;<strong>//以八进制形式输出整数a<br>&nbsp;&nbsp;&nbsp;</strong>char *pt=\"China\";&nbsp;<strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>//pt指向字符串”China”<br></strong><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;setw(10)&lt;&lt;pt&lt;&lt;endl;<strong>//指定域宽为10，输出字符串<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;setfill('*')&lt;&lt;setw(10)&lt;&lt;pt&lt;&lt;endl;<strong>//指定域宽10，输出字符串，空白处以“*”填充<br>&nbsp;&nbsp;&nbsp;</strong>double pi=22.0/7.0;&nbsp;<strong>//计算pi值<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;setiosflags(ios::scientific)&lt;&lt;setprecision(8);<strong>//按指数形式输出，8位小数<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"pi=\"&lt;&lt;pi&lt;&lt;endl;&nbsp;<strong>//输出pi值<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"pi=\"&lt;&lt;setprecision(4)&lt;&lt;pi&lt;&lt;endl;/<strong>/改为4位小数<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"pi=\"&lt;&lt;setiosflags(ios::fixed)&lt;&lt;pi&lt;&lt;endl;<strong>//改为小数形式输出<br>&nbsp;&nbsp;&nbsp;</strong>return 0; }&nbsp;</p><p><strong>运行结果如下</strong>：<br><strong>&nbsp;&nbsp;</strong>inputa：34 (输入a的值)<br><strong>&nbsp;&nbsp;</strong>dec：34 (十进制形式)<br><strong>&nbsp;&nbsp;</strong>hex：22 (十六进制形)<br><strong>&nbsp;&nbsp;</strong>oct：42 (八进制形式)<br><strong>&nbsp;&nbsp;</strong>China (域宽为10)<br><strong>&nbsp;&nbsp;</strong>***** China (域宽为10，空白处以'*'填充)<br><strong>&nbsp;&nbsp;</strong>pi=3.14285714e+00 (指数形式输出，8位小数)<br><strong>&nbsp;&nbsp;</strong>pi=3.1429e+00) (指数形式输小，4位小数)<br><strong>&nbsp;&nbsp;</strong>pi=3.143 (小数形式输出，梢度仍为4)</p></blockquote><p><strong>2．用流对象的成员函数控制输出格式</strong></p><p><strong>&nbsp;&nbsp;&nbsp;</strong>除了可以用控制符来控制输出格式外，还可以通过调用流对象COUt中用于控制输出格式的成员函数来控制输出格式。用于控制输出格式的常用的成员函数见表4。</p><p align=\"left\">流成员函数setf和控制符setiosflags括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类ios中被定义为枚举值。因此在引用这些格式标志时要在前面加上类名ios和域运算符“::”。格式标志见表5。</p><blockquote><p><strong>例3 用流控制成员函数输出数据。<br></strong>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>int a=21;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout.setf(ios::showbase);<strong>//设置输出时的基数符号<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"dec:\"&lt;&lt;a&lt;&lt;endl;&nbsp;<strong>//默认以十进制形式输出a<br>&nbsp;&nbsp;&nbsp;</strong>cout.unsetf(ios::dec);&nbsp;<strong>//终止十进制的格式设置<br>&nbsp;&nbsp;&nbsp;</strong>cout.setf(ios::hex);&nbsp;<strong>//设置以十六进制输出的状态<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"hex:\"&lt;&lt;a&lt;&lt;endl;&nbsp;<strong>//以十六进制形式输出a<br>&nbsp;&nbsp;&nbsp;</strong>cout.unsetf(ios::hex);&nbsp;<strong>//终止十六进制的格式设置<br>&nbsp;&nbsp;&nbsp;</strong>cout.setf(ios::oct);&nbsp;<strong>//设置以八进制输出的状态<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"oct:\"&lt;&lt;a&lt;&lt;endl;&nbsp;<strong>//以八进制形式输出a<br>&nbsp;&nbsp;&nbsp;</strong>cout.unsetf(ios::oct);&nbsp;<strong>//终止以八进制的输出格式设置<br>&nbsp;&nbsp;&nbsp;</strong>char *pt=\"China\";&nbsp;<strong>//pt指向字符串”china”<br>&nbsp;&nbsp;&nbsp;</strong>cout.width(10);&nbsp;<strong>//指定域宽为10<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;pt&lt;&lt;endl;&nbsp;<strong>//输出字符串<br>&nbsp;&nbsp;&nbsp;</strong>cout.width(10);&nbsp;<strong>//指定域宽为10<br>&nbsp;&nbsp;&nbsp;</strong>cout.fill('*');&nbsp;<strong>//指定空白处以'*'填充<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;pt&lt;&lt;endl;&nbsp;<strong>//输出字符串<br>&nbsp;&nbsp;&nbsp;</strong>double pi=22.0/7.0;&nbsp;<strong>//计算pi值<br>&nbsp;&nbsp;&nbsp;</strong>cout.setf(ios::scientific);<strong>//指定用科学记数法输出<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"pi=\";&nbsp;<strong>//输出\"pi=\"<br>&nbsp;&nbsp;&nbsp;</strong>cout.width(14);&nbsp;<strong>//指定域宽为14<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;pi&lt;&lt;endl;&nbsp;<strong>//输出\"pi值<br>&nbsp;&nbsp;&nbsp;</strong>cout.unsetf(ios::scientific);&nbsp;<strong>//终止科学记数法状态<br>&nbsp;&nbsp;&nbsp;</strong>cout.setf(ios::fixed);&nbsp;<strong>//指定用定点形式输出<br>&nbsp;&nbsp;&nbsp;</strong>cout.width(12);&nbsp;<strong>//指定域宽为12<br>&nbsp;&nbsp;&nbsp;</strong>cout.setf(ios::showpos);&nbsp;<strong>//在输出正数时显示“+”号<br>&nbsp;&nbsp;&nbsp;</strong>cout.setf(ios::internal);&nbsp;<strong>//数符出现在左侧<br>&nbsp;&nbsp;&nbsp;</strong>cout.precision(6);&nbsp;<strong>//保留6位小数<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;pi&lt;&lt;endl;&nbsp;<strong>//输出pi，注意数符“+”的位置<br>&nbsp;&nbsp;&nbsp;</strong>return 0;}&nbsp;</p><p><strong>运行情况如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;</strong>dec：21 (十进制形式)<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>hex：Oxl5 (十六进制形式，以0x开头)<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>oct：025 (八进制形式，以O开头)<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>China (域宽为10)<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>*****china (域宽为10，空白处以'*'填充)<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>pi=**3.142857e+00 (指数形式输出，域宽14，默认6位小数)<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>****3.142857 (小数形式输㈩，精度为6，最左侧输出数符“+”)</p></blockquote><p><strong>说明：<br><br>&nbsp;&nbsp;&nbsp;</strong>1、成员函数width(n)和控制符setw(n)只对其后的第一个输出项有效。如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)，而必须在输出每一项前都调用一次width(n)。<br><br><strong>&nbsp;&nbsp;&nbsp;</strong>2、在表5中的输出格式状态分为5组，每一组中同时只能选用一种(例如，dec，hex和oct中只能选一，它们是互相排斥的)，在用成员函数serf和控制符setiosflags设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数unsetf(对应于成员函数serf)或resetiosflags(对应于控制符sefiosflags)，先终止原来设置的状态。然后再设置其他状态。<br><strong>&nbsp;&nbsp;&nbsp;</strong>同理，程序倒数第8行的unsetf函数的调用也是不可缺少的。读者不妨上机试一试。<br><br><strong>&nbsp;&nbsp;&nbsp;</strong>3、用serf函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在lOS类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用“位或”运算符“I”组合多个格式标志<br><br><strong>&nbsp;&nbsp;&nbsp;</strong>4、可以看到：对输出格式的控制，既可以用控制符(如例2)，也可以用cout流的有关成员函数(如例3)，二者的作用是相同的。控制符是在头文件mmamp中定义的，因此用控制符时，必须包含iomanip头文件。cout流的成员函数是在头文件iostream中定义的，因此只需包含头文件iostream，不必包含iomanip。许多程序人员感到使用控制符方便简单，可以在一个cout输出语句中连续使用多种控制符。<br><br><strong>&nbsp;&nbsp;&nbsp;</strong>5、关于输山格式的控制，在使用中还会遇到一些细节问题，不可能在这里全部涉及。在遇到问题时，请查阅专门手册或上机试验一下即可解决。</p><p>六、用流成员函数put输出字符&nbsp;</p><p><strong>&nbsp;&nbsp;&nbsp;</strong>在程序中一般用cout和插入运算符“&lt;&lt;”实现输出，cout流在内存中有相应的缓冲区。有时用户还有特殊的输出要求，例如只输出一个字符。ostream类除了提供上面介绍过的用于格式控制的成员函数外，还提供了专用于输出单个字符的成员函数put。<strong>如： cout.put('a')；<br>&nbsp;&nbsp;&nbsp;</strong>调用该函数的结果是在屏幕上显示一个字符a。put函数的参数可以是字符或字符的ASCII代码(也可以是一个整型表达式)。<strong>如： cout.put(65+32)；<br></strong>也显示字符a，因为97是字符a的ASCII代码。&nbsp;</p><p>可以在一个语句中连续调用put函数。如<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>cout.put(71)，put(79)．put(79)．put(68).put('\\n')；<br>在屏幕上显示GOOD。&nbsp;</p><p><strong>例4 有一个字符串\"BASIC\"，要求把它们按相反的顺序输出。<br>程序如下：</strong></p><blockquote><p>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>char *a=\"BASIC\";<strong>//字符指引指向'B'<br></strong>&nbsp;&nbsp; for(int i=4;i&gt;=0;i--)<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout.put(*(a+i));<strong>//从最后一个字符开始输出<br>&nbsp;&nbsp;&nbsp;</strong>cout.put('\\n');<br><strong>&nbsp;&nbsp;&nbsp;</strong>return 0; }&nbsp;</p></blockquote><p>运行时在屏幕上输出：<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CISAB</strong></p><p><strong>&nbsp;&nbsp;例4也可以改用putchar函数实现。程序如下：</strong></p><blockquote><p>#include&lt;iostream&gt;&nbsp;<strong>//也可以用#include&lt;stdio．h&gt;，同时不要下一行<br></strong>usmg namespace std；<br>int main()<br><strong></strong>{ char *a=\"BASIC\"；<br><strong>&nbsp;&nbsp;</strong>for(int i=4；i&gt;=0；i--)<br><strong>&nbsp;&nbsp;&nbsp;</strong>putchar(*(a+i))；<br><strong>&nbsp;&nbsp;&nbsp;</strong>putchar('\\n')；}</p></blockquote><p><strong>&nbsp;&nbsp;&nbsp;</strong>运行结果与前相同，成员函数put不仅可以用COUT流对象来调用，而且也可以用ostream类的其他流对象调用。</p><p align=\"center\">第二十一讲：标准输入流&nbsp;</p><blockquote><p>本讲基本要求&nbsp;</p><p>&nbsp;&nbsp;&nbsp; * 掌握：标准输入在C++程序中的应用。<br>重点、难点<br>&nbsp;&nbsp;&nbsp; ◆标准输入在C++程序中的应用。&nbsp;</p></blockquote><p>标准输入流是从标准输入设备(键盘)流向程序的数据。&nbsp;</p><p>一、cin流&nbsp;</p><p><strong>&nbsp;&nbsp;&nbsp;</strong>在头文件iostream．h中定义了cin，cout，cerr，clog4个流对象，cin输人流，cout，cerr，clog是输出流。关于coutl，cerr，clog的使用方法已在上一讲中介绍。<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin是istream类的对象，它从标准输入设备(键盘)获取数据，程序中的变量通过流提取符“&gt;&gt;”从流中提取数据。流提取符“&gt;&gt;”从流中提取数据时通常跳过输人流中的空格、tab键、换行符等空白字符。注意：只有在输入完数据再按回车键后，改行数据才被送人键盘缓冲区，形成输入流，提取运算符“&gt;&gt;”才能从中提取数据。需要注意保证从流中读取数据能雁常进行。<br><strong>例如</strong>：<strong>&nbsp;&nbsp;&nbsp;</strong>int a,b；<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>cin&gt;&gt;a&gt;&gt;b;<strong>// 若从键盘上输入 21 abc</strong><strong>出错<br></strong><strong>说明：<br>&nbsp;&nbsp;&nbsp;</strong>只有在正常状态时，才能从输入流中提取数据。<br><strong>&nbsp;&nbsp;&nbsp;</strong>当遇到无效字符或遇到文件结束符(不是换行符，是文件中的数据已读完)时，输人流cin就处于出错状态，即无法正常提取数据。此时对cin流的所有提取操作都将终止。在IBMPC及其兼容机中，以Ctrl+Z表示文件结束符。在UNIX和Macintosh系统中，以Ctrl+D表示文件结束符。当输人流cin处于出错状态时，如果测试cin的值，可以发现它的值为false(假)，即cia为O值。如果输入流在正常状态，cin的值为true(真)，即cin为一个非0值。可以通过测试cin的值，判断流对象是否处于正常状态和提取操作是否成功。</p><p>如:&nbsp;<strong>&nbsp;&nbsp;&nbsp;</strong>if(!cin)<strong>//流cin处于出错状态，无法正常提取数据<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"error”；&nbsp;</p><blockquote><p><strong>例5 通过测试cin的真值，判断流对象是否处于正常状态。<br></strong>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>float grade;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"enter grade:\";<br><strong>&nbsp;&nbsp;&nbsp;</strong>while(cin&gt;&gt;grade)<strong>//如果能从cin流读取数据cin的值为真，执行循环体<br>&nbsp;&nbsp;&nbsp;</strong>{<strong>&nbsp;</strong>if(grade&gt;=85) cout&lt;&lt;grade&lt;&lt;\" GOOD!\"&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>if(grade&lt;60) cout&lt;&lt;grade&lt;&lt;\" fail!\"&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"enter grade:\";<br><strong>&nbsp;&nbsp;&nbsp;</strong>}<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The end.\"&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>return 0;}&nbsp;</p></blockquote><p><strong>&nbsp;&nbsp;&nbsp;</strong>流提取符“&gt;&gt;”不断地从输人流中提取数据(每次提取一个浮点数)，如果成功，就赋给变量grade，此时cin为真，若不成功则cin为假。如果输入文件结束符，表示数据已完。</p><blockquote><p><strong>运行情况如下：<br>&nbsp;&nbsp;&nbsp;</strong>enter grade：67<br><strong>&nbsp;&nbsp;&nbsp;</strong>enter grade：89／<br><strong>&nbsp;&nbsp;&nbsp;</strong>89 GOOD!<br><strong>&nbsp;&nbsp;&nbsp;</strong>enter grade：56s／<br><strong>&nbsp;&nbsp;&nbsp;</strong>56 fail!<br><strong>&nbsp;&nbsp;&nbsp;</strong>entergrade：100<br><strong>&nbsp;&nbsp;&nbsp;</strong>100 GOOD!<br><strong>&nbsp;&nbsp;&nbsp;</strong>enter grade：^Z<strong>//输入文件结束符<br>&nbsp;&nbsp;&nbsp;</strong>The end．&nbsp;</p></blockquote><p>在遇到文件结束符时，程序结束。如果某次输入的数据为： enter grade：100/2&nbsp;<strong>（回车）</strong><br>流提取符“&gt;&gt;”提取100，赋给grade，进行if语句的处理。然后再遇到“/”，认为是无效字符，cin返回o。循环结束，输出\"Theend．”。<br>在不同的C++系统下运行此程序，在最后的处理上有些不同。以上是在GCC环境下运行程序的结果，如果在VC++环境下运行此程序，在键人Ctrl+z时，程序运行马上结束，不输出”Theend．”。</p><p>二、 用于字符输入的流成员函数&nbsp;</p><p>除了可以用CIB输入标准类型的数据外，还可以用istream类流对象的一些成员函数，实现字符的输入。&nbsp;</p><p><strong>1、用get函数读入一个字符<br></strong>流成员函数get有3种形式：无参数的，有一个参数的，有3个参数的。&nbsp;</p><p>(1)不带参数的get函数&nbsp;</p><blockquote><p><strong>其调用形式为：</strong><strong>cin.get()//用来从指定的输人流中提取一个字符(包括空白字符)函数的返回值就是读入的字符。</strong></p></blockquote><p><strong>&nbsp;&nbsp;&nbsp;</strong>若遇到输入流中的文件结束符，则函数值返回文件结束标志EOF(End Of File)，一般以-1代表EOF，用-1而不用0或正值，是考虑到不与字符的ASCII代码混淆，但不同的C++系统所用的EOF值有可能不同。</p><p><strong>例6 用get函数读人字符。<br>&nbsp;&nbsp;&nbsp;</strong>从键盘输入一行字符，用cin．get()逐个读人字符，将读入字符赋给字符变量c。如果c的值不等于EOF(EOF是在lostream头文件中定义的符号常量，代表-1)，表示已成功地读入一个有效字符，然后通过put函数输出该字符。</p><blockquote><p>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>char c;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"enter a sentence:\"&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>while((c=cin.get())!=EOF)<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout.put(c);<br><strong>&nbsp;&nbsp;&nbsp;</strong>return 0; }&nbsp;</p><p><strong>运行情况如下：<br>&nbsp;&nbsp;&nbsp;</strong>enter a sentence：<br><strong>&nbsp;&nbsp;&nbsp;</strong>I study C++ very hard． (输入一行字符)<br><strong>&nbsp;&nbsp;&nbsp;</strong>I study C++ very hard． (输出该行字符)<br><strong>&nbsp;&nbsp;&nbsp;</strong>^Z／(程序结束)&nbsp;</p></blockquote><p><strong>&nbsp;&nbsp;&nbsp;</strong>C语言中的getchar函数与流成员函数cin．get()的功能相同，C++保留厂C的这种用法，可以用getchar(c)从键盘读取一个字符赋给变量c。</p><p><strong>(2)有一个参数的get函数</strong></p><blockquote><p><strong>其调用形式为</strong>：<br><strong>&nbsp;&nbsp;&nbsp;cin.get(ch)// 其作用是从输人流中读取一个字符，赋给字符变量ch。</strong></p></blockquote><p><strong>&nbsp;&nbsp;&nbsp;</strong>如果读取成功则函数返回非。值(真)，如失败(遇文件结束符)则函数返回。值(假)。例6可以改写如下：</p><blockquote><p>#include&lt;iostream&gt;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>char c；<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"enter a sentence：\"&lt;&lt;endl；<br><strong>&nbsp;&nbsp;&nbsp;</strong>while(cin.get(c))<strong>//读取—个字符赋给字符变量c，如果读取成功,cin.get(c)为真<br>&nbsp;&nbsp;&nbsp;</strong>{<strong>&nbsp;</strong>cout.put(c)；}<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"end\"&lt;&lt;endl：<br><strong>&nbsp;&nbsp;&nbsp;</strong>return 0；}&nbsp;</p></blockquote><p>(3)有3个参数的get函数&nbsp;</p><p><strong>其调用形式为<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>cin.get(字符数组，字符个数n，终止字符)<br>&nbsp;&nbsp;&nbsp;</strong><strong>或<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cin.get(字符指针，字符个数n，终止字符)</strong></p><p><strong>&nbsp;&nbsp;&nbsp;</strong>其作用是从输入流中读取n-1个字符，赋给指定的字符数组(或字符指针指向的数组)，如果在读取n-1个字符之前遇到指定的终止字符，则提前结束读取。如果读取成功则函数返回非0值(真)，如失败(遇文件结束符)则函数返回0值(假)。再将例6改写如下：</p><blockquote><p>#include&lt;iostream&gt;<br>using namespace std；<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>char ch[20]；<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"enter a sentence：”&lt;&lt;endl；<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.get(ch，10，'\\n')；<strong>//指定换行符为终止字符<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;ch&lt;&lt;endl；<br><strong>&nbsp;&nbsp;&nbsp;</strong>return()； }&nbsp;</p><p>运行情况如下：<br><strong>&nbsp;&nbsp;&nbsp;</strong>enter a sentence：<br><strong>&nbsp;&nbsp;&nbsp;</strong>I study C++ very hard．／<br><strong>&nbsp;&nbsp;&nbsp;</strong>I study C&nbsp;</p></blockquote><p><strong>&nbsp;&nbsp;&nbsp;</strong>在输人流中有22个字符，但由于在get函数中指定的n为10，读取n-1个(即9个)字符并赋给字符数组ch中前9个元素。有人可能要问：指定n=10，为什么只读取9个字符呢?因为存放的是一个字符串，因此在9个字符之后要加入一个字符中结束标志 '\\0'，实际上存放到数组中的是10个字符。请读者思考：如果不加入字符串结束标志，会出现什么情况?结果是：在用\"cout&lt;&lt;ch”；输出数组中的字符时，不是输出读人的字符串，而是数组中的全部元素。读者可以上机检查一下ch[9](即数组中第10个元素)的值是什么?<br>如果输入:&nbsp;<strong>abcde／<br><br>2．用成员函数getline函数读入一行字符<br>&nbsp;&nbsp;&nbsp;</strong>getline函数的作用是从输人流中读取一行字符，其用法与带3个参数的get函数类 似。<br><br><strong>&nbsp;&nbsp;&nbsp;</strong>即:&nbsp;<strong>cin.getline(字符数组(或字符指针)，字符个数n，终止标志字符)</strong></p><blockquote><p><strong>例7 用getline函数读人一行字符。<br></strong>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>char ch[20];<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"enter a sentence:\"&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin&gt;&gt;ch;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The string read with cin is:\"&lt;&lt;ch&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.getline(ch,20,'/');//读19个字符或遇'／'结束<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The second part is:\"&lt;&lt;ch&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.getline(ch,20); //读l9个字符或遇'/n'，结束<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The third part is:\"&lt;&lt;ch&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>return 0; }&nbsp;</p><p><strong>程序运行情况如下：<br></strong>enter a sentence：I like C++．/I study C++．/I am happy．<strong>(回车)<br></strong>The stung read with cin is：I<br>The second part is：like C++．<br>The third part is：I study C++．／I am h&nbsp;</p></blockquote><p><br><strong>有几点说明并请思考：<br>&nbsp;&nbsp;&nbsp;</strong>1、如果第2个cin．getline函数也写成cin．getline(ch，20，'/')，输出结果会如何?<br>此时最后一行的输出为:<br>The third part is：I study C++&nbsp;</p><p><strong>&nbsp;&nbsp;&nbsp;</strong>2、如果在用cin．getline(ch，20，'/')从输入流读取数据时，遇到回车键('＼n')，是否结束读取?结论是此时'/n'不是结束标志。'/n'被作为一个字符被读人。</p><p><strong>&nbsp;&nbsp;&nbsp;</strong>3、用gefiine函数从输入流读字符时，遇到终止标志字符时结束，指针移到该终止标志字符之后，下一个getline函数将从该终止标志的下一个字符开始接着读人，如本程序运行结果所示那样。如果用cln．get函数从输人流读字符时，遇终止标志字符时停止读取，指针不向后移动，仍然停留在原位置。下一次读取时仍从该终止标志字符开始。这是getline函数和get函数不同之处。<strong>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;</strong>因此用get函数时要特别注意，必要时用其他方法跳过该终止标志字符(如用下面介绍的ignore函数。但一般来说还是用getline函数更方便。<br><br><strong>&nbsp;&nbsp;&nbsp;</strong>4、请比较用\"cin&lt;&lt;”和用成员函数cin.getline()读数据的区别。用\"cin&lt;&lt;”读数据时以空白字符(包括空格、tab键、回车键)作为终止标志，而用cln．gefline()读数据时连续读取一系列字符，可以包括空格。用\"cin&lt;&lt;”可以读取C++的标准类型的各类型数据(如果经过重载，还可以用于输入自定义类型的数据)，而用cin.getline()只用于输入字符型数据。</p><p>三、istrearn类的其他成员函数&nbsp;</p><p><strong>&nbsp;&nbsp;&nbsp;</strong>除了以上介绍的用于读取数据的成员函数外，lstream类还有其他在输入数据时用得着的一些成员函数。常用的有以下几种：</p><p><strong>1．eof函数<br>&nbsp;&nbsp;&nbsp;</strong>eof是end of file的缩写，表示“文件结束”。从输人流读取数据，如果到达文件末尾(遇文件结束符)，eof函数值为非零值(表示真)，否则为o(假)。这个函数是很有用的，经常会用到。</p><p><strong>例8 逐个读入一行字符，将其中的非空格字符输出。<br></strong>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>char c;<br><strong>&nbsp;&nbsp;&nbsp;</strong>while(!cin.eof())<strong>&nbsp;&nbsp; //eof()为假表示未遇到文件结束符<br>&nbsp;&nbsp;&nbsp;</strong>if((c=cin.get())!=' ')<strong>//检查读入的字符是否为空格字符<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>cout.put(c);<br><strong>&nbsp;&nbsp;&nbsp;</strong>return 0; }&nbsp;</p><p><strong>运行情况如下：<br></strong><strong>&nbsp;&nbsp; C++ is very interesting．<br>&nbsp;&nbsp; C++ is veryinteresting．<br>&nbsp;&nbsp; ^z(结束)</strong></p><p><strong>2．peek函数<br>&nbsp;&nbsp;&nbsp;</strong>peek是“观察”的意思，peek函数的作用是观测下一个字符。其调用形式为<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>c=cin．peek()；<br></strong><strong>&nbsp;&nbsp;&nbsp;</strong>cin.peek函数的返回值是指针指向的当前字符，但它只是观测，指针仍停留在当前位置，并不后移。如果要访问的字符是文件结束符，则函数值是EOF(-1)。</p><p><strong>3．putback函数<br>&nbsp; 其调用形式为<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong><strong>cin．putback(ch)；<br></strong><strong>&nbsp;&nbsp;&nbsp;</strong>其作用是将前面用get或getline函数从输人流中读取的字符ch返回到输人流，插入到当前指针位置，以供后面读取。</p><blockquote><p><strong>例9 peek函数和putback函数的用法。<br></strong>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>char c[20];<br><strong>&nbsp;&nbsp;&nbsp;</strong>int ch;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"please enter a sentence.\"&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.getline(c,15,'/');<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The first part is:\"&lt;&lt;c&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>ch=cin.peek();<strong>//观看当前字符<br>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The next character(ASCII code) is:\"&lt;&lt;ch&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.putback(c[0]);<strong>//将'I'插入到指针所指处<br>&nbsp;&nbsp;&nbsp;</strong>cin.getline(c,15,'/');<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The second part is:\"&lt;&lt;c&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>return 0; }&nbsp;</p><p><strong>运行情况如下：<br>&nbsp;&nbsp;&nbsp;</strong>please enter a sentence：<br><strong>&nbsp;&nbsp;&nbsp;</strong>I am a boy．/I am astudent．/<strong>(回车)<br>&nbsp;&nbsp;&nbsp;</strong>The first part is：I am a boy．<br><strong>&nbsp;&nbsp;&nbsp;</strong>The next chamcter(ASCII code) is:32<strong>(下一个字符是空格)<br>&nbsp;&nbsp;&nbsp;</strong>The second part is：I an a student</p></blockquote><p align=\"left\"><strong>4．ignore函数</strong></p><p align=\"left\"><strong>&nbsp;&nbsp;&nbsp;其调用形式为: cin.ignore(n，终止字符)// 函数作用是跳过输人流中n个字符，或在遇到指定的终止字符时提前结束(此时跳过包括终止字符在内的若干字符)</strong>。</p><p align=\"left\"><strong>如:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ighore(5，A，)</strong><strong>//跳过输入流中5个字符，遇A后就不再跳了<br></strong><strong>&nbsp;&nbsp;&nbsp;</strong>也可以不带参数或只带一个参数。如<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ignore()(n默认值为1，终止字符默认为EOF)<br>&nbsp;&nbsp;&nbsp;</strong>相当于:<strong>&nbsp;ignore(1，EOF)</strong></p><p><strong>例10 用ignore函数跳过输入流中的字符。<br></strong>先看不用ignore函数的情况：&nbsp;</p><blockquote><p>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>char ch[20];<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.get(ch,20,'/');<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The first part is:\"&lt;&lt;ch&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.get(ch,20,'/');<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The second part is:\"&lt;&lt;ch&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>return 0;}&nbsp;</p><p><strong>运行结果如下：<br>&nbsp;&nbsp;&nbsp;</strong>I like C++．/I study C++．/I am happy．<br><strong>&nbsp;&nbsp;&nbsp;</strong>The first part is: I like C++<br><strong>&nbsp;&nbsp;&nbsp;</strong>The second part is<strong>(字符数组ch中没有从输人流中读取有效字符)</strong></p></blockquote><p><strong>&nbsp;&nbsp;&nbsp;</strong>前面已对此作过说明。如果希望第二个tin.get函数能读取”I study C++．”，就应该设法跳过输人流中第一个'/'可以用ignore函数来实现此日的，将程序改为:</p><blockquote><p>#include &lt;iostream&gt;<br>using namespace std;<br>int main()<br><strong></strong>{<strong>&nbsp;</strong>char ch[20];<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.get(ch,20,'/');<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The first part is:\"&lt;&lt;ch&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.ignore(); //跳过输入流中一个字符<br><strong>&nbsp;&nbsp;&nbsp;</strong>cin.get(ch,20,'/');<br><strong>&nbsp;&nbsp;&nbsp;</strong>cout&lt;&lt;\"The second part is:\"&lt;&lt;ch&lt;&lt;endl;<br><strong>&nbsp;&nbsp;&nbsp;</strong>return 0; }&nbsp;</p><p><strong>运行结果如下：<br>&nbsp;&nbsp;&nbsp;</strong>I like C++．/I study C++．/I am happy．<br><strong>&nbsp;&nbsp;&nbsp;</strong>The first part is：I like C++．<br><strong>&nbsp;&nbsp;&nbsp;</strong>The second part is: I study C++．</p></blockquote><p>以上介绍的各个成员函数，不仅可以用cln流对象来调用，而且也可以用istream类的其他流对象调用。</p></div></div></td></tr></tbody></table></span><table><tbody><tr><td></td></tr></tbody></table></td></tr><tr><td align=\"left\"><a name=\"anchordoc1\" id=\"anchordoc1\"></a></td></tr></tbody></table>"
    }
  ]
}
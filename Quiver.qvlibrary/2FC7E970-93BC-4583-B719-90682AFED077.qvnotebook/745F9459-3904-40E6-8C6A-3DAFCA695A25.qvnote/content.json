{
  "title": "C++箴言:绝不在构造或析构期调用虚函数",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); line-height: 1.7; font-size: 14px; font-family: arial;\"><div class=\"h pbm\" style=\"word-wrap: break-word; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin: 0px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(205, 205, 205); color: rgb(68, 68, 68); font-family: Tahoma, 'Microsoft Yahei', Simsun; font-size: 12px; line-height: 18px; padding-bottom: 10px !important;\"><h1 class=\"ph\" style=\"word-wrap: break-word; padding: 15px 0px 10px; margin: 0px; font-size: 20px; font-family: 'Microsoft YaHei', 'Hiragino Sans GB', STHeiti, Tahoma, SimHei, sans-serif; font-weight: 100; color: rgb(0, 0, 0);\"><span style=\"font-family: Tahoma, 'Microsoft Yahei', Simsun; font-size: 14px;\">C++的基础知识，不过很多时候都不以为然，没去关注它，但有些问题就是由此造成的。</span></h1></div><div id=\"blog_article\" class=\"d cl\" style=\"word-wrap: break-word; padding: 0px; margin: 15px 0px; zoom: 1; min-height: 100px; line-height: 1.8; font-family: Tahoma, 'Microsoft Yahei', Simsun;\"><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">1.首先说到构造函数和析构函数的顺序<br style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">当创建派生类的对象时，首先执行基类的构造函数，然后执行派生类的构造函数。当撤销对象时，则先执行派生类的析构函数，然后再执行基类的析构函数。</div></div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">2.C++箴言:绝不在构造或析构期调用虚函数</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">如果在基类构造函数中调用虚拟函数，调用到的版本将是基类实现的版本，而不是派生类的实现；反之，在析构函数中调用虚拟函数时，调用到的也是基类的版本。</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><span style=\"word-wrap: break-word; padding: 0px; margin: 0px; font-family: Arial; line-height: 24px;\">因为基类的构造函数在派生类构造函数之前执行，当基类构造函数运行时，派生类数据成员还没有被初始化。</span></div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><span style=\"word-wrap: break-word; padding: 0px; margin: 0px; font-family: Arial; line-height: 24px;\">同样的原因也适用于析构过程。一旦派生类析构函数运行，这个对象的派生类数据成员就被视为未定义的值，所以 C++ 就将它们视为不再存在。在进入基类析构函数时，对象就成为一个基类对象，C++ 的所有配件——虚函数，dynamic_casts 等——都如此看待它。</span></div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><span style=\"word-wrap: break-word; padding: 0px; margin: 0px; font-family: Arial; line-height: 24px;\"><br style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"></span></div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><span style=\"word-wrap: break-word; padding: 0px; margin: 0px; font-family: Arial; line-height: 24px;\">android framework中大量使用了C++及其特性，估计也难免也有上面的问题。如</span></div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><span style=\"word-wrap: break-word; padding: 0px; margin: 0px; line-height: 1.8em;\">ConsumerBase::~ConsumerBase() {</span></div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><span class=\"Apple-tab-span\" style=\"word-wrap: break-word; padding: 0px; margin: 0px; white-space: pre;\">\t</span>CB_LOGV(\"~ConsumerBase\");</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp;&nbsp;<b style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">abandon</b>();</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">}</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">//abandon不是虚拟函数，OK</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">void ConsumerBase::abandon() {</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; CB_LOGV(\"abandon\");</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; Mutex::Autolock lock(mMutex);</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><br style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"></div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; if (!mAbandoned) {</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">abandonLocked</b>();</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; &nbsp; &nbsp; mAbandoned = true;</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; }</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">}</div></div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">//<span style=\"word-wrap: break-word; padding: 0px; margin: 0px; line-height: 1.8em;\">abandonLocked是虚拟函数，有危险</span></div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">void ConsumerBase::abandonLocked() {</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\"><span class=\"Apple-tab-span\" style=\"word-wrap: break-word; padding: 0px; margin: 0px; white-space: pre;\">\t</span>CB_LOGV(\"abandonLocked\");</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; for (int i =0; i &lt; BufferQueue::NUM_BUFFER_SLOTS; i++) {</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<b style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">freeBufferLocked</b>(i);//也是虚拟函数，有危险</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; }</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; // disconnect from the BufferQueue</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; mBufferQueue-&gt;consumerDisconnect();</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">&nbsp; &nbsp; mBufferQueue.clear();</div><div style=\"word-wrap: break-word; padding: 0px; margin: 0px;\">}</div></div></div></div><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span title=\"neteasefooter\" style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span id=\"netease_mail_footer\"><div id=\"netease_mail_footer\"><div style=\"border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); padding: 10px 5px; color: rgb(102, 102, 102); line-height: 22px;\">来自网易手机号码邮箱<a id=\"mobile_set\" sys=\"1\" log=\"1\" logid=\"free_sms_20120504\" href=\"http://shouji.163.com/\" target=\"_blank\" style=\"color: rgb(0, 0, 255);\">了解更多</a></div></div></span></span>"
    }
  ]
}
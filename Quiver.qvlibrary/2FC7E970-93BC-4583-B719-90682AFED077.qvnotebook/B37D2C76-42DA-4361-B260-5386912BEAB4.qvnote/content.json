{
  "title": "C++中的位拷贝与值拷贝浅谈",
  "cells": [
    {
      "type": "text",
      "data": "<div class=\"article_title\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><h1><br></h1></div><div class=\"article_manage\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span class=\"link_report\"></span></div><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-family: 'Comic Sans MS';\">&nbsp; &nbsp; &nbsp; &nbsp;位拷贝拷贝的是地址（也叫浅拷贝），而值拷贝则拷贝的是内容（深拷贝）。深拷贝和浅拷贝可以简单理解为：<span style=\"color: rgb(255, 0, 0);\">如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝</span>，反之，没有重新分配资源，就是浅拷贝。</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-family: 'Comic Sans MS';\">&nbsp; &nbsp; &nbsp; &nbsp;位拷贝，及\"bitwise&nbsp;assignment\"是指将一个对象的内存映像按位原封不动的复制给另一个对象，所谓值拷贝就是指，将原对象的值复制一 份给新对象。&nbsp;在用\"bitwise&nbsp;assignment\"时会直接将对象的内存映像复制给另一个对象，这样两个对象会指向同一个内存区域，当一个对象 被释放后，另一个对象的指针会成为野指针（悬垂指针）。这时，就应该编写operator=和copy&nbsp;constructor来实现值拷贝 。<br>&nbsp; &nbsp; &nbsp; 默认的拷贝构造函数”和“缺省的赋值函数”均采用“位拷贝”而非“值拷贝”的方式来实现，倘若类中含有指针变量，这两个函数注定将出错。<br>&nbsp; &nbsp; 当用一个已初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用。也就是说，当类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：<br></span></p><ol style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><li>一个对象以值传递的方式传入函数体&nbsp;</li><li>一个对象以值传递的方式从函数返回&nbsp;</li><li>一个对象需要通过另外一个对象进行初始化。&nbsp;</li></ol><span style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">&nbsp; &nbsp; 如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的位拷贝。位拷贝又称浅拷贝。自定义拷贝构造函数是一种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率。</span><br style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">&nbsp; &nbsp; &nbsp;</span><span style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">如果没有自定义复制构造函数，则系统会创建默认的复制构造函数，但系统创建的默认复制构造函数只会执行<span lang=\"EN-US\">“</span>位拷贝<span lang=\"EN-US\">”</span>，即将被拷贝对象的数据成员的值一一赋值给新创建的对象，若该类的数据成员中有指针成员，则会使得新的对象的指针所指向的地址与被拷贝对象的指针所指向的地址相同，<span lang=\"EN-US\">delete</span>该指针时则会导致两次重复<span lang=\"EN-US\">delete</span>而出错。下面拿这个经典示例：</span><span style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"></span><div class=\"dp-highlighter bg_cpp\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><div class=\"bar\"><div class=\"tools\"><b>[cpp]</b>&nbsp;<a href=\"http://blog.csdn.net/wangqiulin123456/article/details/8464082#\" class=\"ViewSource\" title=\"view plain\">view plain</a><a href=\"http://blog.csdn.net/wangqiulin123456/article/details/8464082#\" class=\"CopyToClipboard\" title=\"copy\">copy</a><a href=\"http://blog.csdn.net/wangqiulin123456/article/details/8464082#\" class=\"PrintSource\" title=\"print\">print</a><a href=\"http://blog.csdn.net/wangqiulin123456/article/details/8464082#\" class=\"About\" title=\"?\">?</a></div></div><ol class=\"dp-cpp\" start=\"1\"><li class=\"alt\">Class&nbsp;String{&nbsp;&nbsp;</li><li class=\"\"><span class=\"keyword\">public</span>:&nbsp;&nbsp;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;String(<span class=\"keyword\">const</span>&nbsp;<span class=\"datatypes\">char</span>&nbsp;*ch=NULL);<span class=\"comment\">//默认构造函数</span>&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;String(<span class=\"keyword\">const</span>&nbsp;String&nbsp;&amp;str);<span class=\"comment\">//拷贝构造函数</span>&nbsp;&nbsp;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;~String(<span class=\"keyword\">void</span>);&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;String&nbsp;&amp;operator=(<span class=\"keyword\">const</span>&nbsp;String&nbsp;&amp;str);<span class=\"comment\">//赋值函数</span>&nbsp;&nbsp;</li><li class=\"alt\"><span class=\"keyword\">private</span>:&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;<span class=\"datatypes\">char</span>&nbsp;*m_data;&nbsp;&nbsp;</li><li class=\"alt\">};&nbsp;&nbsp;</li></ol></div><p align=\"left\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-family: 'Comic Sans MS';\">如果以String为例定义strA和strB</span></p><p align=\"left\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: 10pt;\"></span></p><div class=\"dp-highlighter bg_cpp\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><div class=\"bar\"><div class=\"tools\"><b>[cpp]</b>&nbsp;<a href=\"http://blog.csdn.net/wangqiulin123456/article/details/8464082#\" class=\"ViewSource\" title=\"view plain\">view plain</a><a href=\"http://blog.csdn.net/wangqiulin123456/article/details/8464082#\" class=\"CopyToClipboard\" title=\"copy\">copy</a><a href=\"http://blog.csdn.net/wangqiulin123456/article/details/8464082#\" class=\"PrintSource\" title=\"print\">print</a><a href=\"http://blog.csdn.net/wangqiulin123456/article/details/8464082#\" class=\"About\" title=\"?\">?</a></div></div><ol class=\"dp-cpp\" start=\"1\"><li class=\"alt\"><span class=\"datatypes\">int</span>&nbsp;main()&nbsp;&nbsp;</li><li class=\"\">{&nbsp;&nbsp;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;strA(<span class=\"string\">\"hello\"</span>);&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;strB(<span class=\"string\">\"world\"</span>);&nbsp;&nbsp;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;strB&nbsp;=&nbsp;strA;&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//&nbsp;结果导致&nbsp;&nbsp;&nbsp;strA&nbsp;和&nbsp;&nbsp;&nbsp;&nbsp;strB&nbsp;的指针都指向了同一个地址</span>&nbsp;&nbsp;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//&nbsp;函数结束析构时</span>&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//&nbsp;同一个地址被delete两次</span>&nbsp;&nbsp;</li><li class=\"alt\">&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;0;&nbsp;&nbsp;</li><li class=\"alt\">}&nbsp;&nbsp;</li></ol></div><p align=\"left\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: 12px;\">&nbsp;</span><span style=\"font-family: 'Comic Sans MS';\"><span style=\"font-size: 12px;\">&nbsp;</span>&nbsp;&nbsp;如果不主动编写拷贝构造函数和赋值函数，编译器将以“位拷贝”</span><span style=\"font-family: 'Comic Sans MS';\">的方式自动生成缺省的函数。倘若类中含有指针变量，那么这两个缺省的函数就隐含了错误。以类String的两个对象strA,strB为例，假设strA.m_data的内容为“hello”，strB.m_data的内容为“world”。 现将strA赋给strB，缺省赋值函数的“位拷贝”意味着执行strB.m_data =strA.m_data。这将造成三个错误：</span></p><ul style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><li><span style=\"font-family: 'Comic Sans MS';\">strB.m_data 原有的内存没被释放，造成内存泄露；</span></li></ul><ul style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><li><span style=\"font-family: 'Comic Sans MS';\">strB.m_data和strA.m_data指向同一块内存，strA或strB任何一方变动都会影响另一方；</span></li></ul><ul style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><li><span style=\"font-family: 'Comic Sans MS';\">在对象被析构时，m_data被释放了两次。&nbsp;</span></li></ul><span lang=\"EN-US\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-family: 'Comic Sans MS';\">对于编译器，如果不主动编写拷贝函数和赋值函数，它会以<span style=\"color: rgb(255, 0, 0);\">位拷贝</span>的方式自动生成缺省的函数。</span></span>"
    }
  ]
}
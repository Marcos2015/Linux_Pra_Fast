{
  "title": "C++中this指针的用法.",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); line-height: 1.7; font-size: 14px; font-family: arial;\"><div class=\"article_title\" style=\"margin: 5px 0px; font-size: 20px; line-height: 30px; font-family: 'Microsoft YaHei';\"><span class=\"ico ico_type_Repost\" style=\"display: inline-block; width: 19px; height: 19px; margin: 0px 2px 0px 0px; background-image: url(http://static.blog.csdn.net/images/ico_Repost.gif); vertical-align: middle; background-position: 0px 0px; background-repeat: no-repeat no-repeat;\"></span><span style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">&nbsp;this指针只能在一个类的成员函数中调用，它表示当前对象的地址。下面是一个例子：&nbsp;</span></div><div id=\"article_content\" class=\"article_content\" style=\"margin: 20px 0px 0px; line-height: 26px; font-family: Arial; color: rgb(51, 51, 51);\"><pre><span style=\"color: rgb(0, 0, 0);\">    </span><span style=\"color: rgb(0, 0, 255);\">void</span><span style=\"color: rgb(0, 0, 0);\"> Date::setMonth( </span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> mn ) \n    { \n     month </span><span style=\"color: rgb(0, 0, 0);\">=</span><span style=\"color: rgb(0, 0, 0);\"> mn; </span><span style=\"color: rgb(0, 128, 0);\">//</span><span style=\"color: rgb(0, 128, 0);\"> 这三句是等价的 </span><span style=\"color: rgb(0, 128, 0);\">\n</span><span style=\"color: rgb(0, 0, 0);\">     </span><span style=\"color: rgb(0, 0, 255);\">this</span><span style=\"color: rgb(0, 0, 0);\">-&gt;</span><span style=\"color: rgb(0, 0, 0);\">month </span><span style=\"color: rgb(0, 0, 0);\">=</span><span style=\"color: rgb(0, 0, 0);\"> mn; \n     (</span><span style=\"color: rgb(0, 0, 0);\">*</span><span style=\"color: rgb(0, 0, 255);\">this</span><span style=\"color: rgb(0, 0, 0);\">).month </span><span style=\"color: rgb(0, 0, 0);\">=</span><span style=\"color: rgb(0, 0, 0);\"> mn; \n    } \n\n</span><span style=\"color: rgb(128, 0, 128);\">1</span><span style=\"color: rgb(0, 0, 0);\">. this只能在成员函数中使用。\n全局函数，静态函数都不能使用this。\n实际上，成员函数默认第一个参数为T</span><span style=\"color: rgb(0, 0, 0);\">*</span><span style=\"color: rgb(0, 0, 0);\"> </span><span style=\"color: rgb(0, 0, 255);\">const</span><span style=\"color: rgb(0, 0, 0);\"> register </span><span style=\"color: rgb(0, 0, 255);\">this</span><span style=\"color: rgb(0, 0, 0);\">。\n如： \n</span><span style=\"color: rgb(0, 0, 255);\">class</span><span style=\"color: rgb(0, 0, 0);\"> A{</span><span style=\"color: rgb(0, 0, 255);\">public</span><span style=\"color: rgb(0, 0, 0);\">: </span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> func(</span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> p){}};\n其中，func的原型在编译器看来应该是： </span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> func(A</span><span style=\"color: rgb(0, 0, 0);\">*</span><span style=\"color: rgb(0, 0, 0);\"> </span><span style=\"color: rgb(0, 0, 255);\">const</span><span style=\"color: rgb(0, 0, 0);\"> register </span><span style=\"color: rgb(0, 0, 255);\">this</span><span style=\"color: rgb(0, 0, 0);\">, </span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> p); \n</span><span style=\"color: rgb(128, 0, 128);\">2</span><span style=\"color: rgb(0, 0, 0);\">. 由此可见，this在成员函数的开始前构造的，在成员的结束后清除。\n这个生命周期同任一个函数的参数是一样的，没有任何区别。\n当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：\nA a;\na.func(</span><span style=\"color: rgb(128, 0, 128);\">10</span><span style=\"color: rgb(0, 0, 0);\">);\n此处，编译器将会编译成： A::func(</span><span style=\"color: rgb(0, 0, 0);\">&amp;</span><span style=\"color: rgb(0, 0, 0);\">a, </span><span style=\"color: rgb(128, 0, 128);\">10</span><span style=\"color: rgb(0, 0, 0);\">);\n嗯，看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化的，因此，this指针的传递效率比较高－－如vc通常是通过ecx寄存器来传递this参数。\n\n</span><span style=\"color: rgb(128, 0, 128);\">3</span><span style=\"color: rgb(0, 0, 0);\">. 回答\n#</span><span style=\"color: rgb(128, 0, 128);\">1</span><span style=\"color: rgb(0, 0, 0);\">:this指针是什么时候创建的</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(0, 0, 0);\">\nthis在成员函数的开始执行前构造的，在成员的执行结束后清除。\n#</span><span style=\"color: rgb(128, 0, 128);\">2</span><span style=\"color: rgb(0, 0, 0);\">:this指针存放在何处</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(0, 0, 0);\"> 堆,栈,全局变量,还是其他</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(0, 0, 0);\">\nthis指针会因编译器不同，而放置的位置不同。可能是栈，也可能是寄存器，甚至全局变量。\n#</span><span style=\"color: rgb(128, 0, 128);\">3</span><span style=\"color: rgb(0, 0, 0);\">:this指针如何传递给类中函数的</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(0, 0, 0);\">绑定</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(0, 0, 0);\">还是在函数参数的首参数就是this指针.那么this指针又是如何找到类实例后函数的</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(0, 0, 0);\">\nthis是通过函数参数的首参数来传递的。this指针是在调用之前生成的。类实例后的函数，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。\n#</span><span style=\"color: rgb(128, 0, 128);\">4</span><span style=\"color: rgb(0, 0, 0);\">:this指针如何访问类中变量的</span><span style=\"color: rgb(0, 0, 0);\">/?</span><span style=\"color: rgb(0, 0, 0);\">\n如果不是类，而是结构的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，那就很好理解这个问题了。\n在C</span><span style=\"color: rgb(0, 0, 0);\">++</span><span style=\"color: rgb(0, 0, 0);\">中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。\nthis是类的指针，如果换成结构，那this就是结构的指针了。\n\n#</span><span style=\"color: rgb(128, 0, 128);\">5</span><span style=\"color: rgb(0, 0, 0);\">:我们只有获得一个对象后,才能通过对象使用this指针,如果我们知道一个对象this指针的位置可以直接使用吗</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(0, 0, 0);\">\nthis指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们也无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以</span><span style=\"color: rgb(0, 0, 0);\">&amp;</span><span style=\"color: rgb(0, 0, 0);\">this获得)，也可以直接使用的。\n#</span><span style=\"color: rgb(128, 0, 128);\">6</span><span style=\"color: rgb(0, 0, 0);\">:每个类编译后,是否创建一个类中函数表保存函数指针,以便用来调用函数</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(0, 0, 0);\">\n普通的类函数（不论是成员函数，还是静态函数），都不会创建一个函数表来保存函数指针的。只有虚函数才会被放到函数表中。\n但是，既使是虚函数，如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。\n\n# </span><span style=\"color: rgb(128, 0, 128);\">7</span><span style=\"color: rgb(0, 0, 0);\">:这些编译器如何做到的</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(128, 0, 128);\">8</span><span style=\"color: rgb(0, 0, 0);\">:能否模拟实现</span><span style=\"color: rgb(0, 0, 0);\">?</span><span style=\"color: rgb(0, 0, 0);\">\n知道原理后，这两个问题就很容易理解了。\n其实，模拟实现this的调用，在很多场合下，很多人都做过。\n例如，系统回调函数。系统回调函数有很多，如定时，线程啊什么的。\n\n举一个线程的例子：\n</span><span style=\"color: rgb(0, 0, 255);\">class</span><span style=\"color: rgb(0, 0, 0);\"> A{\n</span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> n;\n</span><span style=\"color: rgb(0, 0, 255);\">public</span><span style=\"color: rgb(0, 0, 0);\">:\n</span><span style=\"color: rgb(0, 0, 255);\">static</span><span style=\"color: rgb(0, 0, 0);\"> </span><span style=\"color: rgb(0, 0, 255);\">void</span><span style=\"color: rgb(0, 0, 0);\"> run(</span><span style=\"color: rgb(0, 0, 255);\">void</span><span style=\"color: rgb(0, 0, 0);\">*</span><span style=\"color: rgb(0, 0, 0);\"> pThis){\nA</span><span style=\"color: rgb(0, 0, 0);\">*</span><span style=\"color: rgb(0, 0, 0);\"> this_ </span><span style=\"color: rgb(0, 0, 0);\">=</span><span style=\"color: rgb(0, 0, 0);\"> (A</span><span style=\"color: rgb(0, 0, 0);\">*</span><span style=\"color: rgb(0, 0, 0);\">)pThis;\nthis_</span><span style=\"color: rgb(0, 0, 0);\">-&gt;</span><span style=\"color: rgb(0, 0, 0);\">process();\n}\n</span><span style=\"color: rgb(0, 0, 255);\">void</span><span style=\"color: rgb(0, 0, 0);\"> process(){}\n};\n\nmain(){\nA a;\n_beginthread( A::run, </span><span style=\"color: rgb(128, 0, 128);\">0</span><span style=\"color: rgb(0, 0, 0);\">, </span><span style=\"color: rgb(0, 0, 0);\">&amp;</span><span style=\"color: rgb(0, 0, 0);\">a );\n}\n\n这里就是定义一个静态函数来模拟成员函数。\n\n也有许多C语言写的程序，模拟了类的实现。如freetype库等等。\n其实，有用过C语言的人，大多都模拟过。只是当时没有明确的概念罢了。\n如：\ntypedef </span><span style=\"color: rgb(0, 0, 255);\">struct</span><span style=\"color: rgb(0, 0, 0);\"> student{\n</span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> age;\n</span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> no;\n</span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> scores;\n}Student;\n</span><span style=\"color: rgb(0, 0, 255);\">void</span><span style=\"color: rgb(0, 0, 0);\"> initStudent(Student</span><span style=\"color: rgb(0, 0, 0);\">*</span><span style=\"color: rgb(0, 0, 0);\"> pstudent);\n</span><span style=\"color: rgb(0, 0, 255);\">void</span><span style=\"color: rgb(0, 0, 0);\"> addScore(Student</span><span style=\"color: rgb(0, 0, 0);\">*</span><span style=\"color: rgb(0, 0, 0);\"> pstudent, </span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> score);\n...\n如果你把 pstudent改成this，那就一样了。\n\n它相当于：\n</span><span style=\"color: rgb(0, 0, 255);\">class</span><span style=\"color: rgb(0, 0, 0);\"> Student{\n</span><span style=\"color: rgb(0, 0, 255);\">public</span><span style=\"color: rgb(0, 0, 0);\">:\n</span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> age; </span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> no; </span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> scores;\n</span><span style=\"color: rgb(0, 0, 255);\">void</span><span style=\"color: rgb(0, 0, 0);\"> initStudent();\n</span><span style=\"color: rgb(0, 0, 255);\">void</span><span style=\"color: rgb(0, 0, 0);\"> addScore(</span><span style=\"color: rgb(0, 0, 255);\">int</span><span style=\"color: rgb(0, 0, 0);\"> score);\n}\n\nconst常量可以有物理存放的空间，因此是可以取地址的\n\n\n</span><span style=\"color: rgb(128, 128, 128);\">///</span><span style=\"color: rgb(0, 128, 0);\">this指针是在创建对象前创建.</span><span style=\"color: rgb(128, 128, 128);\">\n</span><span style=\"color: rgb(0, 0, 0);\">this指针放在栈上,在编译时刻已经确定.\n并且当一个对象创建后,并且运行整个程序运行期间只有一个this指针.</span></pre></div></div><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span title=\"neteasefooter\" style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span id=\"netease_mail_footer\"><div id=\"netease_mail_footer\"><div style=\"border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); padding: 10px 5px; color: rgb(102, 102, 102); line-height: 22px;\">来自网易手机号码邮箱<a id=\"mobile_set\" sys=\"1\" log=\"1\" logid=\"free_sms_20120504\" href=\"http://shouji.163.com/\" target=\"_blank\" style=\"color: rgb(0, 0, 255);\">了解更多</a></div></div></span></span>"
    }
  ]
}
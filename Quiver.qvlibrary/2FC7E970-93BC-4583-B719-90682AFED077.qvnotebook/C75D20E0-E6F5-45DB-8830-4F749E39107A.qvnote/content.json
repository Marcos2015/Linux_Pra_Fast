{
  "title": "C++中的Lambda表达式详解",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><strong>我是搞C++的</strong></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">一直都在提醒自己，我是搞C++的；但是当C++11出来这么长时间了，我却没有跟着队伍走，发现很对不起自己的身份，也还好，发现自己也有段时间 没有写C++代码了。今天看到了C++中的Lambda表达式，虽然用过C#的，但是C++的，一直没有用，也不知道怎么用，就可怜的连Lambda语法 都看不懂。好了，这里就对C++中的Lambda进行一个简单的总结，就算是对自己的一个交代，我是搞C++的，我是一个C++ programmer。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><strong>一段简单的Code</strong></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">我也不是文艺的人，对于Lambda的历史，以及Lambda与C++的那段渊源，我也不是很熟悉，技术人，讲究拿代码说事。</p><div class=\"codetitle\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><a class=\"copybut\" id=\"copybut80761\" style=\"cursor: pointer;\"><u>复制代码</u></a>&nbsp;代码如下:</div><div class=\"codebody\" id=\"code80761\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br>#include&lt;iostream&gt;<br>using namespace std;<br>&nbsp;<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; int a = 1;<br>&nbsp;&nbsp;&nbsp; int b = 2;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; auto func = [=, &amp;b](int c)-&gt;int {return b += a + c;};<br>&nbsp;&nbsp;&nbsp; return 0;<br>}<br></div><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">当我第一次看到这段代码时，我直接凌乱了，直接看不懂啊。上面这段代码，如果你看懂了，下面的内容就当时复习了；如果看不懂了，就接着和我一起总结吧。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><strong>基本语法</strong></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">简单来说，Lambda函数也就是一个函数，它的语法定义如下：</p><div class=\"codetitle\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><a class=\"copybut\" id=\"copybut72475\" style=\"cursor: pointer;\"><u>复制代码</u></a>&nbsp;代码如下:</div><div class=\"codebody\" id=\"code72475\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br>[capture](parameters) mutable -&gt;return-type{statement}<br></div><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">1.[capture]：捕捉列表。捕捉列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数。捕捉列表能够捕捉上下文中的变量以供Lambda函数使用;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">2.(parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">3.mutable：mutable修饰符。默认情况下，Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">4.-&gt;return-type：返回类型。用追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”-&gt;”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">5.{statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">与普通函数最大的区别是，除了可以使用参数以外，Lambda函数还可以通过捕获列表访问一些上下文中的数据。具体地，捕捉列表描述了上下文中哪些 数据可以被Lambda使用，以及使用方式（以值传递的方式或引用传递的方式）。语法上，在“[]”包括起来的是捕捉列表，捕捉列表由多个捕捉项组成，并 以逗号分隔。捕捉列表有以下几种形式：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">1.[var]表示值传递方式捕捉变量var；<br>2.[=]表示值传递方式捕捉所有父作用域的变量（包括this）；<br>3.[&amp;var]表示引用传递捕捉变量var；<br>4.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）；<br>5.[this]表示值传递方式捕捉当前的this指针。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">上面提到了一个父作用域，也就是包含Lambda函数的语句块，说通俗点就是包含Lambda的“{}”代码块。上面的捕捉列表还可以进行组合，例如：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">1.[=,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量;<br>2.[&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">不过值得注意的是，捕捉列表不允许变量重复传递。下面一些例子就是典型的重复，会导致编译时期的错误。例如：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">3.[=,a]这里已经以值传递方式捕捉了所有变量，但是重复捕捉a了，会报错的;<br>4.[&amp;,&amp;this]这里&amp;已经以引用传递方式捕捉了所有变量，再捕捉this也是一种重复。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><strong>Lambda的使用</strong></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">对于Lambda的使用，说实话，我没有什么多说的，个人理解，在没有Lambda之前的C++ , 我们也是那样好好的使用，并没有对缺少Lambda的C++有什么抱怨，而现在有了Lambda表达式，只是更多的方便了我们去写代码。不知道大家是否记 得C++ STL库中的仿函数对象，仿函数想对于普通函数来说，仿函数可以拥有初始化状态，而这些初始化状态是在声明仿函数对象时，通过参数指定的，一般都是保存在 仿函数对象的私有变量中;在C++中，对于要求具有状态的函数，我们一般都是使用仿函数来实现，比如以下代码：</p><div class=\"codetitle\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><a class=\"copybut\" id=\"copybut50449\" style=\"cursor: pointer;\"><u>复制代码</u></a>&nbsp;代码如下:</div><div class=\"codebody\" id=\"code50449\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br>#include&lt;iostream&gt;<br>using namespace std;<br>&nbsp;<br>typedef enum<br>{<br>&nbsp;&nbsp;&nbsp; add = 0,<br>&nbsp;&nbsp;&nbsp; sub,<br>&nbsp;&nbsp;&nbsp; mul,<br>&nbsp;&nbsp;&nbsp; divi<br>}type;<br>&nbsp;<br>class Calc<br>{<br>&nbsp;&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Calc(int x, int y):m_x(x), m_y(y){}<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int operator()(type i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case add:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_x + m_y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case sub:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_x - m_y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case mul:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_x * m_y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case divi:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m_x / m_y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; private:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m_x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int m_y;<br>};<br>&nbsp;<br>int main()<br>{<br>&nbsp;&nbsp;&nbsp; Calc addObj(10, 20);<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;addObj(add)&lt;&lt;endl; // 发现C++11中，enum类型的使用也变了，更“强” 了&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; return 0;<br>}<br></div><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">现在我们有了Lambda这个利器，那是不是可以重写上面的实现呢？看代码：</p><div class=\"codetitle\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><a class=\"copybut\" id=\"copybut89970\" style=\"cursor: pointer;\"><u>复制代码</u></a>&nbsp;代码如下:</div><div class=\"codebody\" id=\"code89970\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br>#include&lt;iostream&gt;<br>using namespace std;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>typedef enum<br>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; add = 0,<br>&nbsp;&nbsp;&nbsp; sub,<br>&nbsp;&nbsp;&nbsp; mul,<br>&nbsp;&nbsp;&nbsp; divi<br>}type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>int main()<br>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int a = 10;<br>&nbsp;&nbsp;&nbsp; int b = 20;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; auto func = [=](type i)-&gt;int {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (i)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case add:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a + b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case sub:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a - b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case mul:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a * b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case divi:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a / b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; };<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;func(add)&lt;&lt;endl;<br>}<br></div><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">显而易见的效果，代码简单了，你也少写了一些代码，也去试一试C++中的Lambda表达式吧。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><strong>关于Lambda那些奇葩的东西</strong></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">看以下一段代码：<br></p><div class=\"codetitle\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><a class=\"copybut\" id=\"copybut71407\" style=\"cursor: pointer;\"><u>复制代码</u></a>&nbsp;代码如下:</div><div class=\"codebody\" id=\"code71407\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br>#include&lt;iostream&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>using namespace std;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>int main()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int j = 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; auto by_val_lambda = [=]{ return j + 1; };<br>&nbsp;&nbsp;&nbsp; auto by_ref_lambda = [&amp;]{ return j + 1; };<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;\"by_val_lambda: \"&lt;&lt;by_val_lambda()&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;\"by_ref_lambda: \"&lt;&lt;by_ref_lambda()&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; ++j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;\"by_val_lambda: \"&lt;&lt;by_val_lambda()&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;\"by_ref_lambda: \"&lt;&lt;by_ref_lambda()&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; return 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>}<br></div><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">程序输出结果如下：<br></p><div class=\"codetitle\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><a class=\"copybut\" id=\"copybut53653\" style=\"cursor: pointer;\"><u>复制代码</u></a>&nbsp;代码如下:</div><div class=\"codebody\" id=\"code53653\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br>by_val_lambda: 11<br>by_ref_lambda: 11<br>by_val_lambda: 11<br>by_ref_lambda: 12<br></div><br style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">你想到了么？？？那这又是为什么呢？为什么第三个输出不是12呢？</span><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">在by_val_lambda中，j被视为一个常量，一旦初始化后不会再改变（可以认为之后只是一个跟父作用域中j同名的常量），而在 by_ref_lambda中，j仍然在使用父作用域中的值。所以，在使用Lambda函数的时候，如果需要捕捉的值成为Lambda函数的常量，我们通 常会使用按值传递的方式捕捉；相反的，如果需要捕捉的值成成为Lambda函数运行时的变量，则应该采用按引用方式进行捕捉。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">再来一段更晕的代码：</p><div class=\"codetitle\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><a class=\"copybut\" id=\"copybut80356\" style=\"cursor: pointer;\"><u>复制代码</u></a>&nbsp;代码如下:</div><div class=\"codebody\" id=\"code80356\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br>#include&lt;iostream&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>using namespace std;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>int main()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; int val = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; // auto const_val_lambda = [=](){ val = 3; }; wrong!!!<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; auto mutable_val_lambda = [=]() mutable{ val = 3; };<br>&nbsp;&nbsp;&nbsp; mutable_val_lambda();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;val&lt;&lt;endl; // 0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; auto const_ref_lambda = [&amp;]() { val = 4; };<br>&nbsp;&nbsp;&nbsp; const_ref_lambda();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;val&lt;&lt;endl; // 4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; auto mutable_ref_lambda = [&amp;]() mutable{ val = 5; };<br>&nbsp;&nbsp;&nbsp; mutable_ref_lambda();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;val&lt;&lt;endl; // 5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; return 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>}<br></div><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">这段代码主要是用来理解Lambda表达式中的mutable关键字的。默认情况下，Lambda函数总是一个const函数，mutable可以 取消其常量性。按照规定，一个const的成员函数是不能在函数体内修改非静态成员变量的值。例如上面的Lambda表达式可以看成以下仿函数代码：</p><div class=\"codetitle\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><a class=\"copybut\" id=\"copybut246\" style=\"cursor: pointer;\"><u>复制代码</u></a>&nbsp;代码如下:</div><div class=\"codebody\" id=\"code246\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br>class const_val_lambda<br>{<br>public:<br>&nbsp;&nbsp;&nbsp; const_val_lambda(int v) : val(v) {}<br>&nbsp;&nbsp;&nbsp; void operator()() const { val = 3; } // 常量成员函数<br>&nbsp;<br>private:<br>&nbsp;&nbsp;&nbsp; int val;<br>};<br></div><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">对于const的成员函数，修改非静态的成员变量，所以就出错了。而对于引用的传递方式，并不会改变引用本身，而只会改变引用的值，因此就不会报错了。都是一些纠结的规则。慢慢理解吧。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><strong>总结</strong></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">对于Lambda这种东西，有的人用的非常爽，而有的人看着都不爽。仁者见仁，智者见智。不管怎么样，作为程序员的你，都要会的。这篇文章就是用来 弥补自己对C++ Lambda表达式的认知不足的过错，以免以后在别人的代码中看到了Lambda，还看不懂这种东西，那就丢大人了。</p>"
    }
  ]
}
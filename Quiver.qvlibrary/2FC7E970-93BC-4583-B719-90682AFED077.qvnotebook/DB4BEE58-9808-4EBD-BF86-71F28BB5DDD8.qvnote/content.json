{
  "title": "为什么拷贝构造函数必须为引用传递，不能是值传递？",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"position: relative;\"><embed id=\"xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd\" type=\"application/thunder_download_plugin\" height=\"0\" width=\"0\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"color: rgb(51, 51, 51); font-family: STHeiti, 'Microsoft YaHei', arial, 宋体; font-size: 12px;\">作者&nbsp;:&nbsp;</span><span style=\"color: rgb(51, 51, 51); font-family: STHeiti, 'Microsoft YaHei', arial, 宋体; font-size: 12px;\">&nbsp;</span><a href=\"http://blog.renren.com/GetEntry.do?id=716599598&amp;owner=276864830\" target=\"_blank\" style=\"font-size: 14px; font-family: STHeiti, 'Microsoft YaHei', arial, 宋体; text-decoration: none; color: rgb(102, 102, 102); line-height: 14px; display: inline-block;\">任开域</a><div id=\"blogContent\" data-wiki=\"\" class=\"blogDetail-content\" style=\"font-size: 14px; margin: 15px 0px 0px; padding: 0px; line-height: 1.5; color: rgb(51, 51, 51); float: left; font-family: STHeiti, 'Microsoft YaHei', arial, 宋体;\"><p style=\"margin: 0px; padding: 0px;\">对于拷贝构造函数引用传递，似乎司空见惯，认为理所当然。但是被问起这个问题，的确是一片茫然，为什么呢？<br><br>去网上搜索了一下，的确有很多这方面的知识讲解。<br><br>我们先看一下CSDN上的一个帖子的回答：<br>简单的回答是为了防止递归引用。<br>具体一些可以这么讲：<br>&nbsp;当 一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数以生成一个复本。如果类A的拷贝构造函数是以值方式传递一个类A对象作为参数的话，当 需要调用类A的拷贝构造函数时，需要以值方式传进一个A的对象作为实参；&nbsp;而以值方式传递需要调用类A的拷贝构造函数；结果就是调用类A的拷贝构造函数导 致又一次调用类A的拷贝构造函数，这就是一个无限递归。<br><br>这个解释还是蛮具体的。<br>利用值传递的话，会导致递归引用。<br><br>还有一片文章也谈到了这个问题， 我觉得写得也非常好！<a href=\"http://www.cnblogs.com/chio/archive/2007/09/14/893299.html\" style=\"text-decoration: none; color: rgb(34, 125, 197);\"></a>&nbsp;&nbsp;<br><br>其中讲到了3个问题<br><strong>1是拷贝构造函数的作用。<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。<br><strong>2是参数传递过程到底发生了什么？<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 将地址传递和值传递统一起来，归根结底还是传递的是\"值\"(地址也是值，只不过通过它可以找到另一个值)！<br>i)值传递:<br>&nbsp;&nbsp;&nbsp;&nbsp;对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(255, 0, 255);\">对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</span>如void foo(class_type obj_local){}, 如果调用foo(obj);&nbsp; 首先class_type obj_local(obj)&nbsp;,这样就定义了局部变量obj_local供函数内部使用<br>ii)引用传递:<br>&nbsp;&nbsp;&nbsp;&nbsp;无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).<br><strong>3是在类中有指针数据成员时，拷贝构造函数的使用？<br></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果不显式声明拷贝构造函数的时候，编译器也会生成一个默认的拷贝构造函数，而且在一般的情况下运行的也很好。但是在遇到类有指针数据成员时就出现问题 了：因为默认的拷贝构造函数是按成员拷贝构造，这导致了两个不同的指针(如ptr1=ptr2)指向了相同的内存。当一个实例销毁时，调用析构函数 free(ptr1)释放了这段内存，那么剩下的一个实例的指针ptr2就无效了，在被销毁的时候free(ptr2)就会出现错误了, 这相当于重复释放一块内存两次。这种情况必须显式声明并实现自己的拷贝构造函数，来为新的实例的指针分配新的内存。<br><br>问题1和2回答了为什么拷贝构造函数使用值传递会产生无限递归调用的问题；<br>问题3回答了回答了在类中有指针数据成员时，拷贝构造函数使用值传递等于白显式定义了拷贝构造函数，因为默认的拷贝构造函数就是这么干的.</p><p style=\"margin: 0px; padding: 0px;\"><br></p><p style=\"margin: 0px; padding: 0px;\"><br></p><p style=\"margin: 0px; padding: 0px;\"><br></p><p style=\"margin: 0px; padding: 0px;\"><br></p><p style=\"margin: 0px; padding: 0px;\"><br></p><p style=\"margin: 0px; padding: 0px;\"><br></p><p style=\"margin: 0px; padding: 0px;\"><br></p><p style=\"margin: 0px; padding: 0px;\"><br></p><p style=\"margin: 0px; padding: 0px;\"><br></p><div class=\"articalTitle\" style=\"clear: both; line-height: 20px; padding-bottom: 10px; color: rgb(70, 70, 70); font-family: Verdana, 宋体, sans-serif; font-size: 12px;\"><h2 id=\"t_88b95c430100uqt0\" class=\"titName SG_txta\" style=\"margin: 0px; padding: 0px; border: 0px; list-style: none; color: rgb(106, 63, 48); font-size: 18px; font-family: 微软雅黑, 黑体; font-weight: 300; display: inline;\">为什么拷贝构造函数的参数必须是引用？</h2>&nbsp;<span class=\"time SG_txtc\" style=\"color: rgb(124, 124, 124); white-space: nowrap; font-family: Arial; font-size: 10px; margin-left: 5px; margin-right: 13px;\">(2011-10-12 17:31:21)</span><div class=\"turnBoxzz\" style=\"float: right;\"><a class=\"SG_aBtn SG_aBtn_ico SG_turn\" action-type=\"reblog\" action-data=\"{srcBlog:1, blogId:'88b95c430100uqt0'}\" style=\"color: rgb(106, 63, 48); cursor: pointer; padding: 0px 0px 0px 3px; overflow: hidden; white-space: nowrap; display: inline-block; margin-right: 6px; background-image: url(http://simg.sinajs.cn/blog7newtpl/image/3/3_9/images/sg_newsp.png); position: relative; letter-spacing: 5px; width: 86px; zoom: 1; background-position: 0px 0px; background-repeat: no-repeat no-repeat;\"><cite style=\"font-style: normal; line-height: 23px; padding: 0px 20px 0px 32px; height: 23px; min-width: 1px; overflow-x: visible; background-image: url(http://simg.sinajs.cn/blog7newtpl/image/3/3_9/images/sg_newsp.png); width: 34px; display: inline-block !important; background-position: 100% -28px; background-repeat: no-repeat no-repeat;\"><img class=\"SG_icon SG_icon111\" src=\"quiver-image-url/3D045B93716ED28DC745E648B3428A26.gif\" width=\"1\" height=\"1\" align=\"absmiddle\" style=\"margin: 0px; padding: 0px; border: 0px; list-style: none; background-image: url(http://simg.sinajs.cn/blog7style/images/common/sg_icon.png?20131218); position: absolute; left: 11px; top: 4px; background-position: 495px -60px;\">转载<span class=\"arrow\" style=\"font-size: 7px; position: absolute; right: 5px; top: 2px;\">▼</span></cite></a></div></div><div class=\"articalTag\" id=\"sina_keyword_ad_area\" style=\"width: 690px; clear: both; word-break: break-all; line-height: 20px; color: rgb(70, 70, 70); font-family: Verdana, 宋体, sans-serif; font-size: 12px;\"><table style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding: 0px;\"><tbody><tr><td class=\"blog_tag\" style=\"margin: 0px; padding: 0px 10px 0px 0px; font-family: 宋体; vertical-align: top;\"><span class=\"SG_txtb\" style=\"color: rgb(124, 124, 124);\">标签：</span>&nbsp;<h3 style=\"margin: 0px 5px 0px 0px; padding: 0px; border: 0px; list-style: none; display: inline; font-size: 12px; font-weight: normal;\"><a href=\"http://search.sina.com.cn/?c=blog&amp;q=%D4%D3%CC%B8&amp;by=tag\" target=\"_blank\" style=\"text-decoration: none; color: rgb(106, 63, 48); white-space: nowrap;\">杂谈</a></h3></td><td class=\"blog_class\" style=\"margin: 0px; padding: 0px; font-family: 宋体; vertical-align: top; width: 220px; white-space: nowrap;\"></td></tr></tbody></table></div><div id=\"sina_keyword_ad_area2\" class=\"articalContent   \" style=\"width: 690px; clear: both; padding-top: 18px; padding-bottom: 30px; overflow: hidden; font-family: simsun; word-wrap: normal; word-break: normal; line-height: 21px; color: rgb(70, 70, 70);\"><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">例子：inline Account::<br>Account( const Accout &amp;rhs )<br>: _balance( rhs._balance )<br>{<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;_name = new char[ strlen(rhs._name)+1 ];<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;strcpy( _name, rhs._name );<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;// 不能拷贝 rhs._acct_nmbr<br>&nbsp;<wbr>&nbsp;_acct_nmbr = get_unique_acct_nmbr();</p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">}</p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">int main（）</p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">{</p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">Account acct2( acct1 );</p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">}</p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">问题：为什么拷贝构造函数Account( const Accout &amp;rhs )不能写成Account( const Accout rhs )？</p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">解答：<span style=\"color: rgb(255, 0, 255);\">首先你要明白普通的函数，像这样的Account acct2( acct1 );如果参数不是引用，是会默认调用一次拷贝构造函数的。</span></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><span style=\"color: rgb(255, 0, 0);\">所以如果有一个函数Account( const Accout rhs )，在参数传递的时候要调用拷贝构造函数也就是自己，调用自己的时候又是一次参数传递，所以又要调用一次自己，调用自己的时候又是一次参数传递，所以又要调用一次自己，……以下省略无限多字。</span></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">注：在ｃ＋＋ｐｒｉｍｅｒ第三版中有解释。<br>=============================================================</p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\">今天又想到了这个问题。其实当初我写这篇blog的时候应该不是很明白的。<br>（1）拷贝构造函数的参数为什么不能是值？用反证法说明。<br><br>Account account2(Account&nbsp;<wbr>&nbsp;account1);<br>不是要调用拷贝构造函数Account（Account account）吗？这个不就是自己吗？<br>所以是自己调用自己。死循环了。<br><br>（2）拷贝构造函数的参数为什么不能是指针？<br>关于这个问题我是想了很久的，到现在还没有确定原因对不对，因为我没有在一本教科书上看到过答案（thinking in c++里只是简单的带了一下过：<font face=\"Georgia\" style=\"word-wrap: normal; word-break: normal; line-height: 21px;\">But that object can’t be passed into the constructor by value because you’re trying to define the function that handles passing by value, and syntactically it doesn’t make sense to pass a pointer because, after all, you’re creating the new object from an existing object</font>&nbsp;）<br>我们知道拷贝构造函数在三个地方会用到：分别是，<br>a.将一个对象构造为另一个对象的完全副本。（显式）classa_1=class_2;<br>b.函数的形参有用到类对象却没有用引用或传址技术时（隐式）<br>c.函数的返回值是一个对象却没有用引用或传址技术时（隐式）。<br>我觉得b和c两种情况是无所谓的。只是a那种情况，你需要写成T t2(&amp;t1)或者<br>T t2=&amp;t1,这样的形式别扭吗？很别扭把。所以用指针也不太合适。<br>所以 不用指针是出于美感上的考虑，如果死认指针又有何不可呢？<br>另外在more effective c++ item25中讲到了虚拷贝构造函数的东东。<br><br></p><table border=\"1\" cellspacing=\"2\" bordercolor=\"#CCCCCC\" cellpadding=\"3\" width=\"100%\" bgcolor=\"#FFFFFF\" style=\"margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding: 0px;\"><tbody><tr><td style=\"margin: 0px; padding: 0px; font-size: 12px; font-family: Verdana, 宋体, sans-serif; line-height: 18px;\">&nbsp;<wbr><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">还有一种特殊种类的虚拟构造函数――虚拟拷贝构造函数――也有着广泛的用途。虚拟拷贝构造函数能返回一个指针，指向调用该函数的对象的新拷贝。因为这种行为特性，虚拟拷贝构造函数的名字一般都是copySelf，cloneSelf或者是象下面这样就叫做clone</font><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">。很少会有函数能以这么直接的方式实现它。<br></font><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">class NLComponent {</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">public:</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">&nbsp;<wbr>&nbsp;// declaration of virtual copy constructor</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">&nbsp;<wbr>&nbsp;virtual NLComponent * clone() const = 0;</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">&nbsp;<wbr>&nbsp;...</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">};</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">class TextBlock: public NLComponent {</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">public:</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">&nbsp;<wbr>&nbsp;virtual TextBlock * clone() const&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;// virtual copy</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">&nbsp;<wbr>&nbsp;{ return new TextBlock(*this); }&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;// constructor</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">&nbsp;<wbr>&nbsp;...</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">};</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">class Graphic: public NLComponent {</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">public:</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">&nbsp;<wbr>&nbsp;virtual Graphic * clone() const&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;// virtual copy</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">&nbsp;<wbr>&nbsp;{ return new Graphic(*this); }&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;// constructor</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 18px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">&nbsp;<wbr>&nbsp;...</font></p><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">}</font></td></tr></tbody></table><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\">作者所谓的virtual Graphic * clone() const&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>就是虚拟拷贝构造函数，厉害吧。其实这个是广义上的虚拟拷贝构造函数，他符合（1）虚拟，只向谁就是谁。（2）拷贝构造函数，在&nbsp;<wbr>clone()&nbsp;<wbr>成员函数中，代码&nbsp;<wbr>new TextBlock(*this); 调用&nbsp;<wbr>TextBlock的拷贝构造函数来复制this的状态到新创建的TextBlock对象。</font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\"><br></font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\"><br></font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\"><br></font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\"><br></font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\"><br></font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\"><br></font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\"><br></font></p><p style=\"margin: 0px 0px 5px; padding: 0px; border: 0px; list-style: none; word-wrap: normal; word-break: normal; line-height: 21px;\"><font size=\"1\" style=\"word-wrap: normal; word-break: normal; line-height: 15px;\"></font></p><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"color: rgb(0, 0, 0); font-family: Arial, Helvetica, sans-serif; font-size: 12px; width: 722px; text-align: center;\"><tbody><tr><td><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" style=\"width: 722px;\"><tbody><tr><td class=\"biaoti\" style=\"color: rgb(61, 107, 167); padding: 30px 26px 22px;\"><div class=\"biaoti2 lf360\" style=\"float: left; font-size: 22px; font-weight: bold;\">为什么拷贝构造函数的形参必须是引用类型？</div></td></tr><tr><td style=\"height: 32px;\"><div style=\"width: 670px; height: 28px; padding-left: 26px; color: rgb(119, 123, 122);\"><table><tbody><tr><td>收藏人：<span class=\"name\"><a href=\"http://www.360doc.com/userhome/1317564\" target=\"_blank\" style=\"color: rgb(88, 134, 0); text-decoration: none;\">圣殿期士</a></span></td><td><div class=\"btzctsg\" id=\"spanfollowstatus\" style=\"padding-left: 10px; padding-right: 6px;\"><div class=\"gzbt1\" style=\"width: 48px; height: 22px;\"><a style=\"color: rgb(61, 107, 167); display: block; width: 48px; height: 22px; background-image: url(http://pubimage.360doc.com/wz/wz19.gif); background-repeat: no-repeat no-repeat;\"></a></div></div></td><td><div class=\"ytdh1\" style=\"width: 81px; height: 22px;\"><a style=\"color: rgb(61, 107, 167); display: block; width: 81px; height: 22px; background-image: url(http://pubimage.360doc.com/wz/yutaduihua.gif); background-repeat: no-repeat no-repeat;\"></a></div></td></tr></tbody></table></div><div class=\"wztopxx\" style=\"width: 670px; height: 35px; padding-left: 26px; color: rgb(119, 123, 122);\"><div style=\"float: left; height: 28px; padding-top: 7px;\"><table cellpadding=\"0\" cellspacing=\"0\" style=\"position: relative; z-index: 4;\"><tbody><tr><td>2014-03-30&nbsp;|&nbsp;阅：<span id=\"360doc_Readnum\">243</span>&nbsp;&nbsp;<span style=\"position: relative;\">转：<span id=\"360doc_saverNum\"><span style=\"cursor: pointer;\">1</span></span><span id=\"360doc_saverUser\"></span></span>&nbsp;&nbsp;</td><td><div style=\"position: relative;\">&nbsp;|&nbsp;<span id=\"docsource\">&nbsp;&nbsp;<a href=\"http://www.360doc.com/userhome/1317564\" target=\"_blank\" style=\"color: rgb(61, 107, 167); text-decoration: none;\">来源</a></span></div></td><td><div style=\"padding-left: 10px;\"><a style=\"color: rgb(61, 107, 167);\"><img src=\"quiver-image-url/DB95BE926C8BF66E1C92661EA5553A05.gif\" style=\"border: 0px;\" width=\"17\" height=\"17\"></a></div></td><td><div style=\"padding-left: 10px;\"><a style=\"color: rgb(61, 107, 167);\"><img src=\"quiver-image-url/C490E161469D1563A55754FC9D138A10.gif\" style=\"border: 0px;\" width=\"17\" height=\"17\"></a></div></td><td>&nbsp;&nbsp;|&nbsp;&nbsp;<a href=\"http://www.360doc.com/content/14/0330/11/1317564_364878947.shtml#\" style=\"color: rgb(61, 107, 167); text-decoration: none;\">分享</a>&nbsp;</td><td><a href=\"http://www.360doc.com/content/14/0330/11/1317564_364878947.shtml#\" style=\"color: rgb(61, 107, 167); text-decoration: none;\"><img src=\"quiver-image-url/04734018F53693244C66E4402DEFD373.gif\" style=\"border: 0px; cursor: pointer;\" width=\"10\" height=\"5\"></a></td></tr></tbody></table></div><div id=\"resavelayer1\" class=\"rt360\" style=\"float: right;\"><div class=\"zswdbtn1\" style=\"width: 143px; height: 27px;\"><a style=\"color: rgb(61, 107, 167); display: block; width: 133px; height: 27px; background-image: url(http://pubimage.360doc.com/wz/zhuanc.gif); background-repeat: no-repeat no-repeat;\"></a></div></div><div id=\"shareweixinabove\" class=\"rt360\" style=\"float: right;\"><div class=\"fxwx2bt\" style=\"width: 104px; height: 27px;\"><a style=\"color: rgb(61, 107, 167); display: block; width: 104px; height: 27px; background-image: url(http://pubimage.360doc.com/wz/fenxiangweixin.gif); background-repeat: no-repeat no-repeat;\"></a></div></div><table cellpadding=\"0\" cellspacing=\"0\" style=\"margin-right: auto; margin-bottom: 0px; margin-left: auto;\"><tbody><tr><td><div class=\"lf360 zcbutton\" style=\"float: left; position: absolute; margin-left: 100px; margin-top: -10px;\"></div><div class=\"lf360\" style=\"float: left;\">&nbsp;&nbsp;</div></td></tr></tbody></table></div></td></tr><tr><td></td></tr></tbody></table></td></tr><tr><td><table class=\"wenzhangcss\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\" style=\"line-height: 1.5; min-height: 245px; font-size: 16px; color: rgb(68, 68, 68); word-wrap: break-word; padding: 0px 26px; height: auto !important;\"><tbody><tr><td><div class=\"xiantao\" style=\"height: 2px; font-size: 0px; line-height: normal; font-family: Arial; background-color: rgb(222, 231, 226); width: 670px;\"></div></td></tr><tr><td align=\"left\" valign=\"top\" width=\"670px\" style=\"height: 200px;\"><span id=\"articlecontent\"><table><tbody><tr><td width=\"670px\" style=\"position: relative;\"><div><em class=\"highlight\" id=\"highlight_206397\" style=\"background-color: rgb(255, 255, 0);\">复制构造函数只有一个参数</em>,由于在创建时传入的是同种类型的对象,所以一个很自然的想法是将该类型的对象作为参数,像这样：</div><div>&nbsp; &nbsp; &nbsp;Sample (Sample a);</div><div>&nbsp; &nbsp;&nbsp;<span style=\"color: rgb(0, 128, 0);\">&nbsp;不幸的是,即使是这样朴实无华的声明也隐含了一个微妙的错误,呵,我们来看看：当某个时候需要以一个Sample对象的值来为一个新对象进行初始化时,编译器会在各个重载的构造函数版本(如果有多个的话)搜寻,它找到的这个版本,发现声明参数与传入的对象一致,因此该构造函数将会被调用。目前为止,一切都在我们的意料之中,但问题很快来了：该函数的参数我们使用了值传递的方式,按照前面的分析,这需要调用复制构造函数,于是编译器又再度搜寻,最后当然又找到了它,于是进行调用,但同样地,传参时又要进行复制,于是再调用...这个过程周而复始,每次都是到了函数入口处就进行递归,直到堆栈空间耗尽,程序崩溃...</span></div><div><br></div><div>由是观之,值传递看来是行不通的了;我想C语言的用户这时很快会反应到与值传递对应的方式：地址传递(传址),于是声明变为这样：</div><div>&nbsp; &nbsp; &nbsp;Sample Sample *p);</div><div>&nbsp; &nbsp; &nbsp;只作为一般的构造函数,它应该可以运行得很好,但别忘了我们要提供的是复制构造函数,它要求能够接受一个同类型对象,像这样：</div><div>&nbsp; &nbsp; &nbsp;Sample a;</div><div>&nbsp; &nbsp; &nbsp;Sample b(a);</div><div>&nbsp; &nbsp; &nbsp;而不是接受指针：</div><div>&nbsp; &nbsp; &nbsp;Sample a;</div><div>&nbsp; &nbsp; &nbsp;Sample b(&amp;a); &nbsp; // 还要取地址?当然,它可以正确运行,但...</div><div>&nbsp; &nbsp; &nbsp;虽然在初始化对象时可以像上面一样人为加一个取址符,但在函数参数表中(或者函数返回)进行值传递时,编译器可不知道在找不着合适定义的情况下牵就选择你的指针版本。</div><div><br></div><div>只有单个形参，而且该形参是对本类类型对象的引用(常用 const 修饰)，这样的构造函数称为复制</div><div><br></div><div>构造函数</div><div><br></div><div>复制构造函数可用于:</div><div>1. 根据另一个同类型的对象显式或隐式初始化一个对象</div><div>2. 复制一个对象，将它作为实参传给一个函数</div><div>3. 从函数返回时复制一个对象</div><div>4. 初始化顺序容器中的元素</div><div>5. 根据元素初始化式列表初始化数组元素</div><div><br></div><div>当用于类类型对象时，初始化的复制形式和直接形式有所不同：直接初始化直接调用与实参匹配的构</div><div><br></div><div>造函数，复制初始化总是调用复制构造函数</div><div><br></div><div>对于类类型对象，只有指定单个实参或显式创建一个临时对象用于复制时，才使用复制初始化</div><div><br></div><div>当形参或返回值为类类型时，由复制构造函数进行复制</div><div><br></div><div>如果没有为类类型数组提供元素初始化式，则将用默认构造函数初始化每个元素</div><div><br></div><div>如果我们没有定义复制构造函数，编译器就会为我们合成一个</div><div><br></div><div>与合成的默认构造函数不同，即使我们定义了其他构造函数，也会合成复制构造函数</div><div><br></div><div>合成复制构造函数的行为是，执行逐个成员初始化，将新对象初始化为原对象的副本</div><div><br></div><div>虽然一般不能复制数组，但如果一个类具有数组成员，则合成复制构造函数将复制数组，复制数组时</div><div><br></div><div>合成复制构造函数将复制数组的每一个元素</div><div><br></div><div><br></div><div>逐个成员初始化最简单的概念模型是，将合成复制构造函数看作这样一个构造函数：其中每个数据成</div><div><br></div><div>员在构造函数初始化列表中进行初始化</div><div><br></div><div>虽然也可以定义接受非 const 引用的复制构造函数，但形参通常是一个 const 引用</div><div><br></div><div>因为用于向函数传递对象和从函数返回对象，该构造函数一般不应设置为 explicit</div><div><br></div><div>有些类必须对复制对象时发生的事情加以控制，这样的类经常有一个数据成员是指针，或者有成员表</div><div><br></div><div>示在构造函数中分配的其他资源，而另一些类在创建新对象时必须做一些特定工作，这两种情况下，</div><div><br></div><div>都必须定义复制构造函数</div><div><br></div><div>为了防止复制，类必须显式声明其复制构造函数为 private</div><div><br></div><div>类的友元和成员仍可以进行复制，如果想要连友元和成员中的复制也禁止，就可以声明一个</div><div><br></div><div>(private)复制构造函数但不对其定义</div><div><br></div><div>一般来说，最好显式或隐式定义默认构造函数和复制构造函数，只有不存在其他构造函数时才合成默</div><div><br></div><div>认构造函数。如果定义了复制构造函数，也必须定义默认构造函数</div><div><br></div><div>Cpp代码&nbsp;</div><div>#include &lt;iostream&gt; &nbsp;&nbsp;</div><div>#include &lt;string&gt; &nbsp;&nbsp;</div><div>#include &lt;fstream&gt; &nbsp;&nbsp;</div><div>#include &lt;vector&gt; &nbsp;&nbsp;</div><div>using namespace std; &nbsp;&nbsp;</div><div>&nbsp;&nbsp;</div><div>struct NoName { &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; NoName(): pstring(new string), i(0), d(0) { } &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; NoName(const NoName&amp; noName): i(noName.i), d(noName.d) &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; { &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pstring = *(noName.pstring); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; } &nbsp;&nbsp;</div><div>private: &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;string *pstring; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; int &nbsp; &nbsp; i; &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; double d; &nbsp;&nbsp;</div><div>}; &nbsp;&nbsp;</div><div>&nbsp;&nbsp;</div><div>class Foo { &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp;public: &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Foo(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // default constructor &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Foo(const Foo&amp;); // copy constructor &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // ... &nbsp;&nbsp;</div><div>}; &nbsp;&nbsp;</div><div>&nbsp;&nbsp;</div><div>int main() &nbsp;&nbsp;</div><div>{ &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp;string null_book = \"9-999-99999-9\"; // copy-initialization &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp;string dots(10, '.'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // direct-initialization &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;</div><div>&nbsp; &nbsp; &nbsp;string empty_copy = string(); &nbsp; &nbsp; &nbsp; // copy-initialization &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp;string empty_direct; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// direct-initialization &nbsp;&nbsp;</div><div>&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp;ifstream file1(\"filename\"); // ok: direct initialization &nbsp;&nbsp;</div><div>&nbsp; &nbsp; //ifstream file2 = \"filename\"; &nbsp; error: copy constructor is private &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;</div><div>&nbsp; &nbsp; // default string constructor and five string copy constructors invoked &nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp;vector&lt;string&gt; svec(5); &nbsp;&nbsp;</div><div>&nbsp;&nbsp;</div><div>&nbsp; &nbsp; return 0; &nbsp;&nbsp;</div><div>} &nbsp;</div></td></tr></tbody></table></span></td></tr></tbody></table></td></tr></tbody></table></div></div><div style=\"clear: both;\"></div></div>"
    }
  ]
}
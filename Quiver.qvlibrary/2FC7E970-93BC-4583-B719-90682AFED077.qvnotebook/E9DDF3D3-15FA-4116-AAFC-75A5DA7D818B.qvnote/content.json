{
  "title": "C++中成员初始化列表的使用",
  "cells": [
    {
      "type": "text",
      "data": "<embed id=\"xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd\" type=\"application/thunder_download_plugin\" height=\"0\" width=\"0\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: 14px; color: rgb(51, 51, 51); font-family: tahoma, 宋体; text-align: justify;\">最近在学c++，想想有点那个，都读研了还杂学一门语言，而且还是入门，当初学C的时候就没有想到现在。看了那个primer那么厚，看了一些了，想来我还是不能像有的人说的那样，什么一种语言一个礼拜最多一个月就学会了。不管怎样，为了工作期间，c++还是要会的。</span><p style=\"font-size: 14px; color: rgb(51, 51, 51); font-family: tahoma, 宋体; text-align: justify;\">C++在类的构造函数中，可以两种方式初始化成员数据(data member)。&nbsp;</p><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\"><span style=\"color: rgb(255, 0, 0);\">1,在构造函数的实现中，初始类的成员数据。</span>诸如：</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">class point<br>{<br>private:<br>&nbsp;int x,y;<br><span style=\"color: rgb(204, 51, 51);\"><span style=\"color: rgb(0, 0, 0);\">public:</span><br>&nbsp;point(int m=0,int n=0)<br>&nbsp;{<br>&nbsp;&nbsp;x=m;<br>&nbsp;&nbsp;y=n;<br>&nbsp;}</span></div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp;int GetX()<br>&nbsp;{<br>&nbsp;&nbsp;return x;<br>&nbsp;}<br>&nbsp;int GetY()<br>&nbsp;{<br>&nbsp;&nbsp;return y;<br>&nbsp;}<br>};</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">2,还可以定义初始化成员列表（Initializer list）来初始化成员数据(data member)。</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp; 改写构造函数如下：</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\"><span style=\"color: rgb(204, 51, 51);\">&nbsp;point(int m=0,int n=0)<span style=\"color: rgb(0, 0, 255);\">:x(m),y(n)</span><br>&nbsp;{<br>&nbsp;}</span></div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">这样咋一看没有什么不同，确实，对于上面的这种简单列子来说，也真的没有太大不同。</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp;</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">那我们为什么要用初始化成员列表，什么时候用初始化成员列表来初始化成员数据呢？Lippman的《C++ Primer》中提到在以下三种情况下需要使用初始化成员列表：</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp;</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">一，需要初始化的数据成员是对象的情况；</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">二，需要初始化const修饰的类成员；</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">三，需要初始化引用成员数据；</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp;</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">现在分别举例说明：</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">一，需要初始化的数据成员是对象。</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">---------------------------</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">#include &lt;stdio.h&gt;</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">class point<br>{<br>protected:<br>&nbsp;int m_x,m_y;<br>public:<br>&nbsp;point(int m=0,int n=0)<br>&nbsp;{<br>&nbsp;&nbsp;m_x = m;<br>&nbsp;&nbsp;m_y = n;<br>&nbsp;&nbsp;printf(\"constructor called!/n\");<br>&nbsp;}<br>&nbsp;point(point&amp; p)<br>&nbsp;{<br>&nbsp;&nbsp;m_x = p.GetX();<br>&nbsp;&nbsp;m_y = p.GetY();<br>&nbsp;&nbsp;printf(\"copy constructor called!/n\");<br>&nbsp;}<br>&nbsp;int GetX()<br>&nbsp;{<br>&nbsp;&nbsp;return m_x;<br>&nbsp;}<br>&nbsp;int GetY()<br>&nbsp;{<br>&nbsp;&nbsp;return m_y;<br>&nbsp;}<br>};</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp;</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">class point3d<br>{<br>private:<br>&nbsp;point m_p;<br>&nbsp;int m_z;<br>public:<br><span style=\"color: rgb(204, 51, 51);\">&nbsp;point3d(point p, int k)<br>&nbsp;{<br>&nbsp;&nbsp;m_p = p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这里是<span style=\"color: rgb(255, 0, 0);\"><span style=\"color: rgb(0, 0, 255);\">对m_p的赋值</span><br></span>&nbsp;&nbsp;m_z=k;<br>&nbsp;}<br>&nbsp;point3d(int i,int j, int k):m_p(i,j)&nbsp;&nbsp; // 相当于 point m_p(i,j)这样<span style=\"color: rgb(255, 0, 0);\"><span style=\"color: rgb(0, 0, 255);\">对m_p初始化</span><br></span>&nbsp;{<br>&nbsp;&nbsp;m_z=k;<br>&nbsp;}</span><br>&nbsp;void Print()<br>&nbsp;{<br>&nbsp;&nbsp;printf(\"%d,%d,%d /n\",m_p.GetX(),m_p.GetY(),m_z);<br>&nbsp;}<br>};</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">---------------------------------------</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">上述代码中Point3d是一个3D坐标，他有一个point的2D坐标和一个成员组成。</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">我们现在想定义一个3D坐标p3d，可以这样实现：</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">void main()<br>{<br>&nbsp;point p(1,2);&nbsp;&nbsp;&nbsp; //先定义一个2D坐标</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp;point3d p3d(p,3);</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp;p3d.Print();<br>}<br>从point3d实现体可以看出，我们是通过对m_p进行赋值，这样不仅调用copy constructor产生<a href=\"http://blog.chinaunix.net/u/11680/showart_316503.html\" target=\"_blank\" style=\"color: rgb(179, 43, 213);\"><span style=\"color: rgb(114, 151, 115);\">临时对象</span></a>而且是对m_p的一个赋值操作。</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">而如果使用成员初始化列表，我们则可以这样：</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">void main()<br>{<br>&nbsp;point p(1,2);</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp;<span style=\"color: rgb(204, 51, 51);\">point3d p3d(1,2,3);</span></div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">&nbsp;p3d.Print();<br>}</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">p3d中的point型成员是通过调用初始化的方式构建的。由于对象赋值比初始化要麻烦的多，因此也带来的性能上的消耗。（可以参见Scott Meyers著《effective C++》条款12）。</div><div style=\"font-size: 14px; word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\">这也是我们在对成员数据是对象成员的采用初始化列表进行初始始化的主要原因。</div><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><a href=\"http://www.linuxidc.com/\" target=\"_blank\" style=\"color: rgb(179, 43, 213); font-family: tahoma, 宋体; text-align: justify;\"><img src=\"quiver-image-url/2300D78886562F780F143EC953C6243F.gif\" alt=\"linux\" width=\"15\" height=\"17\" style=\"border: 0px;\"></a></div><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br></div><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br></div><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br></div><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br></div><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><div style=\"word-wrap: break-word; font-family: tahoma, 宋体; line-height: 1.6; color: rgb(51, 51, 51); text-align: justify;\"><div style=\"word-wrap: break-word; line-height: 1.6;\"><span style=\"color: rgb(255, 0, 0);\">二，需要初始化const修饰的类成员；</span></div><div style=\"word-wrap: break-word; line-height: 1.6;\"><span style=\"color: rgb(255, 0, 0);\">三，需要初始化引用成员数据；</span></div><div style=\"word-wrap: break-word; line-height: 1.6;\">对于类成员是const修饰，或是引用类型的情况，是不允许赋值操作的，(显然嘛，const就是防止被错误赋值的，引用类型必须定义赋值在一起)因此只能用初始化列表对齐进行初始化。</div><div style=\"word-wrap: break-word; line-height: 1.6;\">上面两点比较好明白，可以用一个例子加以说明：</div><div style=\"word-wrap: break-word; line-height: 1.6;\">-------------------------------------</div><div style=\"word-wrap: break-word; line-height: 1.6;\">#include &lt;stdio.h&gt;</div><div style=\"word-wrap: break-word; line-height: 1.6;\">class base<br>{<br>private:<br>&nbsp;const int a;<br>&nbsp;int&amp; b;</div><div style=\"word-wrap: break-word; line-height: 1.6;\">public:<br><span style=\"color: rgb(255, 0, 0);\">//&nbsp;base(int m, int n)<br>//&nbsp;{<br>//&nbsp;&nbsp;a = m;<br>//&nbsp;&nbsp;b = n;<br>//&nbsp;}</span></div><div style=\"word-wrap: break-word; line-height: 1.6;\">&nbsp;base(int m, int n):a(m),b(n)<br>&nbsp;{}<br>};</div><div style=\"word-wrap: break-word; line-height: 1.6;\">&nbsp;</div><div style=\"word-wrap: break-word; line-height: 1.6;\">void main()<br>{<br>&nbsp;base ba(1,2);<br>}<br>---------------------------</div><div style=\"word-wrap: break-word; line-height: 1.6;\">上面红色的部分初始化的方式是不允许的通不过编译,通过初始化列表则可以很好的定义。</div></div><a href=\"http://www.linuxidc.com/\" target=\"_blank\" style=\"color: rgb(179, 43, 213); font-family: tahoma, 宋体; text-align: justify;\"><img src=\"quiver-image-url/2300D78886562F780F143EC953C6243F.gif\" alt=\"linux\" width=\"15\" height=\"17\" style=\"border: 0px;\"></a></div>"
    }
  ]
}
{
  "title": "htons函数详解",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\"><span style=\"font-size: medium;\"><span style=\"color: rgb(255, 0, 0);\">Part 1: htons函数具体解释</span></span><br>&nbsp;&nbsp;&nbsp;&nbsp; 在Linux和Windows网络编程时需要用到htons和htonl函数，用来将主机字节顺序转换为网络字节顺序。</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">&nbsp;&nbsp;&nbsp;&nbsp; 在Intel机器下，执行以下程序</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">int main()<br>...{<br>&nbsp;&nbsp; printf(\"%d /n\",htons(16));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;<br>}<br>得到的结果是4096，初一看感觉很怪。</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">&nbsp;&nbsp;&nbsp; 解释如下，数字16的16进制表示为0x0010，数字4096的16进制表示为0x1000。 由于Intel机器是小尾端，存储数字16时实际顺序为1000，存储4096时实际顺序为0010。因此在发送网络包时为了报文中数据为0010，需要 经过htons进行字节转换。如果用IBM等大尾端机器，则没有这种字节顺序转换，但为了程序的可移植性，也最好用这个函数。</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">&nbsp;&nbsp; 另外用注意，数字所占位数小于或等于一个字节（8 bits）时，不要用htons转换。这是因为对于主机来说，大小尾端的最小单位为字节(byte)。</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">&nbsp;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: medium;\"><span style=\"color: rgb(255, 0, 0);\">Part 2: 大小端模式</span></span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><br><span style=\"font-size: small;\">不同的CPU有不同的字节序类型 这些字节序是指整数在内存中保存的顺序 这个叫做主机序&nbsp;<br>最常见的有两种<br>1． Little endian：将低序字节存储在起始地址<br>2． Big endian：将高序字节存储在起始地址</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">LE little-endian&nbsp;<br>最符合人的思维的字节序&nbsp;<br>地址低位存储值的低位&nbsp;<br>地址高位存储值的高位&nbsp;<br>怎么讲是最符合人的思维的字节序，是因为从人的第一观感来说&nbsp;<br>低位值小，就应该放在内存地址小的地方，也即内存地址低位&nbsp;<br>反之，高位值就应该放在内存地址大的地方，也即内存地址高位&nbsp;</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">BE big-endian&nbsp;<br>最直观的字节序&nbsp;<br>地址低位存储值的高位&nbsp;<br>地址高位存储值的低位&nbsp;<br>为什么说直观，不要考虑对应关系&nbsp;<br>只需要把内存地址从左到右按照由低到高的顺序写出&nbsp;<br>把值按照通常的高位到低位的顺序写出&nbsp;<br>两者对照，一个字节一个字节的填充进去&nbsp;</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">例子：在内存中双字0x01020304(DWORD)的存储方式&nbsp;</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">内存地址&nbsp;<br>4000 4001 4002 4003&nbsp;<br>LE 04 03 02 01&nbsp;<br>BE 01 02 03 04&nbsp;</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">例子：如果我们将0x1234abcd写入到以0x0000开始的内存中，则结果为<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; big-endian&nbsp; little-endian<br>0x0000&nbsp; 0x12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xcd<br>0x0001&nbsp; 0x23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xab<br>0x0002&nbsp; 0xab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x34<br>0x0003&nbsp; 0xcd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x12<br>x86系列CPU都是little-endian的字节序.&nbsp;</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">为了进行转换 bsd socket提供了转换的函数 有下面四个<br>htons 把unsigned short类型从主机序转换到网络序<br>htonl 把unsigned long类型从主机序转换到网络序<br>ntohs 把unsigned short类型从网络序转换到主机序<br>ntohl 把unsigned long类型从网络序转换到主机序</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">在使用little endian的系统中 这些函数会把字节序进行转换&nbsp;<br>在使用big endian类型的系统中 这些函数会定义成空宏</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">同样 在网络程序开发时 或是跨平台开发时 也应该注意保证只用一种字节序 不然两方的解释不一样就会产生bug.</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">注：<br>1、网络与主机字节转换函数:htons ntohs htonl ntohl (s 就是short l是long h是host n是network)<br>2、不同的CPU上运行不同的操作系统，字节序也是不同的，参见下表。<br>处理器&nbsp;&nbsp;&nbsp; 操作系统&nbsp;&nbsp;&nbsp; 字节排序<br>Alpha&nbsp;&nbsp;&nbsp; 全部&nbsp;&nbsp;&nbsp; Little endian<br>HP-PA&nbsp;&nbsp;&nbsp; NT&nbsp;&nbsp;&nbsp; Little endian<br>HP-PA&nbsp;&nbsp;&nbsp; UNIX&nbsp;&nbsp;&nbsp; Big endian<br>Intelx86&nbsp;&nbsp;&nbsp; 全部&nbsp;&nbsp;&nbsp; Little endian &lt;-----x86系统是小端字节序系统<br>Motorola680x()&nbsp;&nbsp;&nbsp; 全部&nbsp;&nbsp;&nbsp; Big endian<br>MIPS&nbsp;&nbsp;&nbsp; NT&nbsp;&nbsp;&nbsp; Little endian<br>MIPS&nbsp;&nbsp;&nbsp; UNIX&nbsp;&nbsp;&nbsp; Big endian<br>PowerPC&nbsp;&nbsp;&nbsp; NT&nbsp;&nbsp;&nbsp; Little endian<br>PowerPC&nbsp;&nbsp;&nbsp; 非NT&nbsp;&nbsp;&nbsp; Big endian&nbsp; &lt;-----PPC系统是大端字节序系统<br>RS/6000&nbsp;&nbsp;&nbsp; UNIX&nbsp;&nbsp;&nbsp; Big endian<br>SPARC&nbsp;&nbsp;&nbsp; UNIX&nbsp;&nbsp;&nbsp; Big endian<br>IXP1200 ARM核心&nbsp;&nbsp;&nbsp; 全部&nbsp;&nbsp;&nbsp; Little endian</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"font-size: small;\">本文来自CSDN博客，转载请标明出处：</span><a href=\"http://blog.csdn.net/zouxinfox/archive/2007/10/07/1814088.aspx\"><span style=\"font-size: small;\">http://blog.csdn.net/zouxinfox/archive/2007/10/07/1814088.aspx</span></a></p>"
    }
  ]
}
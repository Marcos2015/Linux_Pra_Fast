{
  "title": "网络函数[04]connect解析",
  "cells": [
    {
      "type": "text",
      "data": "<h1 class=\"postTitle\" style=\"color: rgb(0, 0, 0); font-family: Arial;\"><span style=\"color: rgb(0, 0, 0); font-size: 14px;\">0 -- connect函数解析</span><br></h1><div id=\"cnblogs_post_body\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><pre class=\"motadou_pre_box\">#include &lt;sys/socket.h&gt;\nint connect(int socket, const struct sockaddr * address, socklen_t address_len);\n\n返回值\n 0：建立连接成功；\n-1：建立连接失败或者发生其他错误，请参考errno；</pre><p><br>网络函数connect用来建立一个TCP客户与TCP服务器之间的连接。&nbsp;<br>参数socket，是由socket函数返回的套接口文件描述符；&nbsp;<br>参数address，是一个指向欲连接服务器套接口地址的指针；&nbsp;<br>参数address_len，是参数address表示的套接口地址结构体的大小；&nbsp;<br><br>在讲述connect的使用方法，以及在实际使用中可能遇到的问题之前，我们先看下使用connect进行阻塞连接的例子。</p><pre class=\"motadou_pre_box\">#include &lt;sys/socket.h&gt;\t//socket,connect的定义\n#include &lt;arpa/inet.h&gt;\t//inet_pton的定义\n#include &lt;string.h&gt;       //memset的定义\n#include &lt;netinet/in.h&gt;\t//htons,struct sockaddr_in的定义\n#include &lt;errno.h&gt;        //errno,strerror的定义\n\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\n/***\n ** 函数返回值：\n **  -1:内部调用网络函数错误，请参考相关errno；\n **  -2:网络地址不合法\n ** &gt;=0:网络套接口文件描述符\n **/\nint do_connect(const std::string &amp; s_host, const unsigned short usi_port)\n{\n    //转换指定\n    struct sockaddr_in sock_addr;\n    memset(&amp;sock_addr, 0, sizeof(struct sockaddr_in));\n    sock_addr.sin_family  = AF_INET;\n    sock_addr.sin_port    = ::htons(usi_port);\n\n    switch (::inet_pton(AF_INET, s_host.c_str(), &amp;sock_addr.sin_addr))\n    {\n        case  0: return -2;\n        case -1: return -1;\n    }\n\n    //建立网络套接口文件描述符\n    int sock_fd = ::socket(AF_INET, SOCK_STREAM, 0);\n    if (sock_fd == -1)\n    {\n        return -1;\n    }\n\n    //调用connect函数连接服务器\n    if (::connect(sock_fd, (struct sockaddr *)&amp;sock_addr, sizeof(struct sockaddr_in)) == -1)\n    {\n        return -1;\n    }\n\n    return sock_fd;\n}\n\n#define PRINT_ERRNO(err) printf(\"ERROR(%-15s %4d):%s\\n\", #err, err, strerror(err));\n\nint main(int argc, char ** argv)\n{\n    if (argc != 3)\n    {\n        std::cout &lt;&lt; \"Usage:\" &lt;&lt; argv[0] &lt;&lt; \" host port\" &lt;&lt; std::endl;\n        return -1;\n    }\n\n    PRINT_ERRNO(ECONNREFUSED);\n    PRINT_ERRNO(ENETUNREACH);\n    PRINT_ERRNO(ETIMEDOUT);\n\n    int i_ret = do_connect(argv[1], atoi(argv[2]));\n    if (i_ret == -1)\n    {\n        std::cout &lt;&lt; \"RET:\" &lt;&lt; i_ret &lt;&lt; \"|ENO:\" &lt;&lt; errno \n        &lt;&lt; \"|ERROR:\" &lt;&lt; strerror(errno) &lt;&lt; std::endl;\n        \n        return -1;\n    }\n    if (i_ret == -2)\n    {\n        std::cout &lt;&lt; \"RET:\" &lt;&lt; i_ret &lt;&lt; \"|ERROR:invalid host\" &lt;&lt; std::endl;\n        return -2;\n    }\n\t\n    std::cout &lt;&lt; \"RET:\" &lt;&lt; i_ret &lt;&lt; \"|SUCCESS|\" &lt;&lt; i_ret &lt;&lt; std::endl;\n\n    ::close(i_ret);\n\t\n    return 0;\n}\n</pre><div class=\"motadou_spec_line\">1 -- connect对应errno的解析</div><p>4.3 connect Function</p><p>In the case of a TCP socket, the connect function initiates TCP's three-way handshake (Section 2.6). The function returns only when the connection is established or an error occurs. There are several different error returns possible.</p><p>If the client TCP receives no response to its SYN segment, ETIMEDOUT is returned. 4.4BSD, for example, sends one SYN when connect is called, another 6 seconds later, and another 24 seconds later (p. 828 of TCPv2). If no response is received after a total of 75 seconds, the error is returned.</p><p>Some systems provide administrative control over this timeout; see Appendix E of TCPv1.</p><p>If the server's response to the client's SYN is a reset (RST), this indicates that no process is waiting for connections on the server host at the port specified (i.e., the server process is probably not running). This is a hard error and the error ECONNREFUSED is returned to the client as soon as the RST is received.</p><p>An RST is a type of TCP segment that is sent by TCP when something is wrong. Three conditions that generate an RST are: when a SYN arrives for a port that has no listening server (what we just described), when TCP wants to abort an existing connection, and when TCP receives a segment for a connection that does not exist. (TCPv1 [pp. 246–250] contains additional information.)</p><p>If the client's SYN elicits an ICMP \"destination unreachable\" from some intermediate router, this is considered a soft error. The client kernel saves the message but keeps sending SYNs with the same time between each SYN as in the first scenario. If no response is received after some fixed amount of time (75 seconds for 4.4BSD), the saved ICMP error is returned to the process as either EHOSTUNREACH or ENETUNREACH. It is also possible that the remote system is not reachable by any route in the local system's forwarding table, or that the connect call returns without waiting at all.</p><p>Many earlier systems, such as 4.2BSD, incorrectly aborted the connection establishment attempt when the ICMP \"destination unreachable\" was received. This is wrong because this ICMP error can indicate a transient condition. For example, it could be that the condition is caused by a routing problem that will be corrected.</p><p>Notice that ENETUNREACH is not listed in Figure A.15, even when the error indicates that the destination network is unreachable. Network unreachables are considered obsolete, and applications should just treat ENETUNREACH and EHOSTUNREACH as the same error.</p><div class=\"motadou_spec_line\">1 -- 使用Tcpdump观察connect运行状态</div><p>对于connect，我们想象下实际使用中会遇到那些状况：</p><ol><li>正常连接一个服务器(连接成功的情况)；</li><li>欲连接服务器指定的端口上没有启用监听(服务器可达)；</li><li>有路由信息但服务器不存在的情况；</li><li>连接一个路由不可达的服务器；</li></ol><p>正常连接一个服务器(连接成功的情况)；</p><div class=\"motadou_spec_line\">2 -- 非阻塞connect原理</div><p><a href=\"http://images.cnblogs.com/cnblogs_com/motadou/201012/201012310011159381.jpg\" target=\"_blank\"><img title=\"connect\" src=\"quiver-image-url/FB9DE35D8D03A99B1443C238AF6FDE63.jpg\" alt=\"connect\" border=\"0\" height=\"501\" width=\"513\" style=\"display: inline; border-width: 0px; width: 667px;\"></a></p><div class=\"motadou_spec_line\">3 -- 非阻塞connect(基于select实现)</div><div class=\"motadou_spec_line\">4 -- 非阻塞connect(基于epoll实现)</div></div>"
    }
  ]
}
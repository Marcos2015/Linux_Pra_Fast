{
  "title": "为你详解Linux安装GCC方法",
  "cells": [
    {
      "type": "text",
      "data": "<h2 style=\"color: rgb(0, 0, 0); font-family: Arial; margin: 0px 0px 4px; font-size: 14px;\"><br></h2><div class=\"postbody\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><div id=\"cnblogs_post_body\"><p style=\"margin: 5px auto;\">下载：&nbsp;<a href=\"http://ftp.gnu.org/gnu/gcc/gcc-4.5.1/gcc-4.5.1.tar.bz2\" target=\"_blank\" style=\"color: rgb(29, 88, 209); text-decoration: none;\">http://ftp.gnu.org/gnu/gcc/gcc-4.5.1/gcc-4.5.1.tar.bz2</a><br>浏览：&nbsp;<a href=\"http://ftp.gnu.org/gnu/gcc/gcc-4.5.1/\" target=\"_blank\" style=\"color: rgb(29, 88, 209); text-decoration: none;\">http://ftp.gnu.org/gnu/gcc/gcc-4.5.1/</a><br>查看Changes：&nbsp;<a href=\"http://gcc.gnu.org/gcc-4.5/changes.htm\" target=\"_blank\" style=\"color: rgb(29, 88, 209); text-decoration: none;\">http://gcc.gnu.org/gcc-4.5/changes.htm</a></p><p class=\"newtext\" style=\"margin: 5px auto;\">现在很多程序员都应用GCC，怎样才能更好的应用GCC。目前，GCC可以用来编译C/C++、FORTRAN、JAVA、OBJC、ADA等语言的程序，可根据需要选择安装支持的语言。本文以在Redhat Linux安装GCC4.1.2为例(因在项目开发过程中要求使用，没有用最新的GCC版本)，介绍Linux安装GCC过程。</p><p class=\"newtext\" style=\"margin: 5px auto;\">安装之前，系统中必须要有cc或者gcc等编译器，并且是可用的，或者用环境变量CC指定系统上的编译器。如果系统上没有编译器，不能安装源代码形式的GCC 4.1.2。如果是这种情况，可以在网上找一个与你系统相适应的如RPM等二进制形式的GCC软件包来安装使用。本文介绍的是以源代码形式提供的GCC软件包的安装过程，软件包本身和其安装过程同样适用于其它Linux和Unix系统。</p><p class=\"newtext\" style=\"margin: 5px auto;\">系统上原来的GCC编译器可能是把gcc等命令文件、库文件、头文件等分别存放到系统中的不同目录下的。与此不同，现在GCC建议我们将一个版本的GCC安装在一个单独的目录下。这样做的好处是将来不需要它的时候可以方便地删除整个目录即可(因为GCC没有uninstall功能);缺点是在安装完成后要做一些设置工作才能使编译器工作正常。在本文中采用这个方案安装GCC 4.1.2，并且在安装完成后，仍然能够使用原来低版本的GCC编译器，即一个系统上可以同时存在并使用多个版本的GCC编译器。</p><p class=\"newtext\" style=\"margin: 5px auto;\">按照本文提供的步骤和设置选项，即使以前没有安装过GCC，也可以在系统上安装上一个可工作的新版本的GCC编译器。</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>1 下载</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">在GCC网站上(<a href=\"http://gcc.gnu.org/\">http://gcc.gnu.org</a>)或者通过网上搜索可以查找到下载资源。目前GCC的最新版本为 4.2.1。可供下载的文件一般有两种形式：gcc-4.1.2.tar.gz和gcc-4.1.2.tar.bz2，只是压缩格式不一样，内容完全一致，下载其中一种即可。</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>2. 解压缩</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">拷贝gcc-4.1.2.tar.bz2(我下载的压缩文件)到/usr/local/src(根据自己喜好选择)下,根据压缩格式，选择下面相应的一种方式解包(以下的“%”表示命令行提示符)：</p><p class=\"newtext\" style=\"margin: 5px auto;\">% tar zxvf gcc-4.1.2.tar.gz</p><p class=\"newtext\" style=\"margin: 5px auto;\">或者</p><p class=\"newtext\" style=\"margin: 5px auto;\">% bzcat gcc-4.1.2.tar.bz2 | tar xvf -</p><p class=\"newtext\" style=\"margin: 5px auto;\">新生成的gcc-4.1.2这个目录被称为源目录，用${srcdir}表示它。以后在出现${srcdir}的地方，应该用真实的路径来替换它。用pwd命令可以查看当前路径。</p><p class=\"newtext\" style=\"margin: 5px auto;\">在${srcdir}/INSTALL目录下有详细的GCC安装说明，可用浏览器打开index.html阅读。</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>3. 建立目标目录</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">目标目录(用${objdir}表示)是用来存放编译结果的地方。GCC建议编译后的文件不要放在源目录${srcdir]中(虽然这样做也可以)，最好单独存放在另外一个目录中，而且不能是${srcdir}的子目录。</p><p class=\"newtext\" style=\"margin: 5px auto;\">例如，可以这样建立一个叫 /usr/local/gcc-4.1.2的目标目录：</p><p class=\"newtext\" style=\"margin: 5px auto;\">% mkdir /usr/local/gcc-4.1.2</p><p class=\"newtext\" style=\"margin: 5px auto;\">% cd gcc-4.1.2</p><p class=\"newtext\" style=\"margin: 5px auto;\">以下的操作主要是在目标目录 ${objdir} 下进行。(否则会出错，后面有解释)</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>4. 配置</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">配置的目的是决定将GCC编译器安装到什么地方(${destdir})，支持什么语言以及指定其它一些选项等。其中，${destdir}不能与${objdir}或${srcdir}目录相同。</p><p class=\"newtext\" style=\"margin: 5px auto;\">配置是通过执行${srcdir}下的configure来完成的。其命令格式为(记得用你的真实路径替换${destdir})：</p><p class=\"newtext\" style=\"margin: 5px auto;\">% ${srcdir}/configure --prefix=${destdir} [其它选项]</p><p class=\"newtext\" style=\"margin: 5px auto;\">例如，如果想将GCC 4.1.2安装到/usr/local/gcc-4.1.2目录下，则${destdir}就表示这个路径。</p><p class=\"newtext\" style=\"margin: 5px auto;\">在我的机器上，我是这样配置的：</p><p class=\"newtext\" style=\"margin: 5px auto;\">% ../gcc-4.1.2/configure --prefix=/usr/local/gcc-4.1.2 --enable-threads=posix --disable-checking --enable--long-long --host=i386-redhat-linux--with-system-zlib --enable-languages=c,c++,java</p><p class=\"newtext\" style=\"margin: 5px auto;\">将GCC安装在/usr/local/gcc-4.1.2目录下，支持C/C++和JAVA语言，其它选项参见GCC提供的帮助说明。</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>5. 编译</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">% make</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>6. 安装</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">执行下面的命令将编译好的库文件等拷贝到${destdir}目录中(根据你设定的路径，可能需要管理员的权限)：</p><p class=\"newtext\" style=\"margin: 5px auto;\">% make install</p><p class=\"newtext\" style=\"margin: 5px auto;\">至此，GCC 4.1.2安装过程就完成了。</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>7. 其它设置</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">GCC 4.1.2的所有文件，包括命令文件(如gcc、g++)、库文件等都在${destdir}目录下分别存放，如命令文件放在bin目录下、库文件在 lib下、头文件在include下等。由于命令文件和库文件所在的目录还没有包含在相应的搜索路径内，所以必须要作适当的设置之后编译器才能顺利地找到并使用它们。</p><p class=\"newtext\" style=\"margin: 5px auto;\">7.1 gcc、g++、gcj的设置</p><p class=\"newtext\" style=\"margin: 5px auto;\">要想使用GCC 4.1.2的gcc等命令，简单的方法就是把它的路径${destdir}/bin放在环境变量PATH中。我不用这种方式，而是用符号连接的方式实现，这样做的好处是我仍然可以使用系统上原来的旧版本的GCC编译器。</p><p class=\"newtext\" style=\"margin: 5px auto;\">首先，查看原来的gcc所在的路径：</p><p class=\"newtext\" style=\"margin: 5px auto;\">% which gcc</p><p class=\"newtext\" style=\"margin: 5px auto;\">在我的系统上，上述命令显示：/usr/bin/gcc。因此，原来的gcc命令在/usr/bin目录下。我们可以把GCC 4.1.2中的gcc、g++、gcj等命令在/usr/bin目录下分别做一个符号连接：</p><p class=\"newtext\" style=\"margin: 5px auto;\">% cd /usr/bin</p><p class=\"newtext\" style=\"margin: 5px auto;\">% ln -s ${destdir}/bin/gcc gcc412</p><p class=\"newtext\" style=\"margin: 5px auto;\">% ln -s ${destdir}/bin/g++ g++412</p><p class=\"newtext\" style=\"margin: 5px auto;\">% ln -s ${destdir}/bin/gcj gcj412</p><p class=\"newtext\" style=\"margin: 5px auto;\">这样，就可以分别使用gcc412、g++412、gcj412来调用GCC 4.1.2的gcc、g++、gcj完成对C、C++、JAVA程序的编译了。同时，仍然能够使用旧版本的GCC编译器中的gcc、g++等命令。</p><p class=\"newtext\" style=\"margin: 5px auto;\">(cool，我感觉棒极了!!1)</p><p class=\"newtext\" style=\"margin: 5px auto;\">7.2 库路径的设置</p><p class=\"newtext\" style=\"margin: 5px auto;\">将${destdir}/lib路径添加到环境变量LD_LIBRARY_PATH中，例如，如果GCC 4.1.2安装在/usr/local/gcc-4.1.2目录下，在RH Linux下可以直接在命令行上执行</p><p class=\"newtext\" style=\"margin: 5px auto;\">% export LD_LIBRARY_PATH=/usr/local/gcc-4.1.2/lib</p><p class=\"newtext\" style=\"margin: 5px auto;\">最好添加到系统的配置文件中，这样就不必要每次都设置这个环境变量了,在文件$HOME/.bash_profile中添加下面两句：</p><p class=\"newtext\" style=\"margin: 5px auto;\">LD_LIBRARY_PATH=/usr/local/gcc-4.1.2/lib:$LD_LIBRARY_PATH</p><p class=\"newtext\" style=\"margin: 5px auto;\">export LD_LIBRARY_PATH</p><p class=\"newtext\" style=\"margin: 5px auto;\">重启系统设置生效，或者执行命令</p><p class=\"newtext\" style=\"margin: 5px auto;\">% source $HOME/.bash_profile</p><p class=\"newtext\" style=\"margin: 5px auto;\">用新的编译命令(gcc412、g++412等)编译你以前的C、C++程序，检验新安装的GCC编译器是否能正常工作。</p><p class=\"newtext\" style=\"margin: 5px auto;\">完成了Linux安装GCC，之后你就能轻松地编辑了。</p><p class=\"newtext\" style=\"margin: 5px auto;\">from:<a href=\"http://os.51cto.com/art/200912/168804.htm\">os.51cto.com/art/200912/168804.htm</a></p><p class=\"newtext\" style=\"margin: 5px auto;\">在RHLinux下安装gcc-4.0.1方法比较简单，但是安装过程中有些环节是需要注意的，否则，可能会导致安装不成功，或者安装报错。具体安装过程如下：</p><p class=\"newtext\" style=\"margin: 5px auto;\">首先，下载并解压缩gcc的RPM包至源目录(如/opt/gcc-4.0.1)</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>1、解压缩RPM包：</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">[root@linuxopt]# tar xjvf gcc-4.0.1.tar.bz2 (解压后生成源目录/opt/gcc-4.0.1)</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>2、创建安装目标目录：</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">[root@linux opt]# mkdir /usr/local/gcc-4.0.1/</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>3、进入安装目标目录：</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">[root@linux opt]# cd /usr/local/gcc-4.0.1/ (这一步很重要，配置安装文件时，需要在目标目录下执行configure命令)</p><p class=\"newtext\" style=\"margin: 5px auto;\">[root@linux opt]# pwd</p><p class=\"newtext\" style=\"margin: 5px auto;\">/usr/local/gcc-4.0.1</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>4、配置安装文件：</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">[root@linux gcc-4.0.1]# /opt/gcc-4.0.1/configure --prefix=/usr/local/gcc-4.0.1/ (这一步非常重要，需要在安装的目标目录下，执行源目录 /opt/gcc-4.0.1/中的configure命令，配置将gcc安装到目标目录/usr/local/gcc-4.0.1/)</p><p class=\"newtext\" style=\"margin: 5px auto;\">creating cache ./config.cache</p><p class=\"newtext\" style=\"margin: 5px auto;\">checking host system type... i686-pc-linux-gnu</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>5、编译安装文件：</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">[root@linux gcc-4.0.1]# pwd</p><p class=\"newtext\" style=\"margin: 5px auto;\">/usr/local/gcc-4.0.1</p><p class=\"newtext\" style=\"margin: 5px auto;\">[root@linux gcc-4.0.1]# make (在目标目录下执行编译)</p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>6、安装gcc：</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\">[root@linux gcc-4.0.1]# pwd</p><p class=\"newtext\" style=\"margin: 5px auto;\">/usr/local/gcc-4.0.1</p><p class=\"newtext\" style=\"margin: 5px auto;\">[root@linux gcc-4.0.1]# make install (在目标目录下执行安装)</p><p class=\"newtext\" style=\"margin: 5px auto;\">如果安装过程中步骤和命令没有错误，你肯定能安装成功。</p><p class=\"newtext\" style=\"margin: 5px auto;\">&nbsp;</p><p class=\"newtext\" style=\"margin: 5px auto;\">---------------------------------------------------------------------</p><p class=\"newtext\" style=\"margin: 5px auto;\">&nbsp;</p><p class=\"newtext\" style=\"margin: 5px auto;\">　　首先，现在最新的包GCC 4.2.bz2，一般的到处都有的下，linux下的下载速度很满，20多k，很恶心，我喜欢迅雷的下载速度，在windows下下载，大概42M，下载速度2到4M，回到linux下，挂载，ntfs格式的我的，具体不说了，说安装！&nbsp;<br><br>　　进入到挂载的目录下，先cp GCC4.2.bz2 /azuo，&nbsp;<br><br>　　cd /azuo，&nbsp;<br><br>　　tar -xvf GCC 4.2.bz2 ，&nbsp;<br><br>　　得到gcc-4.2,&nbsp;<br><br>　　cd gcc-4.2，在/usr目录下建立一个文件夹就是现在要存放新的gcc的目录，&nbsp;<br><br>　　mkdir /usr/gcc4&nbsp;<br><br>　　./configure –prefix=/usr/gcc4&nbsp;<br><br>　　回车，就会有配置信息，只要不报错就可以了，&nbsp;<br><br>　　make，这个过程很久，因为我没有设置一些具体的选项，因此，所有的组件几乎都要编译一遍，我的电脑cpu：AMD 3200＋X2 ，1.5g内存，大概花费一个半小时。&nbsp;<br><br>　　到这个时候为止，/usr/gcc4下还没有任何东西，编译过程都是发生在源文件夹，让我们再来一个动作，所有的要用到的东西都会配置到目标文件夹下，&nbsp;<br><br>　　make install；&nbsp;<br><br>　　这个过程也不短，等着就是了。&nbsp;<br><br>　　一切都已经弄好了之后就是使用最新的gcc了，可以看到，在/usr/gcc4/bin下有gcc，g++，等一些东西，都是可以用的，写两个程序：&nbsp;<br><br>　　aa.c：&nbsp;<br><br>　　1 #include&nbsp;<br><br>　　2&nbsp;<br><br>　　3 int main(void) {&nbsp;<br><br>　　4 printf(\"ad\");&nbsp;<br><br>　　5 return 1;&nbsp;<br><br>　　6 }&nbsp;<br><br>　　gcc -o aa aa.c&nbsp;<br><br>　　执行 ./aa&nbsp;<br><br>　　上面的这个是c的，下面这个就是c++的了：&nbsp;<br><br>　　a.cpp:&nbsp;<br><br>　　1 #include&nbsp;<br><br>　　2 using namespace std;&nbsp;<br><br>　　3 int main(void) {&nbsp;<br><br>　　4 cout &lt;&lt; \"Ok!\" &lt;&lt; endl;&nbsp;<br><br>　　5 return 1;&nbsp;<br><br>　　6 }&nbsp;<br><br>　　g++ -o a a.cpp&nbsp;<br><br>　　执行就是了./a&nbsp;<br><br>　　一切ok了，就可以让最新的gcc工具取代原来的工具了。&nbsp;<br><br>　　看看原来的gcc是什么版本的，我们好卸载它：&nbsp;<br><br>　　[root@BTazuo bin]# rpm -qa gcc&nbsp;<br><br>　　gcc-4.1.2-27.fc7&nbsp;<br><br>　　[root@BTazuo bin]# rpm -e gcc-4.1.2-27.fc7&nbsp;<br><br>　　error: Failed dependencies:&nbsp;<br><br>　　gcc is needed by (installed) systemtap-0.5.13-1.fc7.i386&nbsp;<br><br>　　gcc = 4.1.2-27.fc7 is needed by (installed) gcc-c++-4.1.2-27.fc7.i386&nbsp;<br><br>　　gcc = 4.1.2-27.fc7 is needed by (installed) gcc-gfortran- 4.1.2 -27.fc7. i386&nbsp;<br><br>　　[root@BTazuo bin]# rpm -e gcc-c++-4.1.2-27.fc7.i386&nbsp;<br><br>　　[root@BTazuo bin]# rpm -e gcc-gfortran-4.1.2-27.fc7.i386&nbsp;<br><br>　　[root@BTazuo bin]# rpm -e gcc-4.1.2-27.fc7&nbsp;<br><br>　　error: Failed dependencies:&nbsp;<br><br>　　gcc is needed by (installed) systemtap-0.5.13-1.fc7.i386&nbsp;<br><br>　　[root@BTazuo bin]# g++&nbsp;<br><br>　　bash: g++: command not found&nbsp;<br><br>　　卸载成功&nbsp;<br><br>　　[root@BTazuo bin]# gcc&nbsp;<br><br>　　gcc: 没有输入文件 ，可见gcc犹在&nbsp;<br><br>　　[root@BTazuo bin]# rpm -e systemtap-0.5.13-1.fc7.i386&nbsp;<br><br>　　[root@BTazuo bin]# gcc&nbsp;<br><br>　　gcc: 没有输入文件&nbsp;<br><br>　　[root@BTazuo bin]# rpm -e gcc-4.1.2-27.fc7&nbsp;<br><br>　　[root@BTazuo bin]# gcc&nbsp;<br><br>　　bash: /usr/lib/ccache/gcc: 没有那个文件或目录&nbsp;<br><br>　　最后的卸载成功！&nbsp;<br><br>　　这个时候，要注意了，我的gcc在/usr/bin下面有，在/usr/lib/ccache这个目录下也有，分别在这两个下面都要建立一个链接：&nbsp;<br><br>　　[root@BTazuo bin]# ln -s /usr/gcc4/bin/g++ g++&nbsp;<br><br>　　[root@BTazuo bin]# g++&nbsp;<br><br>　　g++: 没有输入文件&nbsp;<br><br>　　可见g++已经装好了，可以使用了。&nbsp;<br><br>　　然后是gcc：&nbsp;<br><br>　　[root@BTazuo bin]# ln -s /usr/gcc4/bin/gcc gcc&nbsp;<br><br>　　[root@BTazuo bin]# gcc&nbsp;<br><br>　　bash: /usr/lib/ccache/gcc: 没有那个文件或目录&nbsp;<br><br>　　[root@BTazuo bin]# ./gcc&nbsp;<br><br>　　gcc: 没有输入文件&nbsp;<br><br>　　可见还要给另外一个目录建立一个gcc的链接：&nbsp;<br><br>　　[root@BTazuo lib]# ln -s /usr/gcc4/bin/gcc /usr/lib/ccache/gcc&nbsp;<br><br>　　[root@BTazuo lib]# gcc&nbsp;<br><br>　　gcc: 没有输入文件&nbsp;<br><br>　　到此为止，gcc和g++都已经建立好了，可以用了，最后把原来的包和解压文件都可以删除了，以节省硬盘空间！</p><p class=\"newtext\" style=\"margin: 5px auto;\">-------------------------------------------------------------------------------------------------------</p><p class=\"newtext\" style=\"margin: 5px auto;\">下面介绍其在Red Hat Linux 9.0编译器给gcc 3.2.2环境下的安装方法。<br>一．确定安装环境<br>本安装方法适用于Red Hat Linux 9.0操作系统，自带的GCC编译器是GCC 3.2.2版本。其他系列的linux操作系统或是其他版本GCC下安装过程可能有些细节上的不同。<br>注：因为不同版本的GCC编译器下一些库的定义可能有不同，因此首先要确定一下本机的GCC编译器版本。确定方法是进入命令行输入命令gcc –v得到的结果如图1.1所示：<br><br><img src=\"quiver-image-url/9D07CCE7C79C381715CC65C83F52F613.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"721\" height=\"113\"><br><strong>图1.1<br>可见本机的GCC版本为GCC 3.2.2，根据simplescalar网站上的一些介绍，该模拟器的开发工具可能是GCC2.7左右，比较接近GCC 3.2.2，因此估计安装过程会比较顺利。<br>二.获得安装包<br>完成本安装过程的安装包可以在</strong><br><a href=\"http://www.simplescalar.com/\" target=\"_blank\" style=\"color: rgb(29, 88, 209); text-decoration: none;\">http://www.simplescalar.com</a><br><strong>下下载，本安装所需要的安装包共有以下三个<br><img src=\"quiver-image-url/5163F830D5033687E4F401D3F5A42A5A.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"547\" height=\"36\"><br>三 建立安装目录，解压安装包<br>建立安装目录为/root/simplescalar,将安装包复制到安装目录，整个过程如下：<br><img src=\"quiver-image-url/7F93603FA20A0820E0202A1A3582D413.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"550\" height=\"115\"><br>解压缩，命令为tar –zxvf,加压缩完毕后用rm*.tgz命令删除压缩包，整个过程输入命令如下：<br>tar –zxvf simplesim-3v0d.tgz<br>tar –zxvf simpletools-2v0.tgz<br>tar –zxvf simpleutils-2v0.tgz<br>rm*.tgz<br>加压缩后得到如下七个文件夹：<br><img src=\"quiver-image-url/B80A123E2E501C19C249E67F0399258B.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"578\" height=\"68\"><br>四.安装binutils2.5.2<br>首先用configure命令配置程序的安装环境和参数，生成Makefile文件，整个过程如下：<br><img src=\"quiver-image-url/86ECFBF45AA696B40200A36FD0D7BD9E.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"719\" height=\"51\"><br>注：configure命令的参数含义说明<br>-host:配置安装环境<br>-target:配置成littleEndian模式<br>-with-gnu-as 加载汇编器<br>-with-gnu-ld 加载链接器<br>-prefix 设置安装目录<br>此时遇到两个错误，如下所示：<br>&nbsp;&nbsp;<br><img src=\"quiver-image-url/1CFF488EAA64640E4FD107EE5BC1AD2E.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"713\" height=\"271\"><br>从错误说明可以估计出错误来自于libiberty文件夹下的dummy.c文件。网上一些帖子说是dummy.c中定义的宏functions.def文件中的函数定义与声明不一致引起的，将它们改成一致就可以通过编译。但是这样做的话，继续编译依然会遇到许多错误。这里我试出了最好的方法就是将dummy.c文件中的内容全部删除（即将dummy.c变成空文件）然后再make一次，这回不报任何错误，编译一次通过！<br>运行make install命令，这时binutils-2.5.2安装成功！<br>五.安装simplescalar<br>Simplescalar是最简单的一个安装过程，运行下列命令即可完成安装！<br><br><img src=\"quiver-image-url/C9DDAA4300E81D2026E5A0B7C7D81F0C.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"670\" height=\"212\"><br>六.安装gcc-2.6.3<br>安装好simplescalar后在安装文件夹/root/simplescalar下可以找到一个名为bin的文件夹，里面包含的是一些simplescalar自带的工具，如链接工具等，该文件内容如下：<br><br><img src=\"quiver-image-url/73A338E239A278C26D38937AFC075E47.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"497\" height=\"130\"><br>可见，里面没有C编译工具gcc，因此还需要安装gcc2.6.3作为simplescalar的内置编译工具，下面介绍安装方法。<br>首先对安装环境进行配置，生成Makefile文件，具体方法如下图所示。<br><br><img src=\"quiver-image-url/02C9870B7FADB6C92AC69C2F1CAD729F.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"724\" height=\"291\"><br>Makefile文件生成完毕后，运行make命令，此时出现以下错误：<br><br><img src=\"quiver-image-url/0BD20828BE8F6CECE54D48E8FDE36E19.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"657\" height=\"63\"><br>由错误报告可知，这是由于sys_errlist的定义不一致造成的，打开cccp.c文件发现其194行附近有如下代码，第194行为extern char *sys_errlist[]。显然要消除冲突，只需改变宏编译的分支方向，使其不走这一分支即可。尝试在这段代码前面如175行加上#define bsd4_4，修改后再次make,该错误改正，遇到下一个错误。<br>&nbsp;&nbsp;<br><img src=\"quiver-image-url/D0F3B49968399D243EC38BE4FBCF4B74.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"389\" height=\"221\"><br>第二个错误是sdbout.c文件中的一些常量没有定义，如下：<br><br><img src=\"quiver-image-url/ED5ADEB31A257475CB8AB45D08C34915.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"588\" height=\"79\"><br></strong><strong><br>因此第一估计是头文件的问题，打开sdbout.c发现其包含的头文件有如下几个：&nbsp;<br><img src=\"quiver-image-url/CFF6FFCB7AC27938B0C974FA9606E28C.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"652\" height=\"376\"><br>可以肯定报错的原因是宏编译的分支的问题（走不同的宏编译分支，可能包含syms.h或者是gsyms.h）。经过多次尝试，发现在前面加上#undef&nbsp;&nbsp;USG即可解决该错误（即把gsyms.h包含进去）。<br>继续make,发生第三个错误，如下：<br><br><img src=\"quiver-image-url/AD0B6928A8A903AA14586BC5BF5DBD66.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"663\" height=\"66\"><br>这个错误和第一个错误一样，是由于sys_errlist定义冲突引起的，因此进入gcc.c文件，在172行之前（这里加在167行）加上#define bsd4_4即可。<br>继续make,发生第四个错误，如下：<br><br><img src=\"quiver-image-url/797E4EF8B686206E835213295F000338.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"663\" height=\"66\"><br>和前面一样，只要在g++.c文件的第90行代码段之前（这里加在85行）加上#define bsd4_4即可。<br>继续make,发生第五个错误，如下：&nbsp;<br><br><img src=\"quiver-image-url/76157C8C6AEA255D13EEB585B43EE104.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"727\" height=\"97\"><br>这里提示是将cp/g++.c文件中第213行的sys_errlist改成strerror或者strerror_r，然而改过之后会报strerror未定义的错误，上网搜了很久也没发现有这两个定义的头文件名，最后根据函数名感觉这段代码(pfatal_with_name)的功能可能是获得错误名，将其删除估计对工作影响不大，因此干脆将这个函数放空，放空后再运行make，果然OK,不报任何错误，编译通过！<br>运行make install,gcc 2.6.3安装成功！<br>返回simplescalar，进入bin文件夹，可以发现里面多了一个sslittle-na-sstrix-gcc文件，该文件是simplescalar的内建C编译器，如下所示：<br><br><img src=\"quiver-image-url/9A90C7CF9E9A5F3A1518955BDA73AB54.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"494\" height=\"159\"><br>进一步运行./sslittle-na-sstrix-gcc –v测试出该内建编译器版本为gcc 2.6.3。<br><br><img src=\"quiver-image-url/978C7710CCCBC2872390913F86FB5B70.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"725\" height=\"77\"><br>到此为止，整个安装过程结束，下面进行测试。<br>七.测试<br>为了测试simplescalar是否能够顺利运行，我们对其进行测试，测试程序依然采用最经典的hello world！程序，程序如下：<br>&nbsp; &nbsp; #include&nbsp;<br>main()<br>{<br>printf(\"Hello World!\\n\");<br>return 0;<br>}<br>编辑好程序后将其保存在/root/simplescalar文件夹下，文件名为hello.c,用刚刚安装的simplescalar内建编译器编译，编译方法如下。<br><br><img src=\"quiver-image-url/1DB7DF66D1C2A643B972203A3104265D.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"475\" height=\"48\"><br>&nbsp; &nbsp; 运行结果如下：<br><br><img src=\"quiver-image-url/0061D19DC7F3275A72A2777E59A0D033.jpg\" border=\"0\" alt=\"\" style=\"border: 0px;\" width=\"610\" height=\"408\"><br>八 结束语<br>本安装方法适用于Red Hat Linux 9.0操作系统，自带的GCC编译器是GCC 3.2.2版本。其他系列的linux操作系统或是其他版本GCC下安装过程可能有些细节上的不同，主要原因可能是高版本的GCC没有兼容低版本的一些库文件，还有就是遵循的C标准可能会有点出入。如果机器上的GCC正好是低版本的，估计可能一次编译通过！<br>-----------------------------------------------------------------------------------------------------</strong></p><p class=\"newtext\" style=\"margin: 5px auto;\"><span style=\"color: rgb(0, 0, 255);\">　　1. 下载&nbsp;</span><br>　　在GCC网站上（<br><span style=\"text-decoration: underline;\"><span style=\"color: rgb(0, 0, 255);\"><a href=\"http://gcc.gnu.org/\">http://gcc.gnu.org/</a></span></span><br>）或通过网上搜索能查找到下载资源。目前GC<br>C的最新版本为3.4.0。可供下载的文件一般有两种形式：gcc-3.4.0.tar.gz和gcc-3.4.0.tar.bz2，<br>只是压缩格式不相同，内容完全一致，下载其中一种即可。&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　2. 解压缩&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　根据压缩格式，选择下面相应的一种方式解包（以下的\"%\"表示命令行提示符）：&nbsp;</span><br>　　% tar xzvf gcc-3.4.0.tar.gz<br>或<br>% bzcat gcc-3.4.0.tar.bz2 | tar xvf -&nbsp;<br>　　新生成的gcc-3.4.0这个目录被称为源目录，用${srcdir}表示他。以后在出现${srcdir<br>}的地方，应该用真实的路径来替换他。用pwd命令能查看当前路径。&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　在${srcdir}/INSTALL目录下有周详的GCC安装说明，可用浏览器打开index.html阅读。&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　3. 建立目标目录&nbsp;</span><br>　　目标目录（用${objdir}表示）是用来存放编译结果的地方。GCC建议编译后的文件不要<br>放在源目录${srcdir]中（虽然这样做也能），最佳独立存放在另外一个目录中，而且不<br>能是${srcdir}的子目录。&nbsp;<br>　　例如，能这样建立一个叫 gcc-build<br>的目标目录（和源目录${srcdir}是同级目录）：&nbsp;<br>　　% mkdir gcc-build<br>% cd gcc-build&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　以下的操作主要是在目标目录 ${objdir} 下进行。&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　4. 设置&nbsp;</span><br>　　设置的目的是决定将GCC编译器安装到什么地方（${destdir}），支持什么语言及指<br>定其他一些选项等。其中，${destdir}不能和${objdir}或${srcdir}目录相同。&nbsp;<br>　　设置是通过执行${srcdir}下的configure来完成的。其命令格式为（记得用你的真实路<br>径替换${destdir}）：&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　% ${srcdir}/configure --prefix=${destdir} [其他选项]&nbsp;</span><br>　　例如，如果想将GCC<br>3.4.0安装到/usr/local/gcc-3.4.0目录下，则${destdir}就表示这个路径。&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　在我的机器上，我是这样设置的：&nbsp;</span><br>　　% ../gcc-3.4.0/configure --prefix=/usr/local/gcc-3.4.0<br>--enable-threads=posix --disable-checking --enable--long-long<br>--host=i386-redhat-linux --with-system-zlib --enable-languages=c,c++,java&nbsp;<br>　　将GCC安装在/usr/local/gcc-3.4.0目录下，支持C/C++和JAVA语言，其他选项参见GCC<br>提供的帮助说明。&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　5. 编译&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　% make&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　这是个漫长的过程。在我的机器上（P4-1.6），这个过程用了50多分钟。&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　6. 安装&nbsp;</span><br>　　执行下面的命令将编译好的库文件等拷贝到${destdir}目录中（根据你设定的路径，可<br>能需要管理员的权限）：&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　% make install&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　至此，GCC 3.4.0安装过程就完成了。&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　6. 其他设置&nbsp;</span><br>　　GCC<br>3.4.0的所有文件，包括命令文件（如gcc、g++）、库文件等都在${destdir}目录下分别存<br>放，如命令文件放在bin目录下、库文件在lib下、头文件在include下等。由于命令文件和<br>库文件所在的目录还没有包含在相应的搜索路径内，所以必须要作适当的设置之后编译器才<br>能顺利地找到并使用他们。&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　6.1 gcc、g++、gcj的设置&nbsp;</span><br>　　要想使用GCC<br>3.4.0的gcc等命令，简单的方法就是把他的路径${destdir}/bin放在环境变量PATH中。我不<br>用这种方式，而是用符号连接的方式实现，这样做的好处是我仍然能使用系统上原来的旧<br>版本的GCC编译器。&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　首先，查看原来的gcc所在的路径：&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　% which gcc&nbsp;</span><br>　　在我的系统上，上述命令显示：/usr/bin/gcc。因此，原来的gcc命令在/usr/bin目录<br>下。我们能把GCC<br>3.4.0中的gcc、g++、gcj等命令在/usr/bin目录下分别做一个符号连接：&nbsp;<br>　　% cd /usr/bin<br>% ln -s ${destdir}/bin/gcc gcc34<br>% ln -s ${destdir}/bin/g++ g++34<br>% ln -s ${destdir}/bin/gcj gcj34&nbsp;<br>　　这样，就能分别使用gcc34、g++34、gcj34来调用GCC<br>3.4.0的gcc、g++、gcj完成对C、C++、JAVA程式的编译了。同时，仍然能够使用旧版本的GC<br>C编译器中的gcc、g++等命令。&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　6.2 库路径的设置&nbsp;</span><br>　　将${destdir}/lib路径添加到环境变量LD_LIBRARY_PATH中，最佳添加到系统的设置文<br>件中，这样就不必要每次都设置这个环境变量了。&nbsp;<br>　　例如，如果GCC 3.4.0安装在/usr/local/gcc-3.4.0目录下，在RH<br>Linux下能直接在命令行上执行或在文件/etc/profile中添加下面一句：&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　setenv LD_LIBRARY_PATH /usr/local/gcc-3.4.0/lib:$LD_LIBRARY_PATH&nbsp;</span><br><span style=\"color: rgb(0, 0, 255);\">　　7. 测试&nbsp;</span><br>　　用新的编译命令（gcc34、g++34等）编译你以前的C、C++程式，检验新安装的GCC编译<br>器是否能正常工作。&nbsp;<br><span style=\"color: rgb(0, 0, 255);\">　　8. 根据需要，能删除或保留${srcdir}和${objdir}目录。</span></p><p class=\"newtext\" style=\"margin: 5px auto;\"><strong>&nbsp;</strong></p><p style=\"margin: 5px auto;\">&nbsp;</p></div><div id=\"blog_post_info_block\" style=\"margin-top: 20px;\"><div id=\"BlogPostCategory\">分类:&nbsp;<a href=\"http://www.cnblogs.com/chuncn/category/265759.html\" style=\"color: rgb(29, 88, 209); text-decoration: none;\">linux</a></div></div></div>"
    }
  ]
}
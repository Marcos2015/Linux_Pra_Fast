{
  "title": "ACE这么蛋疼的复杂有人在用吗？",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><h4>引用来自“Jack.arain”的答案</h4><div>这不很简单嘛? 不喜欢用就别用, 就像我不喜欢ACE, 不喜欢MFC, 我就不用, 我不喜欢它是在基于了解它的情况下, 我有我的理由, 但我不会把自己的观点强加于别人, 希望别人也和我一样不要用它不喜欢它.&nbsp;&nbsp;</div><div>但千万别在什么都不了解的情况下, 先来一千万个理由, 说服自己它很烂, 这不是一个好的学习方法.&nbsp;</div><div>另外, ACE框架是不是装B, 其实装B也是要有条件的, 拿语言和工具来装B, 是很肤浅的, 也只会有肤浅人才会认为其牛B, 在国内这个怪圈里有的是. 不过, 一般是真正牛B的人会show出其code, 让人信服.&nbsp;</div><div>比如&nbsp;<a href=\"http://my.oschina.net/javayou\" target=\"_blank\" rel=\"nofollow\">@红薯</a>&nbsp;, OSC社区就是最好的证明, 用java写的, 不牛B么? 那些整天吐槽java的人, 除了整天吐槽, 你又有什么证明呢?&nbsp;</div><br><br><br><br>补充说明一下：</div><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">很多人看不懂我下面的讨论，这个错，在我，不在诸位。哈。我承认我的思维是比较怪，谈不上跳跃，因为看似跳跃的东西，我都是有逻辑牵引，只是经常懒得描述这些逻辑本身了。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">此处，通俗的做个总结，或者白话版吧：</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">ACE这种“自适应网络通信”系统，它本身的设计，不属于面向对象的问题。因此使用C++，来设计ACE本身，是一种错误的工程设计方法。如同使 用C++去设计OS一样不靠谱。当然这并不代表基于ACE之上的开发，不能使用面向对象。如同很多APP是面向对象的开发任务，而其是在非面向对象的OS 上运行的。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">&nbsp;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">&nbsp;</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">有一点你说的对，不了解，就没有资格评论。不过ACE虽然我也不了解，只是刚才看了他的主页，但就我的经验判断。这个任务目标使用C++，不形而 上学，就不太可能。使用C++我个人的理解，就是比较容易对理论的验证。如同一个版本，说用C语言，开发网站，我相信可以实现，我也相信能更为高效和体验 一些新的学术思维，但问题是，用C去实现一个其他语言更方便实现的任务。会导致很多研究的重点，恰恰是这个任务如何用C这种形而上学的研究上。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">另一个例子，用C++去重写linux我相信,完全可以.但是和C版本的linux，针对OS本身，没有任何新意，而是为了C++的实现，研究了很多理论。或许什么面向对象的框架在进程管控方面的技术。这就是典型学院派的做风。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">为什么我会直觉的反对，是因为ACE违背了两点工程哲理（工程哲理就是简单的绝不复杂，功能的是模块，数据则可对象）。例如一个排序算法，属于功 能，因此不应该用面向对象处理。而GUI很多是窗口的数据信息，则更应该将数据相关性，融入到面向对象中来解决，使用C语言这种模块化的语言，则天然的给 自己增加障碍。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">因此，ACE，一个是谈的通信，通信属于模块化功能系统，准确说是面向设备，设备是专有功能，客观上并不是面向对象那样，类继承类。因此用C++，说好听点叫“形而上学”说难听点，真的很装B。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">一个是谈自适应。模块的自适应也好，数据的自适应也好。没有那种比散列表更有优势。这不是因为搞这快的人都只懂C而不懂C++。系统的自适应，在 于可适应，好坏在于降低对接本身的成本，而不是在于简便适应的工作。这个不单单是写程序，任何涉及系统的东西，都是如此。例如；汽车轮胎和汽车钢箍，大家 谈的就是直径，和宽度，不会谈轮胎的颜色，纹理。越好的自适应，就是对接的参数越简单，越清楚。此时使用面向对象就拐了很大的弯。如同穿着礼服make love一样。繁衍后代，只需要生殖器，为什么还要皮带套外裤，外裤里面还存在内裤。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">因此，对接则一定会有对接点。采用模块的方式可以最小化（最简单）的描述对接点。而面向对象则相反，是便于对不同系统之间的相互参考的描述。例如 血缘，或者屏幕的窗口。屏幕的窗口，要动，则这个窗口全动，不会这个窗口的某个角落或者某个属性和别的窗口恶意静态的锁定。后者是两个子系统的对接。前者 两个子系统之间相互的参考。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">从这两点的分析来看，一个是面向模块，设备，一个是面向自适应对接，没有任何理由需要使用C++，使用C++只会把东西搞复杂。而使用C，则会如同OS一样，你可以对系统进行模块划分，拆了又拆。而不用追溯老爸的老爸。</p>"
    }
  ]
}
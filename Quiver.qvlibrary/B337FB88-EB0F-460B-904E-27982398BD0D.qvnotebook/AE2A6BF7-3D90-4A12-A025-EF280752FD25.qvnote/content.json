{
  "title": "fork,你知道多少？",
  "cells": [
    {
      "type": "text",
      "data": "<span style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">main()</span><br style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">{</span><br style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\">&nbsp;</span><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><wbr>　int pid;<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;pirntf(\"fork!\\n\");<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;pid = fork();<br><br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;if(pid &lt; 0)<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;{<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;printf(\"fork error!!\\n\");<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;}else if(0 == pid)<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;{<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;printf(\"i am chid process, my process id = %d\\n\",getpid());<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;}else<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;{<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;printf(\"i am parent process, my process id = %d\\n\",getpid());<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;}<br>}<br>当执行这个程序的时候，它的输出是:<br>fork!<br>i am chid process, my process id = 2014<br>i am parent process, my process id = 2002<br><br>为什么会输出两条语句呢？<br><br><font id=\"zoom\" class=\"f14\">要搞清楚fork的执行过程，就必须先讲清楚操作系统中的“进程(process)”概念。一个进程，主要包含三个元素：<br>０一个可以执行的程序；<br>１和该进程相关联的全部数据（包括变量，内存空间，缓冲区等等）；<br>２程序的执行上下文（execution&nbsp;<wbr>context）。<br><br>不妨简单理解为，一个进程表示的，就是一个可执行程序的一次执行过程中的一个状态。操作系统对进程的管理，典型的情况，是通过进程表完成的。进程 表中的每一个表项，记录的是当前操作系统中一个进程的情况。对于单&nbsp;<wbr>CPU的情况而言，每一特定时刻只有一个进程占用&nbsp;<wbr>CPU，但是系统中可能同时存在多 个活动的（等待执行或继续执行的）进程。<br><br>一个称为“程序计数器（program&nbsp;<wbr>counter,&nbsp;<wbr>pc）”的寄存器，指出当前占用&nbsp;<wbr>CPU的进程要执行的下一条指令的位置。<br><br>当分给某个进程的&nbsp;<wbr>CPU时间已经用完，操作系统将该进程相关的寄存器的值，保存到该进程在进程表中对应的表项里面；把将要接替这个进程占用 &nbsp;<wbr>CPU的那个进程的上下文，从进程表中读出，并更新相应的寄存器（这个过程称为“上下文交换(process&nbsp;<wbr>context&nbsp;<wbr>switch)”，实际 的上下文交换需要涉及到更多的数据，那和fork无关，不再多说，主要要记住程序寄存器pc指出程序当前已经执行到哪里，是进程上下文的重要内容，换出CPU的进程要保存这个寄存器的值，换入CPU的进程，也要根据进程表中保存的本进程执行上下文信息，更新这个寄存器。<br><br>好了，有这些概念打底，可以说fork了。当你的程序执行到下面的语句：<br>pid=fork();&nbsp;<wbr><br>操作系统创建一个新的进程（子进程），并且在进程表中相应为它建立一个新的表项。新进程和原有进程的可执行程序是同一个程序；上下文和数据，绝大 部分就是原进程（父进程）的拷贝，但它们是两个相互独立的进程！此时程序寄存器pc，在父、子进程的上下文中都声称，这个进程目前执行到fork调用即将 返回（此时子进程不占有CPU，子进程的pc不是真正保存在寄存器中，而是作为进程上下文保存在进程表中的对应表项内）。问题是怎么返回，在父子进程中就 分道扬镳。<br>&nbsp;<wbr><br></font><font id=\"zoom\" class=\"f14\">fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据 空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，但只有一点不同，如果fork成功，子进程中fork的返回值是0， 父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。 可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了。所以就输出了两个语句！这也是fork为什么叫fork的原因。 至于那一个最先运行，可能与操作系统有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决</font></div>"
    }
  ]
}
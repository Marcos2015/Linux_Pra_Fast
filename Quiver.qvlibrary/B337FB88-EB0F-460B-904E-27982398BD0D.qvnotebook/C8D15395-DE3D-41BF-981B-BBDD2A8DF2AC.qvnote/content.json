{
  "title": "深入解析神奇的vfork（看完就晕了）...",
  "cells": [
    {
      "type": "text",
      "data": "<strong style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">一段神奇的代码</strong><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">在论坛里看到下面一段代码：</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">int createproc();</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">int main()</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">{</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">pid_t pid=createproc();</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">printf(\"%d\\n\", pid);</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">exit(0);</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">}</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">int createproc()</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">{</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">pid_t pid;</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">if(!(pid=vfork())) {</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">printf(\"child proc:%d\\n\", pid);</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">return pid;</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">}</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">else return -1;</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">}</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">输出结果：</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">child proc:0</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">0</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">child proc:0</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">Killed</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">感觉非常奇怪，为什么vfork以后，父子进程都走了“子进程”的分支呢？</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><strong style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">什么是vfork？</strong><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">“写时复制”其实还是有复制，进程的mm结构、页表都还是被复制了（“写时复制”也必须由这些信息来支撑。否则内核捕捉到CPU访存异常，怎么区分这是“写时复制”引起的，还是真正的越权访问呢？）。</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">而 vfork就把事情做绝了，所有有关于内存的东西都不复制了，父子进程的内存是完全共享的。但是这样一来又有问题了，虽然用户程序可以设计很多方法来避免 父子进程间的访存冲突。但是关键的一点，父子进程共用着栈，这可不由用户程序控制的。一个进程进行了关于函数调用或返回的操作，则另一个进程的调用栈（实 际上就是同一个栈）也被影响了。这样的程序没法运行下去。</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">所以，vfork有个限制，子进程生成后，父进程在vfork中被内核挂起，直 到子进程有了自己的内存空间（exec**）或退出(_exit)。并且，在此之前，子进程不能从调用vfork的函数中返回（同时，不能修改栈上变量、 不能继续调用除_exit或exec系列之外的函数，否则父进程的数据可能被改写）。</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><strong style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">问题的思考</strong><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">说到这里，可以看出文章开头的那段代码是存在问题的了。子进程不但调用了printf，还从createproc函数中返回了。</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">但是，子进程的违规为什么会使父进程走上“child proc”这条路呢？父进程在子进程退出前被阻塞在vfork里面，vfork的返回值是如何变成0的呢？</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">前面一直在说vfork，其实它是两个东西，库（libc）函数vfork和系统调用vfork。用户程序调用的是库函数，而库函数再去调用系统调用。用户 程序中几乎所有的系统调用都是通过库函数去调用的。因为不同体系结构下（甚至相同体系结构），系统调用的指令和参数传递规则都可能不同，这些细节被库函数 隐藏了。</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">前面提到，父进程被挂起在vfork中，这是指的系统调用vfork。在系统调用中，进程使用的是内核栈（每个进程有着自己独有 的内核栈）。此时，父进程在内核里面是安全的，随便子进程怎么违规。内核会保证系统调用vfork的完整性，系统调用的返回值也不会有问题（它是通过寄存 器传回用户空间的，跟栈无关）。</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">而vfork的返回值变成0的问题，则是在库函数vfork中产生的。既然子进程已经违规了，库函数没办法保证程 序的正确性。而库函数vfork是否返回0也是不确定的，可能不同版本的libc、不同的程序上下文、不同的系统、等等、都会有不同的返回值（或者就直接 “段错误”了）。还有可能是，父进程中库函数vfork并没有返回0，但是栈上的返回地址被改写了，从函数createproc返回，返回到 printf(\"child proc\")这句话去了。</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><strong style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">再深入一点</strong><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">vfork后，库函数没法保证子进程在进行函数调用或返回的操作后程序还正常，但是库函数vfork本身就是一个函数呀，从系统调用vfork返回后，库函数vfork接着又返回了。这时，程序的正确性又是如何保证的呢？</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">关于函数调用，一般而言：调用前－调用者将需要传递的参数放到栈上；调用时－调用者使用call指令，该指令自动将返回地址入栈；调用后，在被调用的函数中，第一件事是做调用栈的调整，如createproc函数如是做：</span><br style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">08048487&nbsp;</span><createproc style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-family: 宋体, Arial; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">:<br style=\"word-wrap: break-word;\">8048487:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %ebp<br style=\"word-wrap: break-word;\">8048488:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89 e5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %esp,%ebp<br style=\"word-wrap: break-word;\">804848a:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 83 ec 28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sub&nbsp;&nbsp;&nbsp; $0x28,%esp<br style=\"word-wrap: break-word;\">......<br style=\"word-wrap: break-word;\">其中ESP是当前栈的指针，而EBP是上一层调用栈的指针。调用栈调整之前，EBP保存着上上一层栈的指针，这个值不能丢，需要放在栈上，以便函数返回时恢复。<br style=\"word-wrap: break-word;\"><br style=\"word-wrap: break-word;\">每层调用都有自己的调用栈，“深”的调用不会影响到之前的调用栈。所以，vfork后子进程调用其他函数应该是没有问题的（但是可能会改写掉属于父进程的某些数据，造成逻辑上的错误），只要它不从调用vfork的函数中返回就行了。<br style=\"word-wrap: break-word;\">但是，库函数vfork本身却不是这样做的。在这个函数中没有使用栈上的内存空间，它没有去进行调用栈的切换，如：<br style=\"word-wrap: break-word;\">000983f0 &lt;__vfork&gt;:<br style=\"word-wrap: break-word;\">983f0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp; %ecx<br style=\"word-wrap: break-word;\">983f1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 65 8b 15 6c 00 00 00&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %gs:0x6c,%edx<br style=\"word-wrap: break-word;\">983f8:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 89 d0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; %edx,%eax<br style=\"word-wrap: break-word;\">983fa:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f7 d8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; neg&nbsp;&nbsp;&nbsp; %eax<br style=\"word-wrap: break-word;\">......<br style=\"word-wrap: break-word;\">9840e:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cd 80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; $0x80<br style=\"word-wrap: break-word;\">98410:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp; %ecx<br style=\"word-wrap: break-word;\">......<br style=\"word-wrap: break-word;\"><br style=\"word-wrap: break-word;\">所以父进程在库函数中运行时，不用担心栈上的数据已经被子进程修改（它根本不去使用栈上的数据）。<br style=\"word-wrap: break-word;\">然而call/ret指令却不得不使用栈（因为返回地址自动会被CPU放在栈上），如果子进程在vfork后调用其他函数，会使得父进程在进入库函数vfork时通过call指令在栈上留下的“返回地址”被擦掉。<br style=\"word-wrap: break-word;\">事 情的确是这样。于是库函数vfork为了解决这个问题，做了一些手脚，它并没有让栈上的“返回地址”一直留在栈上。注意上面的汇编代码，进入库函数 vfork的第一条指令就是“pop %ecx”，把放在栈上的“返回地址”弹到了ECX中去，保存起来。然后在系统调用vfork返回后（int 0x80是用于系统调用的指令），再“push %ecx”，把“返回地址”放回去。</createproc>"
    }
  ]
}
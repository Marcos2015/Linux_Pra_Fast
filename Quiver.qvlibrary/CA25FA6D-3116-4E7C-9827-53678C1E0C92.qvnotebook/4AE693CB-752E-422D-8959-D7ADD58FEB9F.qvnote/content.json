{
  "title": "Socket基本-TCP粘包问题",
  "cells": [
    {
      "type": "text",
      "data": "<div id=\"meta_content\" class=\"rich_media_meta_list\">\n                                        <span id=\"copyright_logo\" class=\"rich_media_meta meta_original_tag\">原创</span>\n                                                            <em id=\"post-date\" class=\"rich_media_meta rich_media_meta_text\">2017-12-22</em>\n\n                                        <em class=\"rich_media_meta rich_media_meta_text\">王传义</em>\n                                        <a class=\"rich_media_meta rich_media_meta_link rich_media_meta_nickname\" href=\"https://mp.weixin.qq.com/s?__biz=MzA3OTY3OTE1MQ==&amp;mid=2651703405&amp;idx=1&amp;sn=c78770350e7de72d995dfc0b292fc741&amp;scene=21##\" id=\"post-user\">架构说</a>\n                    \n\n                    \n                </div>\n                \n                \n                \n                \n                                                \n                                                                \n                \n                <div class=\"rich_media_content \" id=\"js_content\">\n                    \n\n                    \n\n                    \n                    \n                    <blockquote><p><span style=\"color: rgb(69, 69, 69);\">Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架 提供完整的解决方案 优点很多也就不说了，</span></p><p><span style=\"color: rgb(69, 69, 69);\">但是有个缺点必须要求客户端调用采用thrift框架&nbsp;</span></p><p><span style=\"color: rgb(69, 69, 69);\"><strong>于是开始使用基本socket 来传输数据&nbsp;</strong></span></p><p><br></p><p><span style=\"font-size: 18px;\"><strong><span style=\"font-size: 14px;color: rgb(20, 25, 30);\">一看到涉及底层，有的同学就表示</span></strong></span></p></blockquote><p><br></p><p><br></p><p><br></p><p><img data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/2H3gcc9GEbvfKfTb6Gia8n17JPMAPFbgfA1WFTMIic3wAkUJfMCZSBibNIZb3oywI9J7xiaBLsMnP1DkOoejH27xJQ/0?wx_fmt=png\" style=\"width: auto !important; visibility: visible !important;\" class=\"\" data-ratio=\"1.005181347150259\" data-w=\"193\" src=\"quiver-image-url/2B836FB4210CCA821E9F17C94D0105A7.jpg\" data-fail=\"0\" width=\"193\" height=\"194\"></p><p><br></p><p>现在分析其中一个问题：&nbsp;</p><p><span style=\"font-size: 18pt;color: rgb(173, 0, 0);\">问题1 如何读出socket所有数据&nbsp;</span><span style=\"color: rgb(173, 0, 0);\">&nbsp;(这里阻塞方式 )</span></p><p><br></p><p><span style=\"font-weight: bold;\">方法1&nbsp; 读取数据到固定大小冲区（读取一次）</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 128);font-weight: bold;\">&nbsp;var</span> buffer []<span style=\"color: rgb(0, 0, 128);\">byte</span> = <span style=\"color: rgb(0, 0, 128);\">make</span>([]<span style=\"color: rgb(0, 0, 128);\">byte</span>, <span style=\"color: rgb(128, 0, 128);\">1024</span>)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;outBytes, err := con.Read(buffer)</p><p><span style=\"font-weight: bold;\"><br></span></p><p><span style=\"font-weight: bold;\">缺点</span>：对方发送数据过大 造成解析失败</p><p>日志：</p><p><span style=\"font-size: 14pt;\">&nbsp;2017/12/21 15:12:33 read pack failed&nbsp;&nbsp;runtime error: slice bounds out of range</span></p><p><span style=\"font-size: 14pt;\">没有接受到完整的包</span><br></p><blockquote><p><span style=\"font-size: 12pt;color: rgb(51, 127, 229);\">什么是半包&nbsp;</span></p><p><span style=\"font-size: 12pt;color: rgb(51, 127, 229);\">接受方没有接受到完整的包，只接受了一部分。 由于发送方看到内容太大切分数据包进行发送，</span></p></blockquote><p><br></p><p><span style=\"font-weight: bold;\">涉及问题：</span><span style=\"font-size: 18px;color: rgb(204, 0, 0);font-family: 'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-weight: bold;\">如何确定</span><span style=\"font-size: 18px;color: rgb(69, 69, 69);font-family: 'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-weight: bold;\">接收数据的大小</span></p><p><span style=\"font-size: 18px;color: rgb(69, 69, 69);font-family: 'PingFang SC', 'Microsoft YaHei', SimHei, Arial, SimSun;font-weight: bold;\"><br></span></p><p><br></p><p><span style=\"font-size: 14pt;color: rgb(69, 69, 69);font-family: 'PingFang SC';font-weight: bold;\">方法2：读取数据到动态缓冲区（读取多次）</span></p><p><span style=\"font-size: 14pt;color: rgb(69, 69, 69);font-family: 'PingFang SC';font-weight: bold;\"></span></p><p><br></p><p><img data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/2H3gcc9GEbvfKfTb6Gia8n17JPMAPFbgfrPItzHGYRib6apcyuX4Qr8xK53pfzkRMTGFSqktibLYJjlvayn6e7Yyg/0?wx_fmt=png\" style=\"width: auto !important; visibility: visible !important;\" class=\"\" data-ratio=\"0.3402843601895735\" data-w=\"1055\" src=\"quiver-image-url/E01AE89EB094B2027875890CD876831D.png\" data-fail=\"0\" width=\"640\" height=\"218\"></p><p><span style=\"font-size: 14pt;color: rgb(69, 69, 69);font-family: 'PingFang SC';font-weight: bold;\"></span><br></p><p><br></p><p><span style=\"color: rgb(217, 33, 66);\"><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;\">缺点：</span><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;font-size: 12pt;\">涉及问题： TCP粘包&nbsp;</span></span></p><p><span style=\"font-size: 16px;color: rgb(51, 51, 51);\"><br></span></p><blockquote><p><span style=\"font-size: 16px;color: rgb(51, 51, 51);\">概念：</span><span style=\"font-size: 12pt;color: rgb(51, 51, 51);font-family: Monaco;\">TCP</span></p><p><span style=\"font-size: 12pt;color: rgb(51, 51, 51);\">TCP 协议本身把这些数据块仅仅看成一连串无结构的字节流&nbsp;&nbsp;就是没有界限的一串数据.就像河里的流水,绵延不断，没有分界&nbsp;&nbsp;</span></p><p><span style=\"font-size: 16px;color: rgb(51, 51, 51);\">针对结构化数据如何确定边界呢</span></p></blockquote><p><span style=\"color: rgb(51, 51, 51);\"><br></span></p><p><span style=\"color: rgb(51, 51, 51);\">思考下面几个场景</span></p><p><span style=\"color: rgb(51, 51, 51);\"><br></span></p><p><span style=\"font-size: 14px;box-sizing: border-box;color: rgb(61, 68, 80);\">1: &nbsp;类似 http的请求就不用考虑粘包的问题，因为服务端收到报文后, 就将缓冲区数据接收, 然后关闭连接，这样粘包问题不用考虑到，因为大家都知道是发送一段字符。</span></p><p><span style=\"box-sizing: border-box;color: rgb(61, 68, 80);\">2：如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包</span></p><p><span style=\"font-size: 18px;\"><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;font-size: 14px;color: rgb(61, 68, 80);\">3：</span> <span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;font-size: 11pt;color: rgb(61, 68, 80);\">&nbsp;</span><span style=\"box-sizing: border-box; word-wrap: break-word; word-break: normal; color: rgb(102, 102, 102);\">UDP</span></span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;color: rgb(102, 102, 102);font-family: Baskerville;font-style: italic;font-size: 18px;\">UDP是有边界的，应用层要整包地收，一次只能收一包，每次接收的要么是一个独立的完整的数据包，要么什么也接收不到。</span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;color: rgb(102, 102, 102);font-family: Baskerville;font-style: italic;font-size: 18px;\">TCP是无边界的，是字节流，需要应用层自己判断包边界，一次不一定能收几包，也不一定是完整的包</span></p><p><span style=\"font-size: 12pt;box-sizing: border-box;word-wrap: break-word;word-break: normal;font-weight: bold;color: rgb(63, 63, 63);\"><br></span></p><p><span style=\"font-size: 12pt;box-sizing: border-box;word-wrap: break-word;word-break: normal;font-weight: bold;color: rgb(63, 63, 63);\">粘包情况</span></p><blockquote><p><span style=\"font-size: 12pt;font-weight: bold;\">&nbsp; 每个包数据长度大小不一&nbsp;，每次接受和发送 数据大小不一致 可能导致 包含数据，也可能多，也可能少于实际数据</span></p><p><span style=\"font-size: 12pt;font-weight: bold;\"><br></span></p></blockquote><p><span style=\"border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\"><br></span></p><p><span style=\"border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\">第一种情况，接收端正常收到两个数据包 都是完整的包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。&nbsp;</span></p><p><span style=\"border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\"></span></p><p><br></p><p><img data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/2H3gcc9GEbvfKfTb6Gia8n17JPMAPFbgfbc60pF2RVwP0ONeXwQ0efic1aDbAqicdjpQNv88A7h5iasS1sS6bRNOMw/0?wx_fmt=png\" style=\"width: auto !important; visibility: visible !important;\" class=\"\" data-ratio=\"0.16063675832127353\" data-w=\"691\" src=\"quiver-image-url/C257FBECAF3B5CF2FF3EE48EBEFD0DD3.png\" data-fail=\"0\" width=\"640\" height=\"103\"></p><p><span style=\"border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\"></span><br></p><p><span style=\"border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\">第二种情况（多），接收端只收到一个数据包，由于TCP是不会出现丢包的，</span><span style=\"border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\">所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包</span><span style=\"border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\">。</span></p><p><span style=\"border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\">&nbsp;这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\">&nbsp;</span></p><p><img data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/2H3gcc9GEbvfKfTb6Gia8n17JPMAPFbgf3zLKRo50fvrSYTuM2ibXL5sDeMTMic58VcQQCM9FMoa5OPCpbXnnIvXA/0?wx_fmt=png\" style=\"width: auto !important; visibility: visible !important;\" class=\"\" data-ratio=\"0.16376811594202897\" data-w=\"690\" src=\"quiver-image-url/AF1CE234081709F06A8CED67FAB32180.png\" data-fail=\"0\" width=\"640\" height=\"105\"></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\"></span><br></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\"><br></span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\">第三种情况（少），这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，</span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\">这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\"><br></span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\"></span></p><p><img data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/2H3gcc9GEbvfKfTb6Gia8n17JPMAPFbgfb4esd7rzMeTSia5xeKbZ3ZfiaCxQlXYze1nRT7ibMWT6bItlgq3PFYHiag/0?wx_fmt=png\" style=\"width: auto !important; visibility: visible !important;\" class=\"\" data-ratio=\"0.16521739130434782\" data-w=\"690\" src=\"quiver-image-url/58C9B09FC25C9EA51C174B3B8C7FF43B.png\" data-fail=\"0\" width=\"640\" height=\"106\"></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;border-width: 0px;border-style: initial;border-color: initial;color: rgb(102, 102, 102);\"></span><br></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;color: rgb(63, 63, 63);\">方法3&nbsp;&nbsp;</span><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;color: rgb(47, 47, 47);\">粘包处理原理：读取数据到缓冲区，然后根据协议来解析</span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;color: rgb(85, 85, 85);\">&nbsp;包头+数据的格式 确定边界</span></p><p><img data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/2H3gcc9GEbvfKfTb6Gia8n17JPMAPFbgf3tYVppvkr8hmRK7amHbxKoUP0YGOxInmRPGMMmR29ygqjKgSiawTaicQ/0?wx_fmt=png\" style=\"width: auto !important; visibility: visible !important;\" class=\"\" data-ratio=\"0.14285714285714285\" data-w=\"287\" src=\"quiver-image-url/E92AE3089B47A2692D891692EB92D644.png\" data-fail=\"0\" width=\"287\" height=\"41\"></p><p><br></p><blockquote><p><span style=\"font-size: 12pt;color: rgb(51, 51, 51);\">解包步骤：</span></p><p><span style=\"font-size: 12pt;color: rgb(51, 51, 51);\">1&nbsp; &nbsp;建立一个缓冲去</span></p><p><span style=\"font-size: 12pt;color: rgb(51, 51, 51);\">2&nbsp;&nbsp;&nbsp;读取固定数据到缓冲区</span></p><p><span style=\"font-size: 12pt;color: rgb(51, 51, 51);\">3&nbsp;&nbsp;&nbsp;如果符合一个完整的pack,移走&nbsp;</span></p><p><span style=\"font-size: 12pt;color: rgb(51, 51, 51);\">4&nbsp;&nbsp;&nbsp;如果不符合 ，继续读取 &nbsp;</span></p><p><span style=\"font-size: 12pt;color: rgb(51, 51, 51);\">说明：数据不能错位</span></p></blockquote><p><br></p><p><br></p><p><img data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/2H3gcc9GEbvfKfTb6Gia8n17JPMAPFbgfBvH5u6qgic0Tmrs0tZkibt52cXqVEbAwpz8ZHVoyd0mHUW76HVW9B3bQ/0?wx_fmt=png\" style=\"width: auto !important; visibility: visible !important;\" class=\"\" data-ratio=\"0.7514177693761814\" data-w=\"1058\" src=\"quiver-image-url/BEDB27E5CC993817D045BC3D72BD8431.jpg\" data-fail=\"0\" width=\"640\" height=\"481\"></p><p><br></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;\">方法4&nbsp;&nbsp;</span><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;color: rgb(47, 47, 47);\">粘包处理原理：通过请求头中数据包大小，将客户端N次发送的数据缓冲到一个数据包中</span></p><p><span style=\"font-size: 12pt;color: rgb(69, 69, 69);\">从数据流中读取数据的时候，只要根据包头和数据长度就能取到需要的数据。这个其实就是平时说的协议（protocol）</span></p><p><span style=\"font-size: 12pt;color: rgb(69, 69, 69);\">里面处理这个包的方式之一如下：</span></p><p><span style=\"font-size: 12pt;color: rgb(69, 69, 69);\">1： 一直阻塞读取第一个第二个字节，获取版本号(如果错误就做错误处理)；</span></p><p><span style=\"font-size: 12pt;color: rgb(69, 69, 69);\">2： 然后读取第三、四个字节，获取数据的大小；</span></p><p><span style=\"font-size: 12pt;color: rgb(69, 69, 69);\">3： 然后根据第二步中的数据大小，后面下面的数据；</span></p><p><span style=\"font-size: 12pt;color: rgb(69, 69, 69);\">4： 重复上面的过程；</span></p><p><span style=\"font-size: 12pt;color: rgb(69, 69, 69);\">NSQ就是采取这种方式。</span></p><p>&nbsp;参考例子</p><p>1&nbsp;https://feixiao.github.io/2016/05/08/bufio/</p><p>2&nbsp;&nbsp;http://blog.csdn.net/scythe666/article/details/51996268</p><p><br></p><p><span style=\"font-family: 微软雅黑;font-size: 18pt;color: rgb(255, 76, 0);\">思考：</span></p><p><span style=\"color: rgb(255, 76, 0);\"><span style=\"color: rgb(255, 76, 0);font-family: 微软雅黑;font-size: 18pt;\">&nbsp; 这只是其中一个问题&nbsp;</span><span style=\"color: rgb(255, 76, 0);font-size: 18pt;font-family: 微软雅黑;\">阻塞下read，</span><span style=\"color: rgb(255, 76, 0);font-family: 微软雅黑;font-size: 18pt;\">&nbsp;</span></span></p><p><span style=\"font-size: 18pt;font-family: 微软雅黑;color: rgb(255, 76, 0);\">&nbsp; 非阻塞，同步呢 异步</span></p><p><span style=\"font-family: 微软雅黑;font-size: 18pt;color: rgb(255, 76, 0);\">&nbsp; 正确读写方式是什么</span></p><p><span style=\"font-family: 微软雅黑;font-size: 18pt;color: rgb(255, 76, 0);\"><br></span></p><p><span style=\"font-family: 微软雅黑;font-size: 18pt;color: rgb(255, 76, 0);\"></span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;font-family: 微软雅黑;\">不同语言实现区别：</span></p><p><span style=\"box-sizing: border-box;word-wrap: break-word;word-break: normal;font-family: 微软雅黑;\">&nbsp;read函数说明</span></p><ul class=\"list-paddingleft-2\"><li><p><span style=\"box-sizing: border-box;font-size: 12pt;font-family: 微软雅黑;\">&nbsp;c语言：&nbsp;</span></p></li></ul><p><span style=\"font-size: 14px;color: rgb(51, 51, 51);font-family: 'Hiragino Sans GB', 'Helvetica Neue', 'Microsoft YaHei', Arial, 'WenQuanYi Micro Hei', sans-serif;\">对于阻塞socket，read/write返回-1代表网络出错了。</span></p><p><span style=\"font-size: 14px;color: rgb(51, 51, 51);\">但对于非阻塞socket，read/write返回-1不一定网络真的出错了。</span></p><p><span style=\"font-size: 14px;color: rgb(51, 51, 51);\">可能是Resource temporarily unavailable。</span></p><p><span style=\"font-size: 14px;color: rgb(51, 51, 51);\">这时你应该再试，直到Resource available</span></p><p><span style=\"box-sizing: border-box;word-break: break-all;word-wrap: break-word;color: green;\">综上，对于non-blocking的socket，正确的读写操作为:</span><span style=\"box-sizing: border-box;word-break: break-all;word-wrap: break-word;color: green;\">&nbsp;</span></p><p><span style=\"box-sizing: border-box;word-break: break-all;word-wrap: break-word;color: green;\">读：忽略掉errno = EAGAIN的错误，下次继续读</span><span style=\"box-sizing: border-box;word-break: break-all;word-wrap: break-word;color: green;\">&nbsp;</span></p><p><span style=\"box-sizing: border-box;word-break: break-all;word-wrap: break-word;color: green;\">写：忽略掉errno = EAGAIN的错误，下次继续写</span></p><p><span style=\"color: red;\">对于select和epoll的LT模式，这种读写方式是没有问题的。但对于epoll的ET模式，这种方式还有漏洞。</span></p><p><span style=\"font-size: 15px;background-color: rgb(255, 255, 255);color: rgb(136, 136, 136);\">所以，在epoll的ET模式下，正确的读写方式为:</span><span style=\"font-size: 15px;background-color: rgb(255, 255, 255);color: rgb(136, 136, 136);\">&nbsp;</span></p><p><span style=\"font-size: 15px;color: rgb(136, 136, 136);\">读：只要可读，就一直读，直到返回0，或者 errno = EAGAIN 写:只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN。</span></p><p><br></p><p><img data-s=\"300,640\" data-type=\"png\" data-src=\"http://mmbiz.qpic.cn/mmbiz_png/2H3gcc9GEbvfKfTb6Gia8n17JPMAPFbgfG7MNg6HJ8icExJXiaOlhxqkPBcqjM4yiaw37nicGNtsXiaZFibLRNtBhzjxg/0?wx_fmt=png\" style=\"width: auto !important; visibility: visible !important;\" class=\"\" data-ratio=\"0.6337899543378995\" data-w=\"1095\" src=\"quiver-image-url/403F848F3D565BB7135CF92B4D7F4652.jpg\" data-fail=\"0\" width=\"640\" height=\"406\"></p><ul class=\"list-paddingleft-2\"><li><p><span style=\"color: rgb(255, 0, 0);\">&nbsp;java&nbsp; Netty框架&nbsp;&nbsp;</span><span style=\"box-sizing: border-box;font-size: 12pt;color: rgb(255, 0, 0);\">把数据读取到通道内&nbsp;</span><span style=\"box-sizing: border-box;font-size: 12pt;color: rgb(255, 0, 0);\">通道可以知道数据大小和长度来进行获取</span></p></li><li><p><span style=\"box-sizing: border-box;font-size: 14px;color: rgb(51, 51, 51);\">goroutine底层用的非阻塞+epoll&nbsp;</span> <span style=\"box-sizing: border-box;font-size: 15px;color: rgb(85, 85, 85);\">异步多路复用的机制来</span><span style=\"box-sizing: border-box;font-size: 14px;color: rgb(51, 51, 51);\">&nbsp;</span></p></li></ul></div>"
    }
  ]
}
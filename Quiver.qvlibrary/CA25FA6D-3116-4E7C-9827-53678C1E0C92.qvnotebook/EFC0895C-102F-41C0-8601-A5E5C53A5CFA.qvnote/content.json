{
  "title": "网络IO之阻塞、非阻塞、同步、异步总结",
  "cells": [
    {
      "type": "text",
      "data": "<h1 class=\"postTitle\" style=\"color: rgb(0, 0, 0); font-family: Arial;\"><strong style=\"color: rgb(0, 0, 0); font-size: 14px;\">1、前言</strong><br></h1><div id=\"cnblogs_post_body\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><p>　　在网络编程中，阻塞、非阻塞、同步、异步经常被提到。unix网络编程第一卷第六章专门讨论五种不同的IO模型，Stevens讲的非常详细，我记得去年看第一遍时候，似懂非懂，没有深入理解。网上有详细的分析：<a href=\"http://blog.csdn.net/historyasamirror/article/details/5778378\">http://blog.csdn.net/historyasamirror/article/details/5778378</a>。我结合网上博客和书总结一下，加以区别，加深理解。</p><p><strong>2、数据流向</strong></p><p>　　网络IO操作实际过程涉及到内核和调用这个IO操作的进程。以read为例，read的具体操作分为以下两个部分:</p><p>　　（1）内核等待数据可读</p><p>　　（2）将内核读到的数据拷贝到进程</p><p>详细过程如下图所示：</p><p><img src=\"quiver-image-url/422C804E5B7169E66108FA4C653824E1.png\" alt=\"\" width=\"569\" height=\"405\"></p><p><strong>3、网络IO模型详细分析</strong></p><p>　　常见的IO模型有阻塞、非阻塞、IO多路复用，异步。以一个生动形象的例子来说明这四个概念。周末我和女友去逛街，中午饿了，我们准备去吃饭。周末人多，吃饭需要排队，我和女友有以下几种方案：</p><p>　　（1）我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。</p><p>女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。这就是典型的阻塞。网络中IO阻塞如下图所示：</p><p><img src=\"quiver-image-url/1FB958696E64D3C2DAA665093E0AD1F3.png\" alt=\"\" width=\"541\" height=\"243\"></p><p>　　（2）我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。这就是非阻塞。需要不断的询问，是否准备好了。网络IO非阻塞如下图所示：<img src=\"quiver-image-url/AEC28BF60EFC5CA48AD26A9E6A691AA3.png\" alt=\"\" width=\"481\" height=\"256\"></p><p>　　（3）与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以 了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，这就是典型的IO多路复用，如select、poll、epoll。网络IO具体模型如下图所 示：</p><p><img src=\"quiver-image-url/9DCBABB6B4A5F2ECC8CA69EFD00FF63E.png\" alt=\"\" width=\"497\" height=\"264\"></p><p>　　（4）女友不想逛街，又餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家 里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。linux提供了AIO库函数实现异步，但是用的很少。目前有很 多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：</p><p><img src=\"quiver-image-url/B514D990E207D2FEC21B90CC6479F4A7.png\" alt=\"\" width=\"492\" height=\"250\"></p><p><strong>4、同步与异步</strong></p><p>　　实际上同步与异步是针对应用程序与内核的交互而言的。同步过程中进程触发IO操作并等待或者轮询的去查看IO操作是否完成。异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。同步与异步如下图所示：</p><p><img src=\"quiver-image-url/1BC7B2D4C20A60BF2BEDF43D4685E6AD.png\" alt=\"\" width=\"505\" height=\"305\"></p><p><strong>5、阻塞与非阻塞</strong></p><p>　　简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了，否则就可以理解为非阻塞。详细区别如下图所示：</p><p><img src=\"quiver-image-url/5FA58AC62EB7BBC07049B11F240B448C.png\" alt=\"\" width=\"557\" height=\"231\"></p><p>&nbsp;</p><p>参考资料：</p><p><a href=\"http://www.open-open.com/doc/view/cbb2c3363c3b49ceb5812220a9c42e42\">http://www.open-open.com/doc/view/cbb2c3363c3b49ceb5812220a9c42e42</a></p><p><a href=\"http://blog.csdn.net/historyasamirror/article/details/5778378\">http://blog.csdn.net/historyasamirror/article/details/5778378</a></p><p><a href=\"http://www.zhihu.com/question/19732473\">http://www.zhihu.com/question/19732473</a></p><p><a href=\"http://www.ibm.com/developerworks/cn/linux/l-async/\">http://www.ibm.com/developerworks/cn/linux/l-async/</a></p></div>"
    }
  ]
}
{
  "title": "setsockopt设置缓存区大小",
  "cells": [
    {
      "type": "text",
      "data": "<p> <span style=\"font-size:18px\">在利用tcp/ip进行网络编程的时候，一定会涉及到setsockopt。这个函数可以自定义的设置一些socket的配置。这里记录一下相关配置，</span></p>\n<p><span style=\"font-size:18px\">&nbsp;&nbsp;&nbsp; </span></p>\n<p><strong><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp; 1.</span></strong><span lang=\"EN-US\">closesocket（一般不会立即关闭而经历<span lang=\"EN-US\">TIME_WAIT的过程）后想继续重用该<span lang=\"EN-US\">socket：<span lang=\"EN-US\"><br>\nBOOL bReuseaddr=TRUE;<br>\n<strong>setsockopt</strong>(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)&amp;bReuseaddr,sizeof(BOOL));</span></span></span></span></p>\n<p><span lang=\"EN-US\"><br>\n<strong><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp; 2.</span></strong><span lang=\"EN-US\">&nbsp;如果要已经处于连接状态的<span lang=\"EN-US\">soket在调用<span lang=\"EN-US\">closesocket后强制关闭，不经历<span lang=\"EN-US\"><br>\nTIME_WAIT的过程：<span lang=\"EN-US\"><br>\nBOOL bDontLinger = FALSE;<br>\n<strong>setsockopt</strong>(s,SOL_SOCKET,SO_DONTLINGER,(const char*)&amp;bDontLinger,sizeof(BOOL));</span></span></span></span></span></span></p>\n<p><span lang=\"EN-US\"><br>\n<strong><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp; 3.</span></strong>在<span lang=\"EN-US\">send(),recv()过程中有时由于网络状况等原因，发收不能预期进行<span lang=\"EN-US\">,而设置收发时限：<span lang=\"EN-US\"><br>\nint nNetTimeout=1000;//1秒<span lang=\"EN-US\"><br>\n//发送时限<span lang=\"EN-US\"><br>\n<strong>setsockopt</strong>(socket，<span lang=\"EN-US\">SOL_S0CKET,SO_SNDTIMEO，<span lang=\"EN-US\">(char *)&amp;nNetTimeout,sizeof(int));<br>\n//接收时限<span lang=\"EN-US\"><br>\n<strong>setsockopt</strong>(socket，<span lang=\"EN-US\">SOL_S0CKET,SO_RCVTIMEO，<span lang=\"EN-US\">(char *)&amp;nNetTimeout,sizeof(int));</span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span lang=\"EN-US\"><br>\n<strong><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp; 4.</span></strong>在<span lang=\"EN-US\">send()的时候，返回的是实际发送出去的字节<span lang=\"EN-US\">(同步<span lang=\"EN-US\">)或发送到<span lang=\"EN-US\">socket缓冲区的字节<span lang=\"EN-US\"><br>\n(异步<span lang=\"EN-US\">);系统默认的状态发送和接收一次为<span lang=\"EN-US\">8688字节<span lang=\"EN-US\">(约为<span lang=\"EN-US\">8.5K)；在实际的过程中发送数据<span lang=\"EN-US\"><br>\n和接收数据量比较大，可以设置<span lang=\"EN-US\">socket缓冲区，而避免了<span lang=\"EN-US\">send(),recv()不断的循环收发：<span lang=\"EN-US\"><br>\n//&nbsp;接收缓冲区<span lang=\"EN-US\"><br>\nint nRecvBuf=32*1024;//设置为<span lang=\"EN-US\">32K<br>\n<strong>setsockopt</strong>(s,SOL_SOCKET,SO_RCVBUF,(const char*)&amp;nRecvBuf,sizeof(int));<br>\n//发送缓冲区<span lang=\"EN-US\"><br>\nint nSendBuf=32*1024;//设置为<span lang=\"EN-US\">32K<br>\n<strong>setsockopt</strong>(s,SOL_SOCKET,SO_SNDBUF,(const char*)&amp;nSendBuf,sizeof(int));</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span lang=\"EN-US\"><br>\n<strong><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp; 5.</span></strong><span lang=\"EN-US\">&nbsp;如果在发送数据的时，希望不经历由系统缓冲区到<span lang=\"EN-US\">socket缓冲区的拷贝而影响<span lang=\"EN-US\"><br>\n程序的性能：<span lang=\"EN-US\"><br>\nint nZero=0;<br>\n<strong>setsockopt</strong>(socket，<span lang=\"EN-US\">SOL_S0CKET,SO_SNDBUF，<span lang=\"EN-US\">(char *)&amp;nZero,sizeof(nZero));</span></span></span></span></span></span></span></p>\n<p><span lang=\"EN-US\"><br>\n<strong><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp; 6.</span></strong>同上在<span lang=\"EN-US\">recv()完成上述功能<span lang=\"EN-US\">(默认情况是将<span lang=\"EN-US\">socket缓冲区的内容拷贝到系统缓冲区<span lang=\"EN-US\">)：<span lang=\"EN-US\"><br>\nint nZero=0;<br>\n<strong>setsockopt</strong>(socket，<span lang=\"EN-US\">SOL_S0CKET,SO_RCVBUF，<span lang=\"EN-US\">(char *)&amp;nZero,sizeof(int));</span></span></span></span></span></span></span></span></p>\n<p><span lang=\"EN-US\"><br>\n<strong><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp; 7.</span></strong>一般在发送<span lang=\"EN-US\">UDP数据报的时候，希望该<span lang=\"EN-US\">socket发送的数据具有广播特性：<span lang=\"EN-US\"><br>\nBOOL bBroadcast=TRUE;<br>\n<strong>setsockopt</strong>(s,SOL_SOCKET,SO_BROADCAST,(const char*)&amp;bBroadcast,sizeof(BOOL));</span></span></span></span></p>\n<p><span lang=\"EN-US\"><br>\n<strong><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp; 8.</span></strong>在<span lang=\"EN-US\">client连接服务器过程中，如果处于非阻塞模式下的<span lang=\"EN-US\">socket在<span lang=\"EN-US\">connect()的过程中可<span lang=\"EN-US\"><br>\n以设置<span lang=\"EN-US\">connect()延时<span lang=\"EN-US\">,直到<span lang=\"EN-US\">accpet()被呼叫<span lang=\"EN-US\">(本函数设置只有在非阻塞的过程中有显著的<span lang=\"EN-US\"><br>\n作用，在阻塞的函数调用中作用不大<span lang=\"EN-US\">)<br>\nBOOL bConditionalAccept=TRUE;<br>\n<strong>setsockopt</strong>(s,SOL_SOCKET,SO_CONDITIONAL_ACCEPT,(const char*)&amp;bConditionalAccept,sizeof(BOOL));</span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span lang=\"EN-US\"><br>\n<strong><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp; 9</span></strong><span lang=\"EN-US\">.如果在发送数据的过程中<span lang=\"EN-US\">(send()没有完成，还有数据没发送<span lang=\"EN-US\">)而调用了<span lang=\"EN-US\">closesocket(),以前我们<span lang=\"EN-US\"><br>\n一般采取的措施是<span lang=\"EN-US\">\"从容关闭<span lang=\"EN-US\">\"shutdown(s,SD_BOTH),但是数据是肯定丢失了，如何设置让程序满足具体<span lang=\"EN-US\"><br>\n应用的要求<span lang=\"EN-US\">(即让没发完的数据发送出去后在关闭<span lang=\"EN-US\">socket)？<span lang=\"EN-US\"><br>\nstruct linger {<br>\nu_short l_onoff;<br>\nu_short l_linger;<br>\n};<br>\nlinger m_sLinger;<br>\nm_sLinger.l_onoff=1;//(在<span lang=\"EN-US\">closesocket()调用<span lang=\"EN-US\">,但是还有数据没发送完毕的时候容许逗留<span lang=\"EN-US\">)<br>\n//&nbsp;如果<span lang=\"EN-US\">m_sLinger.l_onoff=0;则功能和<span lang=\"EN-US\">2.)作用相同<span lang=\"EN-US\">;<br>\nm_sLinger.l_linger=5;//(容许逗留的时间为<span lang=\"EN-US\">5秒<span lang=\"EN-US\">)<br>\n<strong>setsockopt</strong>(s,SOL_SOCKET,SO_LINGER,(const char*)&amp;m_sLinger,sizeof(linger));\n<br>\n</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p><span lang=\"EN-US\">&nbsp;&nbsp;&nbsp;\n 根据上述配置可以配置发送缓存区和接受缓存区大小。但是设置后的真实缓存区大小是多少呢？<br>\n</span></p>\n<div><font size=\"3\"><span style=\"font-family:微软雅黑; color:#0800\"><span style=\"color:#4D6DF3\">&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr><span style=\"color:#FF0000\"><span style=\"background-color:rgb(255,255,255)\">（1）当设置的值val &gt; 最大值sysctl_wmem_max，则设置为</span></span></span><span style=\"color:#FF0000\"><span style=\"background-color:rgb(255,255,255)\">最大值的2倍：2*sysctl_wmem_max；</span></span></span></font></div>\n<div><span style=\"color:#FF0000\"><span style=\"background-color:rgb(255,255,255)\"><span style=\"font-size:14px\"><span style=\"font-family:微软雅黑\">&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>（2）当设置的值的两倍val*2&nbsp;<wbr>&lt;最小值，则设置成最小值：SOCK_MIN_SNDBUF；</span></span></span></span></div>\n<div><span style=\"color:#FF0000\"><span style=\"background-color:rgb(255,255,255)\"><span style=\"font-size:14px\"><span style=\"font-family:微软雅黑\">&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>（3）当设置的值val &lt; 最大值sysctl_wmem_max，且 val*2&gt;&nbsp;<wbr>SOCK_MIN_SNDBUF， 则设置成2*val。<br>\n</span></span></span></span><span style=\"color:#FF0000\"><span style=\"background-color:rgb(255,255,255)\"></span></span><span style=\"color:#FF0000\"><span style=\"background-color:rgb(255,255,255)\"><span style=\"font-size:14px\"><span style=\"font-family:微软雅黑\"></span></span></span></span>\n<p style=\"text-indent:2em\"><span style=\"font-size:14px\"><span style=\"font-family: 宋体;\">存放接收缓冲区最大值的位置：</span><span style=\"font-family:宋体\">/proc/sys/net/core/rmem_max：</span></span></p>\n<span style=\"color:#FF0000\"><span style=\"background-color:rgb(255,255,255)\"><span style=\"font-size:14px\"><span style=\"font-family:微软雅黑\"></span></span></span></span>\n<div><span style=\"font-family:宋体\"><span style=\"font-size:14px\">&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>结果：4194304&nbsp;<wbr>&nbsp;<wbr>//4M</span></span></div>\n<div><span style=\"font-size:14px\"><span style=\"font-family:宋体\">&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>存放发送缓冲区最大值的位置：</span><span style=\"font-family:宋体\">/proc/sys/net/core/wmem_max：</span></span></div>\n<div><span style=\"font-family:宋体\"><span style=\"font-size:14px\">&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>结果：8388608&nbsp;<wbr> //8M</span></span></div>\n<br>\n</div>\n&nbsp;&nbsp; 做一个简单的测试：\n<p></p>\n<p><span lang=\"EN-US\"><img src=\"quiver-image-url/67C19AC9BD764C8BD876B5826615F6AE.png\" alt=\"\" width=\"752\" height=\"424\"><br>\n</span></p>\n<p><span lang=\"EN-US\">讲缓冲区大小设为1024*100那么结果应该是它的2倍即204800，结果如图：</span><br>\n<span style=\"font-size:18px\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><span lang=\"EN-US\"><img src=\"quiver-image-url/90F40788949EDF7573D19A3B1C05C807.png\" alt=\"\" width=\"464\" height=\"39\"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>"
    }
  ]
}
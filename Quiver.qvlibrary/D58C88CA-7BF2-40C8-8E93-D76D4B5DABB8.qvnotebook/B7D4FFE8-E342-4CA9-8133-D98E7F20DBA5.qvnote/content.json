{
  "title": "编译器如何将高级语言转化成汇编语言的？",
  "cells": [
    {
      "type": "text",
      "data": "<embed id=\"xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd\" type=\"application/thunder_download_plugin\" height=\"0\" width=\"0\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><article class=\"article-content\" style=\"font-size: 15px; line-height: 26px; text-indent: 30px; word-break: break-all; word-wrap: break-word; position: relative; padding: 10px 20px 20px; color: rgb(85, 85, 85); font-family: 'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif;\"><p style=\"margin: 0px 0px 15px;\">对于每天奋斗在一线，用Java，C++，C#，Python等高级编程语言写程序的程序员们来说，理解编译器是如何将高级语言编译成汇编语言，有助于我们更好的理解计算机编程。</p><p style=\"margin: 0px 0px 15px;\">编译器将高级语言转化成汇编语言主要经过三个步骤：词法分析、语法分析、语法树解析。</p><p style=\"margin: 0px 0px 15px;\">本文用简洁易懂的方式描述了这一过程，相信不需要很深的计算机背景知识，也能轻松读懂本文。</p><h2 style=\"margin: 20px -20px 20px -24px; line-height: 18px; color: inherit; text-rendering: optimizeLegibility; font-size: 18px; padding: 10px 20px 9px 10px; border-left-width: 4px; border-left-style: solid; border-left-color: rgb(0, 166, 124); background-color: rgb(251, 251, 251);\">第一步：词法分析</h2><p style=\"margin: 0px 0px 15px;\">最开始的时候，高级语言编写的程序对编译器来说只是一连串的单个字符组成的字符串。为了让编译器识别这一连串的字符串，需要逐个字符的读取源程序，然后将其切分成有意义的单词，这些被切分后的单词在编译器眼里是以</p><p style=\"margin: 0px 0px 15px;\">&lt;标识，语义值&gt;对的形式存在。</p><p style=\"margin: 0px 0px 15px;\">为了从源程序字符串中依次找出单词，编译器需要具有扫描功能，通常这种扫描器可以用一组有限状态机来实现。为了说明有限状态机是怎么一回事，下面给出一个实例。</p><p style=\"margin: 0px 0px 15px;\">下图为一个识别数字的有限状态机，数字由整数部分和可选的小数部分组成。因此，根据这个有限状态机，250和3.14159都能被识别成一个有效的数字。</p><p style=\"margin: 0px 0px 15px;\"><img class=\"aligncenter\" src=\"quiver-image-url/51B97DF3C47A181D088D48AE4D7FCABB.jpg\" alt=\"\" width=\"292\" height=\"112\" style=\"vertical-align: middle; border: 0px; margin: 0px auto; display: block; text-align: center;\"></p><p style=\"margin: 0px 0px 15px; text-align: center;\">图一：有限状态机</p><p style=\"margin: 0px 0px 15px;\">绿色的结点用环形标志，表示他们是“可接受”的状态，也就是说，只要我们的状态达到了绿色的结点，就表示我们之前读取到的数据是一个有效的数字。例如，从图中的start处开始，如果我们读到的数字是42.15，那么依次经历的状态是（1,2,2,3,3,3），由于这一系列状态最终以“可接受”的状态结束(也就是图中的状态3)，因此我们就读取到了一个有效的数字。而且读取到的数字42.15用&lt;标识，值&gt;对的形式表示成&lt;NUMBER,42.15&gt;。这里的NUMBER是用于标识我们读取到的内容是一个数字，而文本“42.15”是标识对应的语义元素值。</p><p style=\"margin: 0px 0px 15px;\">我们可以用为不同类型的单词定义不同的类似上述的小状态机，例如变量名可以由字母、下划线组成，操作符可以取+=、-&gt;，关键字则可以是“if”“while”等单词，类型则可以是“int”“char”等等单词。为每一类单词构造一个小的有限状态机，最终组成一个可以接受不同类型单词的大状态机。可以用表的形式存放我们得到的大状态机。至此，我们通过构造一个大状态机得到一个能识别各类单词的自动扫描器。</p><p style=\"margin: 0px 0px 15px;\">至此，第一步大功告成，这一步我们通常称之为“语法分析”阶段。</p><p style=\"margin: 0px 0px 15px;\">高级源程序通过语法分析后，我们得到的结果是&lt;标识，值&gt;对，以方便后续处理。</p><p style=\"margin: 0px 0px 15px;\">为方便理解，这里举个简单的例子。</p><p style=\"margin: 0px 0px 15px;\">比如，我们程序语句：</p><p style=\"margin: 0px 0px 15px;\"><span id=\"__w2_R5DQRHN_toggle_link\">if ( x == 2 ) { x = a + b; }</span></p><p style=\"margin: 0px 0px 15px;\">通过词法分析后，得到&lt;标识，值&gt;对如下：</p><p style=\"margin: 0px 0px 15px;\"><span id=\"__w2_R5DQRHN_toggle_link\">(KEYWORD,”if”), (IDENTIFIER,”x”), (OPERATOR,”==”), (NUMBER,”2″), (DELIMITER, “{“), (IDENTIFIER,”x”), (OPERATOR,”=”), (IDENTIFIER,”a”), (OPERATOR,”+”), (IDENTIFIER,”b”), (DELIMITER,”;”), (DELIMITER,”}”).</span></p><h2 style=\"margin: 20px -20px 20px -24px; line-height: 18px; color: inherit; text-rendering: optimizeLegibility; font-size: 18px; padding: 10px 20px 9px 10px; border-left-width: 4px; border-left-style: solid; border-left-color: rgb(0, 166, 124); background-color: rgb(251, 251, 251);\">第二步：语法分析</h2><p style=\"margin: 0px 0px 15px;\">完成了“词法分析”后，接下来就是激动人心的“语法分析”阶段。通过语法分析得到语法树。</p><p style=\"margin: 0px 0px 15px;\">例如，对于第一步中的程序语句<span id=\"__w2_R5DQRHN_toggle_link\">if ( x == 2 ) { x = a + b; }</span>。我们得到的语法树如下图所示。</p><p style=\"margin: 0px 0px 15px;\"><img class=\"aligncenter\" src=\"quiver-image-url/48188030A1FEFAAC6990CFEC164D7634.jpg\" alt=\"\" width=\"363\" height=\"198\" style=\"vertical-align: middle; border: 0px; margin: 0px auto; display: block; text-align: center;\"></p><p style=\"margin: 0px 0px 15px; text-align: center;\">图2：语法树</p><p style=\"margin: 0px 0px 15px;\">生成语法树的方法有很多，这里只介绍一种最简单的方法：预测分析法（predictive parsing）。具体做法是：从数据流的一端开始扫描，用占位符为所有之前没遇到的元素创建一个临时语法树，然后依次读取后续的数据来填充完这颗语法树。(听起来可能很抽象，请看下面的实例)</p><p style=\"margin: 0px 0px 15px;\">对于图2的语法树，具体生成过程如下：</p><p style=\"margin: 0px 0px 15px;\"><img class=\"aligncenter\" src=\"quiver-image-url/A2493505FEBE3BA580AADCA8DCA59C97.jpg\" alt=\"\" width=\"300\" height=\"305\" style=\"vertical-align: middle; border: 0px; margin: 0px auto; display: block; text-align: center;\"></p><p style=\"margin: 0px 0px 15px; text-align: center;\">图3：语法树生成实例</p><p style=\"margin: 0px 0px 15px;\">后续的statement部分可以同理生成，这里略去。</p><h2 style=\"margin: 20px -20px 20px -24px; line-height: 18px; color: inherit; text-rendering: optimizeLegibility; font-size: 18px; padding: 10px 20px 9px 10px; border-left-width: 4px; border-left-style: solid; border-left-color: rgb(0, 166, 124); background-color: rgb(251, 251, 251);\">第三步：翻译语法树</h2><p style=\"margin: 0px 0px 15px;\">有了语法树后，我们接下来要做的事情是构建符号表，以便确定各个元素在存储器中的存放位置。</p><p style=\"margin: 0px 0px 15px;\">具体做法：遍历语法树，将语法树中<strong>不同</strong>的变量依次取出，放入可用的存储位置。编译器自己决定如何分配存储位置 。</p><p style=\"margin: 0px 0px 15px;\">具体过程可以用下图表描述：</p><p style=\"margin: 0px 0px 15px;\"><img class=\"aligncenter\" src=\"quiver-image-url/E4FE1D64C0E074D8DA0A6A50D3FCB05D.jpg\" alt=\"\" width=\"360\" height=\"255\" style=\"vertical-align: middle; border: 0px; margin: 0px auto; display: block; text-align: center;\"></p><p style=\"margin: 0px 0px 15px; text-align: center;\">图4：为变量分配存储地址</p><p style=\"margin: 0px 0px 15px;\">语法树中多次出现的变量指向同一地址。从上到下，从左往右依次遍历语法树，遇到一个if结点，执行if相关的操作，遇到赋值结点，执行赋值相关的操作，详细步骤如下所示：</p><p style=\"margin: 0px 0px 15px;\"><strong>首先，寻找最小表达式，如下图中绿色、蓝色圈中的即为一个最小表达式。</strong></p><p style=\"margin: 0px 0px 15px;\"><img class=\"aligncenter\" src=\"quiver-image-url/9D9F749C8E34F37E83C9D9A0274761DF.jpg\" alt=\"\" width=\"225\" height=\"135\" style=\"vertical-align: middle; border: 0px; margin: 0px auto; display: block; text-align: center;\"></p><p style=\"margin: 0px 0px 15px; text-align: center;\">图5：寻找最小表达式</p><p style=\"margin: 0px 0px 15px;\"><strong>接下来，将最小表达式与其周边的表达式合并。</strong></p><p style=\"margin: 0px 0px 15px;\"><img class=\"aligncenter\" src=\"quiver-image-url/29CD6E445B3528020FCBC28C8191B10E.jpg\" alt=\"\" width=\"300\" height=\"213\" style=\"vertical-align: middle; border: 0px; margin: 0px auto; display: block; text-align: center;\"></p><p style=\"margin: 0px 0px 15px; text-align: center;\">图6：表达式合并</p><p style=\"margin: 0px 0px 15px;\"><strong>最后，将所有的表达式有序的进行合并，得到最终的汇编语言描述，如图7所示。</strong></p><p style=\"margin: 0px 0px 15px;\"><img class=\"aligncenter\" src=\"quiver-image-url/F2843EF598ACAA57F5D300824B8FC84B.jpg\" alt=\"\" width=\"300\" height=\"304\" style=\"vertical-align: middle; border: 0px; margin: 0px auto; display: block; text-align: center;\"></p><p style=\"margin: 0px 0px 15px; text-align: center;\">图7：最终生成的汇编语言</p><p style=\"margin: 0px 0px 15px;\">至此，我们便将高级语言翻译成了汇编语言。</p><p style=\"margin: 0px 0px 15px;\">（水平有限，文章翻译如有错误，望不吝赐教，谢谢！）</p><p style=\"margin: 0px 0px 15px;\">来源：Quora</p><p style=\"margin: 0px 0px 15px;\">本文链接：<a href=\"http://www.cricode.com/3132.html\" target=\"_blank\" data-original-title=\"\" title=\"\" style=\"color: rgb(0, 166, 124); text-decoration: none;\">http://www.cricode.com/3132.html</a></p><p style=\"margin: 0px 0px 15px;\">译者：<a href=\"http://www.cricode.com/\" target=\"_blank\" data-original-title=\"\" title=\"\" style=\"color: rgb(0, 166, 124); text-decoration: none;\">快课网-Jay13</a></p><p style=\"margin: 0px 0px 15px;\">转载请注明：<a href=\"http://www.cricode.com/\" data-original-title=\"\" title=\"\" style=\"color: rgb(0, 166, 124); text-decoration: none;\">快课网</a>&nbsp;»&nbsp;<a href=\"http://www.cricode.com/3132.html\" data-original-title=\"\" title=\"\" style=\"color: rgb(0, 166, 124); text-decoration: none;\">编译器如何将高级语言转化成汇编语言的？</a></p></article>"
    }
  ]
}
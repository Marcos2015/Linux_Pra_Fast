{
  "title": "详解僵尸状态(EXIT_ZOMBLE)",
  "cells": [
    {
      "type": "text",
      "data": "<h1 style=\"color: rgb(0, 0, 0); font-family: Arial; margin: 0px; padding: 0px; line-height: 26px;\">1. 产生原因：<br></h1><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\">进程运行结束，父进程尚未使用wait函数族等来收尸，即等待父进程销毁它。那么他将变成一个僵尸进程。通过ps命令查看其带有defunct的标志。僵尸进程是一个早已死亡的进程，但在进程表(processs table)中仍占了一个位置(slot)。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\">但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程，看看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由Init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而Init进程会自动wait其子进程，因此被Init接管的所有进程都不会变成僵尸进程。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\"><br></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\"></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\">在Linux进程的状态中，僵尸进程是非常特殊的一种，它是已经结束了的进程，但是没有从进程表中删除。太多了会导致进程表里面条目满了，进而导致系统崩溃，倒是不占用其他系统资源。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\">它<span style=\"color: rgb(255, 0, 0);\">已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，</span>记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\">进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。<span style=\"color: rgb(255, 0, 0);\">于是进程就只剩下task_struct这么个空壳，故称为僵尸。</span></p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\">之所以保留task_struct，是因为task_struct里面保存了进程的<span style=\"color: rgb(255, 0, 0);\">退出码</span>、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。&nbsp;<br>当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\">子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。 父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。</p><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\">这个信号默认是<span style=\"color: rgb(255, 0, 0);\">SIGCHLD</span>，但是在通过clone系统调用创建子进程时，可以设置这个信号。</p><br style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;\"><h1 style=\"color: rgb(0, 0, 0); font-family: Arial; margin: 0px; padding: 0px; line-height: 26px;\"><a name=\"t1\" style=\"color: rgb(255, 153, 0);\"></a>2. 原理分析：</h1><p style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 0px; padding: 0px; line-height: 26px;\"></p><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;\"><br></div><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;\">　　每个Unix进程在进程表里都有一个<span style=\"color: rgb(255, 0, 0);\">进入点</span>(entry)，核心进程执 行该进程时使用到的一切信息都存储在进入点。当用 ps 命令察看系统中的进程信息时，看到的就是进程表中的相关数据。当以fork()系统调用建立一个新的进程后，核心进程就会在进程表中给这个新进程分配一个 进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。</div><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;\"><br></div><div style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;\">　　子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。那么会不会因为父进程太忙来不及 wait 子进程，或者说不知道子进程什么时候结束，而丢失子进程结束时的状态信息呢？不会。因为UNIX提供了一种机制可以保证，只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是：当子进程走完了自己的生命周期后，它会执行exit()系统调用，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息(包括进程号the process ID，退出码exit code，退出状态the terminationstatus of the process，运行时间the amount of CPU time taken by the process等)，这些数据会一直保留到系统将它传递给它的父进程为止，直到父进程通过wait / waitpid来取时才释放。<br><br><h1 style=\"margin: 0px; padding: 0px;\"><a name=\"t2\" style=\"color: rgb(255, 153, 0);\"></a>3.解决方法：</h1><br>(1) 父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。<div><br></div><div>　执行wait()或waitpid()系统调用，则子进程在终止后会立即把它在进程表中的数据返回给父进程，此时系统会<span style=\"color: rgb(255, 0, 0);\">立即删除该进入点</span>。在这种情形下就不会产生defunct进程。</div><div>(2)&nbsp;<span style=\"color: rgb(255, 0, 0);\">如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler</span>。在子进程结束后，父进程会收到该信号，可以在handler中调用wait回收。</div><div><br></div><div>(3) 如果父进程不关心子进程什么时候结束，那么可以用signal(SIGCLD, SIG_IGN)或signal(SIGCHLD, SIG_IGN)通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，<span style=\"color: rgb(255, 0, 0);\">内核会回收，</span>并不再给父进程发送信号</div><div><br></div><div>(4)fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。</div><a href=\"http://www.lupaworld.com/home.php?mod=spacecp&amp;ac=click&amp;op=add&amp;clickid=1&amp;idtype=aid&amp;id=216737&amp;hash=7455bb9a4951e8b8bf8e6986cd453efa&amp;handlekey=clickhandle\" id=\"click_aid_216737_1\" style=\"color: rgb(255, 153, 0); text-decoration: none;\"></a><p style=\"margin: 0px; padding: 0px;\">（5）把父进程杀掉。</p><p style=\"margin: 0px; padding: 0px;\">父进程死后，僵尸进程成为\"孤儿进程\"，过继给1号进程init，init始终会负责清理僵尸进程．它产生的所有僵尸进程也跟着消失。如：</p><p style=\"margin: 0px; padding: 0px;\">kill -9 `ps -ef | grep \"Process Name\" | awk '{ print $3 }'`&nbsp;<br>其中，“Process Name”为处于zombie状态的进程名。</p><p style=\"margin: 0px; padding: 0px;\">(linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命：&nbsp;<br>1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）；&nbsp;<br>2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作；)</p></div>"
    }
  ]
}
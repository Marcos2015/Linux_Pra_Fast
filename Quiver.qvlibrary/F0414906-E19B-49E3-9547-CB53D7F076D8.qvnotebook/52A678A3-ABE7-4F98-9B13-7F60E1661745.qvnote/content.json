{
  "title": "C++ 多线程编程总结",
  "cells": [
    {
      "type": "text",
      "data": "<embed id=\"xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd\" type=\"application/thunder_download_plugin\" height=\"0\" width=\"0\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">在开发C++程序时，一般在吞吐量、并发、实时性上有较高的要求。设计C++程序时，总结起来可以从如下几点提高效率：</span><ul style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><li>并发</li><li>异步</li><li>缓存</li></ul><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">下面将我平常工作中遇到一些问题例举一二，其设计思想无非以上三点。</p><h2 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; line-height: 25px;\">1任务队列</h2><h3 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; line-height: 25px;\">1.1&nbsp;&nbsp;&nbsp; 以生产者-消费者模型设计任务队列</h3><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;生产者-消费者模型是人们非常熟悉的模型，比如在某个服务器程序中，当User数据被逻辑模块修改后，就产生一个更新数据库的任务（produce），投递给IO模块任务队列，IO模块从任务队列中取出任务执行sql操作（consume）。</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><span id=\"more-5605\"></span><br>设计通用的任务队列，示例代码如下：</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">详细实现可参见：</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><a href=\"http://ffown.googlecode.com/svn/trunk/fflib/include/detail/task_queue_impl.h\" style=\"text-decoration: none;\"><font color=\"#0066cc\">http://ffown.googlecode.com/svn/trunk/fflib/include/detail/task_queue_impl.h</font></a></p><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>void task_queue_t::produce(const task_t&amp; task_) {\n        lock_guard_t lock(m_mutex);\n        if (m_tasklist-&gt;empty()){//! 条件满足唤醒等待线程\n            m_cond.signal();\n        }\n        m_tasklist-&gt;push_back(task_);\n    }\nint   task_queue_t::comsume(task_t&amp; task_){\n        lock_guard_t lock(m_mutex);\n        while (m_tasklist-&gt;empty())//! 当没有作业时，就等待直到条件满足被唤醒{\n            if (false == m_flag){\n                return -1;\n            }\n            m_cond.wait();\n        }\n        task_ = m_tasklist-&gt;front();\n        m_tasklist-&gt;pop_front();\n        return 0;\n}</pre></div><h3 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; line-height: 25px;\">1.2&nbsp;&nbsp;&nbsp; 任务队列使用技巧</h3><h4 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">1.2.1 IO 与 逻辑分离</h4><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;比如网络游戏服务器程序中，网络模块收到消息包，投递给逻辑层后立即返回，继续接受下一个消息包。逻辑线程在一个没有io操作的环境下运行，以保障实时性。示例：</p><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>void handle_xx_msg(long uid, const xx_msg_t&amp; msg){\n    logic_task_queue-&gt;post(boost::bind(&amp;servie_t::proces, uid, msg));\n}</pre></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;注意，此模式下为单任务队列，每个任务队列单线程。</p><h4 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">1.2.2&nbsp; 并行流水线</h4><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;上面的只是完成了io 和 cpu运算的并行，而cpu中逻辑操作是串行的。在某些场合，cpu逻辑运算部分也可实现并行，如游戏中用户A种菜和B种菜两种操作是完全可以并行的，因为两个操作没有共享数据。最简单的方式是A、B相关的操作被分配到不同的任务队列中。示例如下：</p><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>void handle_xx_msg(long uid, const xx_msg_t&amp; msg) {\n　　logic_task_queue_array[uid % sizeof(logic_task_queue_array)]-&gt;post(\n　　　　boost::bind(&amp;servie_t::proces, uid, msg));\n}</pre></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;注意，此模式下为多任务队列，每个任务队列单线程。</p><h4 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">1.2.3 连接池与异步回调</h4><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;比如逻辑Service模块需要数据库模块异步载入用户数据，并做后续处理计算。而数据库模块拥有一个固定连接数的连接池，当执行SQL的任务到来时，选择一个空闲的连接，执行SQL，并把SQL 通过回调函数传递给逻辑层。其步骤如下：</p><ul style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><li>预先分配好线程池，每个线程创建一个连接到数据库的连接</li><li>为数据库模块创建一个任务队列，所有线程都是这个任务队列的消费者</li><li>逻辑层想数据库模块投递sql执行任务，同时传递一个回调函数来接受sql执行结果</li></ul><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">示例如下：</p><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>void db_t:load(long uid_, boost::function&lt;void (user_data_t&amp;) func_){\n    //! sql execute, construct user_data_t user\n    func_(user)\n}\nvoid process_user_data_loaded(user_data_t&amp;){\n    //! todo something\n}\ndb_task_queue-&gt;post(boost::bind(&amp;db_t:load, uid, func));</pre></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">注意，此模式下为单任务队列，每个任务队列多线程。</p><h2 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; line-height: 25px;\">2. 日志</h2><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;本文主要讲C++多线程编程，日志系统不是为了提高程序效率，但是在程序调试、运行期排错上，日志是无可替代的工具，相信开发后台程序的朋友都会使用日志。常见的日志使用方式有如下几种：</p><ul style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><li>流式，如logstream &lt;&lt; “start servie time[%d]” &lt;&lt; time(0) &lt;&lt; ” app name[%s]” &lt;&lt; app_string.c_str() &lt;&lt; endl;</li><li>Printf 格式如：logtrace(LOG_MODULE, “start servie time[%d] app name[%s]“, time(0), app_string.c_str());</li></ul><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">二者各有优缺点，流式是线程安全的，printf格式格式化字符串会更直接，但缺点是线程不安全，如果把app_string.c_str() 换成app_string （std::string），编译被通过，但是运行期会crash（如果运气好每次都crash，运气不好偶尔会crash）。我个人钟爱printf风格，可以做如下改进：</p><ul style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><li>增加线程安全，利用C++模板的traits机制，可以实现线程安全。示例：</li></ul><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>template&lt;typename ARG1&gt;\nvoid logtrace(const char* module, const char* fmt, ARG1 arg1){\n    boost::format s(fmt);\n    f % arg1;\n}</pre></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;这样，除了标准类型+std::string 传入其他类型将编译不能通过。这里只列举了一个参数的例子，可以重载该版本支持更多参数，如果你愿意，可以支持9个参数或更多。</p><ul style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><li>为日志增加颜色，在printf中加入控制字符，可以再屏幕终端上显示颜色，Linux下示例：printf(“33[32;49;1m [DONE] 33[39;49;0m\")</li></ul><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">更多颜色方案参见：</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><a href=\"http://hi.baidu.com/jiemnij/blog/item/d95df8c28ac2815cb219a80e.html\" style=\"text-decoration: none;\"><font color=\"#0066cc\">http://hi.baidu.com/jiemnij/blog/item/d95df8c28ac2815cb219a80e.html</font></a></p><ul style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><li>每个线程启动时，都应该用日志打印该线程负责什么功能。这样，程序跑起来的时候通过top -H - p pid 可以得知那个功能使用cpu的多少。实际上，我的每行日志都会打印线程id，此线程id非pthread_id，而其实是线程对应的系统分配的进程id号。</li></ul><h2 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; line-height: 25px;\">3. 性能监控</h2><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;尽管已经有很多工具可以分析c++程序运行性能，但是其大部分还是运行在程序debug阶段。我们需要一种手段在debug和release阶段都能监控程序，一方面得知程序瓶颈之所在，一方面尽早发现哪些组件在运行期出现了异常。</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;通常都是使用gettimeofday 来计算某个函数开销，可以精确到微妙。可以利用C++的确定性析构，非常方便的实现获取函数开销的小工具,示例如下：</p><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>struct profiler{\n    profiler(const char* func_name){\n        gettimeofday(&amp;tv, NULL);\n    }\n    ~profiler(){\n        struct timeval tv2;\n        gettimeofday(&amp;tv2, NULL);\n        long cost = (tv.tv_sec - tv.tv_sec) * 1000000 + (tv.tv_usec - tv.tv_usec);\n        //! post to some manager\n    }\n    struct timeval tv;\n};\n#define PROFILER() profiler(__FUNCTION__)</pre></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;Cost 应该被投递到性能统计管理器中，该管理器定时讲性能统计数据输出到文件中。</p><h2 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; line-height: 25px;\">4 Lambda 编程</h2><h3 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;使用foreach 代替迭代器</h3><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;很多编程语言已经内建了foreach，但是c++还没有。所以建议自己在需要遍历容器的地方编写foreach函数。习惯函数式编程的人应该会非常钟情使用foreach，使用foreach的好处多多少少有些，如：</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><a href=\"http://www.cnblogs.com/chsword/archive/2007/09/28/910011.html\" style=\"text-decoration: none;\"><font color=\"#0066cc\">http://www.cnblogs.com/chsword/archive/2007/09/28/910011.html</font></a></p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;但主要是编程哲学上层面的。</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">示例：</p><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>void user_mgr_t::foreach(boost::function&lt;void (user_t&amp;)&gt; func_){\n    for (iterator it = m_users.begin(); it != m_users.end() ++it){\n        func_(it-&gt;second);\n    }\n}</pre></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;比如要实现dump 接口，不需要重写关于迭代器的代码</p><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>void user_mgr_t:dump(){\n    struct lambda {\n        static void print(user_t&amp; user){\n            //! print(tostring(user);\n        }\n    };\n    this-&gt;foreach(lambda::print);\n}</pre></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;实际上，上面的代码变通的生成了匿名函数，如果是c++ 11 标准的编译器，本可以写的更简洁一些：</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;this-&gt;foreach([](user_t&amp; user) {} );</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;但是我大部分时间编写的程序都要运行在centos 上，你知道吗它的gcc版本是gcc 4.1.2， 所以大部分时间我都是用变通的方式使用lambda函数。</p><h4 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">Lambda 函数结合任务队列实现异步</h4><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;常见的使用任务队列实现异步的代码如下：</p><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>void service_t:async_update_user(long uid){\n    task_queue-&gt;post(boost::bind(&amp;service_t:sync_update_user_impl, this, uid));\n}\nvoid service_t:sync_update_user_impl(long uid){\n    user_t&amp; user = get_user(uid);\n    user.update()\n}</pre></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;这样做的缺点是，一个接口要响应的写两遍函数，如果一个函数的参数变了，那么另一个参数也要跟着改动。并且代码也不是很美观。使用lambda可以让异步看起来更直观，仿佛就是在接口函数中立刻完成一样。示例代码：</p><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>void service_t:async_update_user(long uid){\n    struct lambda {\n        static void update_user_impl(service_t* servie, long uid){\n            user_t&amp; user = servie-&gt;get_user(uid);\n            user.update();\n        }\n    };\n    task_queue-&gt;post(boost::bind(&amp;lambda:update_user_impl, this, uid));\n}</pre></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;这样当要改动该接口时，直接在该接口内修改代码，非常直观。</p><h2 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; line-height: 25px;\">5. 奇技淫巧</h2><h3 style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; line-height: 25px;\">&nbsp; &nbsp; &nbsp; 利用shared_ptr 实现map/reduce</h3><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">Map/reduce的语义是先将任务划分为多个任务，投递到多个worker中并发执行，其产生的结果经reduce汇总后生成最终的结果。Shared_ptr的语义是什么呢？当最后一个shared_ptr析构时，将会调用托管对象的析构函数。语义和map/reduce过程非常相近。我们只需自己实现讲请求划分多个任务即可。示例过程如下：</p><ul style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><li>定义请求托管对象，加入我们需要在10个文件中搜索“oh nice”字符串出现的次数，定义托管结构体如下：</li></ul><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>struct reducer{\n    void set_result(int index, long result) {\n        m_result[index] = result;\n    }\n    ~reducer(){\n        long total = 0;\n        for (int i = 0; i &lt; sizeof(m_result); ++i){\n            total += m_result[i];\n        }\n        //! post total to somewhere\n    }\n    long m_result[10];\n};</pre></div><ul style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><li>定义执行任务的 worker</li></ul><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>void worker_t:exe(int index_, shared_ptr&lt;reducer&gt; ret) {\n　　ret-&gt;set_result(index, 100);\n}</pre></div><ul style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><li>将任务分割后，投递给不同的worker</li></ul><div class=\"cnblogs_Highlighter\" style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><pre>shared_ptr&lt;reducer&gt; ret(new reducer());\nfor (int i = 0; i &lt; 10; ++i)\n{\n    task_queue[i]-&gt;post(boost::bind(&amp;worker_t:exe, i, ret));\n}</pre></div><div style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><ins class=\"adsbygoogle\" data-ad-client=\"ca-pub-2206192680127944\" data-ad-slot=\"1471313689\" data-adsbygoogle-status=\"done\" style=\"display: inline-block; width: 728px; height: 90px;\"></ins></div>"
    }
  ]
}
{
  "title": "linux下多线程的创建与等待详解",
  "cells": [
    {
      "type": "text",
      "data": "<embed id=\"xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd\" type=\"application/thunder_download_plugin\" height=\"0\" width=\"0\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><span style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">所有线程都有一个线程号，也就是Thread ID。其类型为pthread_t。通过调用pthread_self()函数可以获得自身的线程号。</span><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">下面说一下如何创建一个线程。<br>通过创建线程，线程将会执行一个线程函数，该线程格式必须按照下面来声明：<br>void * Thread_Function(void *)<br>创建线程的函数如下：</p><div style=\"color: rgb(0, 0, 0); line-height: 25px; border: 1px solid black; padding-right: 3px; padding-left: 3px; font-size: 12px; margin-left: auto; margin-right: auto; padding-top: 3px; font-family: 'Courier New'; background-color: window;\"><span style=\"font-family: 微软雅黑;\"><span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;pthread_create(pthread_t&nbsp;<span style=\"color: rgb(51, 51, 153);\">*</span>restrict thread,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>const</strong></span>&nbsp;pthread_attr_t&nbsp;<span style=\"color: rgb(51, 51, 153);\">*</span>restrict attr,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>void</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">*</span>(<span style=\"color: rgb(51, 51, 153);\">*</span>start_routine)(<span style=\"color: rgb(0, 0, 255);\"><strong>void</strong></span><span style=\"color: rgb(51, 51, 153);\">*</span>),&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>void</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">*</span>restrict arg);</span></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">下面说明一下各个参数的含义：<br>thread：所创建的线程号。<br>attr：所创建的线程属性，这个将在后面详细说明。<br>start_routine：即将运行的线程函数。<br>art：传递给线程函数的参数。<br>下面是一个简单的创建线程例子：</p><div style=\"color: rgb(0, 0, 0); line-height: 25px; border: 1px solid black; padding-right: 3px; padding-left: 3px; font-size: 12px; margin-left: auto; margin-right: auto; padding-top: 3px; font-family: 'Courier New'; background-color: window;\"><span style=\"font-family: 微软雅黑;\">#<font face=\"微软雅黑\"><span style=\"color: rgb(0, 0, 255);\"><strong>include</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">&lt;</span>pthread.h<span style=\"color: rgb(51, 51, 153);\">&gt;</span><br>#<span style=\"color: rgb(0, 0, 255);\"><strong>include</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">&lt;</span>stdio.h<span style=\"color: rgb(51, 51, 153);\">&gt;</span><br><span style=\"color: rgb(0, 128, 0);\">/* Prints x’s to stderr. The parameter is unused. Does not return. */</span><br><span style=\"color: rgb(0, 0, 255);\"><strong>void</strong></span><span style=\"color: rgb(51, 51, 153);\">*</span>&nbsp;print_xs (<span style=\"color: rgb(0, 0, 255);\"><strong>void</strong></span><span style=\"color: rgb(51, 51, 153);\">*</span>&nbsp;unused)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>while</strong></span>&nbsp;(<span style=\"color: rgb(110, 0, 170);\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;fputc (‘x’, stderr);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>return</strong></span>&nbsp;NULL;<br>}<br><span style=\"color: rgb(0, 128, 0);\">/* The main program. */</span><br><span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;main ()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t thread_id;<br>&nbsp;&nbsp;&nbsp;&nbsp;</font></span><span style=\"font-family: 微软雅黑;\"><span style=\"color: rgb(0, 128, 0);\">/* Create a new thread. The new thread will run the print_xs<br>&nbsp;&nbsp;&nbsp;&nbsp;function. */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create (<span style=\"color: rgb(51, 51, 153);\">&amp;</span>thread_id, NULL,&nbsp;<span style=\"color: rgb(51, 51, 153);\">&amp;</span>print_xs, NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 128, 0);\">/* Print o’s continuously to stderr. */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>while</strong></span>&nbsp;(<span style=\"color: rgb(110, 0, 170);\">1</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;fputc (‘o’, stderr);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>return</strong></span>&nbsp;<span style=\"color: rgb(110, 0, 170);\">0</span>;<br>}</span></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">在编译的时候需要注意，由于线程创建函数在libpthread.so库中，所以在编译命令中需要将该库导入。命令如下：<br>gcc -o createthread -lpthread createthread.c<br>如果想传递参数给线程函数，可以通过其参数arg，其类型是void *。如果你需要传递多个参数的话，可以考虑将这些参数组成一个结构体来传递。另外，由于类型是void *，所以你的参数不可以被提前释放掉。<br>下面一个问题和前面创建线程类似，不过带来的问题回避进程要严重得多。如果你的主线程，也就是main函数执行的那个线程，在你其他线程推出之前就已经退出，那么带来的bug则不可估量。通过pthread_join函数会让主线程阻塞，直到所有线程都已经退出。</p><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">pthread_join:使一个线程等待另一个线程结束。<br>代码中如果没有pthread_join主线程会很快结束从而使整个进程结束，从而使创建的线程没有机会开始执行就结束了。加入pthread_join后，主线程会一直等待直到等待的线程结束自己才结束，使创建的线程有机会执行。</p><div style=\"color: rgb(0, 0, 0); line-height: 25px; border: 1px solid black; padding-right: 3px; padding-left: 3px; font-size: 12px; margin-left: auto; margin-right: auto; padding-top: 3px; font-family: 'Courier New'; background-color: window;\"><span style=\"font-family: 微软雅黑;\"><span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;pthread_join(pthread_t thread,&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>void</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">*</span><span style=\"color: rgb(51, 51, 153);\">*</span>value_ptr);</span></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">thread：等待退出线程的线程号。<br>value_ptr：退出线程的返回值。<br>下面一个例子结合上面的内容：</p><div style=\"color: rgb(0, 0, 0); line-height: 25px; border: 1px solid black; padding-right: 3px; padding-left: 3px; font-size: 12px; margin-left: auto; margin-right: auto; padding-top: 3px; font-family: 'Courier New'; background-color: window;\"><span style=\"font-family: 微软雅黑;\"><span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;main ()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t thread1_id;<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t thread2_id;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>struct</strong></span>&nbsp;char_print_parms thread1_args;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>struct</strong></span>&nbsp;char_print_parms thread2_args;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 128, 0);\">/* Create a new thread to print 30,000 x’s. */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;thread1_args.character&nbsp;<span style=\"color: rgb(51, 51, 153);\">=</span>&nbsp;’x’;<br>&nbsp;&nbsp;&nbsp;&nbsp;thread1_args.count&nbsp;<span style=\"color: rgb(51, 51, 153);\">=</span>&nbsp;<span style=\"color: rgb(110, 0, 170);\">30000</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create (<span style=\"color: rgb(51, 51, 153);\">&amp;</span>thread1_id, NULL,&nbsp;<span style=\"color: rgb(51, 51, 153);\">&amp;</span>char_print,&nbsp;<span style=\"color: rgb(51, 51, 153);\">&amp;</span>thread1_args);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 128, 0);\">/* Create a new thread to print 20,000 o’s. */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;thread2_args.character&nbsp;<span style=\"color: rgb(51, 51, 153);\">=</span>&nbsp;’o’;<br>&nbsp;&nbsp;&nbsp;&nbsp;thread2_args.count&nbsp;<span style=\"color: rgb(51, 51, 153);\">=</span>&nbsp;<span style=\"color: rgb(110, 0, 170);\">20000</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create (<span style=\"color: rgb(51, 51, 153);\">&amp;</span>thread2_id, NULL,&nbsp;<span style=\"color: rgb(51, 51, 153);\">&amp;</span>char_print,&nbsp;<span style=\"color: rgb(51, 51, 153);\">&amp;</span>thread2_args);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 128, 0);\">/* Make sure the first thread has finished. */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join (thread1_id, NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 128, 0);\">/* Make sure the second thread has finished. */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_join (thread2_id, NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 128, 0);\">/* Now we can safely return. */</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>return</strong></span>&nbsp;<span style=\"color: rgb(110, 0, 170);\">0</span>;<br>}</span></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">下面说一下前面提到的线程属性。<br>在我们前面提到，可以通过pthread_join()函数来使主线程阻塞等待其他线程退 出，这样主线程可以清理其他线程的环境。但是还有一些线程，更喜欢自己来清理退出的状态，他们也不愿意主线程调用pthread_join来等待他们。我 们将这一类线程的属性称为detached。如果我们在调用pthread_create()函数的时候将属性设置为NULL，则表明我们希望所创建的线 程采用默认的属性，也就是jionable。如果需要将属性设置为detached，则参考下面的例子：</p><div style=\"color: rgb(0, 0, 0); line-height: 25px; border: 1px solid black; padding-right: 3px; padding-left: 3px; font-size: 12px; margin-left: auto; margin-right: auto; padding-top: 3px; font-family: 'Courier New'; background-color: window;\"><span style=\"font-family: 微软雅黑;\">#<font face=\"微软雅黑\"><span style=\"color: rgb(0, 0, 255);\"><strong>include</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">&lt;</span>stdio.h<span style=\"color: rgb(51, 51, 153);\">&gt;</span><br>#<span style=\"color: rgb(0, 0, 255);\"><strong>include</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">&lt;</span>pthread.h<span style=\"color: rgb(51, 51, 153);\">&gt;</span><br><span style=\"color: rgb(0, 0, 255);\"><strong>void</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">*</span>&nbsp;start_run(<span style=\"color: rgb(0, 0, 255);\"><strong>void</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">*</span>&nbsp;arg)<br>{<br><span style=\"color: rgb(0, 128, 0);\">//do some work</span><br>}<br><span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_t thread_id;<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_t attr;<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_init(<span style=\"color: rgb(51, 51, 153);\">&amp;</span>attr);<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_setdetachstate(<span style=\"color: rgb(51, 51, 153);\">&amp;</span>attr,PTHREAD_CREATE_DETACHED);<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(<span style=\"color: rgb(51, 51, 153);\">&amp;</span>thread_id,<span style=\"color: rgb(51, 51, 153);\">&amp;</span>attr,start_run,NULL);<br>&nbsp;&nbsp;&nbsp;&nbsp;pthread_attr_destroy(<span style=\"color: rgb(51, 51, 153);\">&amp;</span>attr);<br>&nbsp;&nbsp;&nbsp;&nbsp;sleep(<span style=\"color: rgb(110, 0, 170);\">5</span>);<br>&nbsp;&nbsp;&nbsp;&nbsp;exit(<span style=\"color: rgb(110, 0, 170);\">0</span>);<br>}</font></span></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">在线程设置为joinable后，可以调用pthread_detach()使之成为detached。但是相反的操作则不可以。还有，如果线程已经调用pthread_join()后，则再调用pthread_detach()则不会有任何效果。<br>线程可以通过自身执行结束来结束，也可以通过调用pthread_exit()来结束线程的执行。另外，线程甲可以被线程乙被动结束。这个通过调用pthread_cancel()来达到目的。</p><div style=\"color: rgb(0, 0, 0); line-height: 25px; border: 1px solid black; padding-right: 3px; padding-left: 3px; font-size: 12px; margin-left: auto; margin-right: auto; padding-top: 3px; font-family: 'Courier New'; background-color: window;\"><span style=\"font-family: 微软雅黑;\"><span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;pthread_cancel(pthread_t thread);</span></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">函数调用成功返回0。<br>当然，线程也不是被动的被别人结束。它可以通过设置自身的属性来决定如何结束。<br>线程的被动结束分为两种，一种是异步终结，另外一种是同步终结。异步终结就是当其他线程调用 pthread_cancel的时候，线程就立刻被结束。而同步终结则不会立刻终结，它会继续运行，直到到达下一个结束点（cancellation point）。当一个线程被按照默认的创建方式创建，那么它的属性是同步终结。<br>通过调用pthread_setcanceltype()来设置终结状态。</p><div style=\"color: rgb(0, 0, 0); line-height: 25px; border: 1px solid black; padding-right: 3px; padding-left: 3px; font-size: 12px; margin-left: auto; margin-right: auto; padding-top: 3px; font-family: 'Courier New'; background-color: window;\"><span style=\"font-family: 微软雅黑;\"><span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;pthread_setcanceltype(<span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;type,&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">*</span>oldtype);</span></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">state：要设置的状态，可以为PTHREAD_CANCEL_DEFERRED或者为PTHREAD_CANCEL_ASYNCHRONOUS。<br>那么前面提到的结束点又是如何设置了？最常用的创建终结点就是调用pthread_testcancel()的地方。该函数除了检查同步终结时的状态，其他什么也不做。<br>上面一个函数是用来设置终结状态的。还可以通过下面的函数来设置终结类型，即该线程可不可以被终结：</p><div style=\"color: rgb(0, 0, 0); line-height: 25px; border: 1px solid black; padding-right: 3px; padding-left: 3px; font-size: 12px; margin-left: auto; margin-right: auto; padding-top: 3px; font-family: 'Courier New'; background-color: window;\"><span style=\"font-family: 微软雅黑;\"><span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;pthread_setcancelstate(<span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;state,&nbsp;<span style=\"color: rgb(0, 0, 255);\"><strong>int</strong></span>&nbsp;<span style=\"color: rgb(51, 51, 153);\">*</span>oldstate);</span></div><p style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\">state：终结状态，可以为PTHREAD_CANCEL_DISABLE或者PTHREAD_CANCEL_ENABLE。具体什么含义大家可以通过单词意思即可明白。<br>最后说一下线程的本质。其实在Linux中，新建的线程并不是在原先的进程中，而是系统通过 一个系统调用clone()。该系统copy了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。 copy后的进程和原先的进程共享了所有的变量，运行环境。这样，原先进程中的变量变动在copy后的进程中便能体现出来。</p><div style=\"color: rgb(0, 0, 0); font-family: 'Microsoft Yahei', 'Helvetica Neue', 'Luxi Sans', 'DejaVu Sans', Tahoma, 'Hiragino Sans GB', STHeiti; font-size: 16px; line-height: 25px;\"><ins class=\"adsbygoogle\" data-ad-client=\"ca-pub-2206192680127944\" data-ad-slot=\"1471313689\" data-adsbygoogle-status=\"done\" style=\"display: inline-block; width: 728px; height: 90px;\"></ins></div>"
    }
  ]
}
{
  "title": "把-128的最高位符号位1 丢弃了",
  "cells": [
    {
      "type": "text",
      "data": "<div style=\"color: rgb(0, 0, 0); line-height: 1.7; font-size: 14px; font-family: Arial;\"><div class=\"content-head clearfix\" style=\"zoom: 1;\"><h2 class=\"title content-title\" style=\"margin: 0px 0px 10px; padding: 0px; font-size: 20px; font-family: tahoma, helvetica, 'microsoft yahei', arial; color: rgb(58, 58, 58); font-weight: normal; float: left;\">char的类型为什么是－128～127</h2></div><div id=\"content\" class=\"content mod-cs-content text-content clearfix\" style=\"zoom: 1; width: 758px; overflow: hidden; line-height: 1.5; margin: 7px 0px 10px;\"><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><b>转自：（<a href=\"http://blog.csdn.net/daiyutage/article/details/8575248\">http://blog.csdn.net/daiyutage/article/details/8575248</a>）</b></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong><br></strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>在C语言中， signed char 类型的范围为-128~127,每本教科书上也这么写，但是没有哪一本书上（包括老师）也不会给你为什么是-128~127，这个问题貌似看起来也很简单容易， 以至于不用去思考为什么，不是有一个整型范围的公式吗：&nbsp; -2^(n-1)~2^(n-1)-1&nbsp;&nbsp; n为整型的内存占用位数，所以int类型32位 那么就是 -(2^31)~2^31 -1 即</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp; -2147483648~2147483647,但是为什么最小负数绝对值总比最大正数多1 ，这个问题甚至有的工作几年的程序员都模棱两可，因为没有深入思考过，只知道书上这么写。。于是，我不得不深入思考一下这个被许多人忽视的问题。。</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp; 对于无符号整数，很简单，全部位都表示数值，比如 char型，8位，用二进制表示为0000 0000 ~ 1111 1111</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp; 1111 1111 最大即为十进制255,所以 unsigned char 的范围为0~ 255，在这里普及一下2进制转十进制的方法， 二进制每一位的数值乘以它的位权(2^(n-1),n为自右向左的位),再相加，可得到十进制数，比如 ：</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><strong><span style=\"font-size: 18px;\">1</span><span style=\"font-size: 18px;\">111 1111 =1*2^7+1*2^6+1*2^5+1*2^4+1*2^3+1*2^2+1*2^1+1*2^0=127&nbsp; 。</span></strong></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><strong><span style=\"font-size: 18px;\">&nbsp;&nbsp;<span style=\"color: rgb(255, 102, 0);\">&nbsp;但是对于有符号整数，二进制的最高位表示正负</span>，不表示数值，<span style=\"color: rgb(255, 102, 0);\">最高位为0时表示正数，为1时表示负数</span>，这样一来，能表示数值的就剩下(n-1)位了，比如 char&nbsp;a= -1;&nbsp;&nbsp;&nbsp;那么二进制表示就为&nbsp;1 0000001,&nbsp; 1 表示为0 0000001 ,所以signed char 型除去符号位剩下的7位最大为1111 111 =127，</span><span style=\"font-size: 18px;\">再把符号加上，0 1111111=127 ，1 1111111= -127，范围应该为 -127~127 ，同理int类型也一样，但是问题出来了，教科书上是-128~127 啊，下面就剖析一下这个惊人的奇葩。。。</span></strong></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp; 再普及一下计算机内部整数存储形式，大家都知道计算机内部是以二进制来存贮数值的，<span style=\"color: rgb(255, 102, 0);\">无符号整数会用全部为来存</span><span style=\"color: rgb(255, 102, 0);\">储</span>，有符号的整数，最高位当做符号位 ，其余为表示数值，这样貌似合理， 却带来一个麻烦，当进行加法时，1+1</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;0000 0001</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>+&nbsp;&nbsp;&nbsp;&nbsp; 0000 0001</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>—————————</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0000&nbsp;&nbsp;0010 &nbsp;&nbsp; ………………2&nbsp;</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>当相减时 1-1=?&nbsp; 由于计算机只会加法不会减法，它会转化为1+(-1) ,因此</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000 0001</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>+&nbsp;&nbsp;&nbsp; 1000 0001</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><strong>____________________</strong></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 18px;\">&nbsp;1000&nbsp;0010&nbsp;&nbsp;&nbsp;&nbsp; …………… -2&nbsp;&nbsp;&nbsp; ，1-1= -2?&nbsp; 这显然是不对了，所以为了避免减法运算错误，计算机大神们发明出了反码，</span><span style=\"font-size: 18px;\">直接用最高位表示符号位的叫做原码， 上面提到的二进制都是原码形式，<span style=\"color: rgb(255, 102, 0);\">反码是原码除最高位其余位取反</span>，规定：<span style=\"color: rgb(255, 0, 0);\">正数的反码和原码相同，负数的反码是原码除了符号位，其余为都取反</span>，因此</span><span style=\"font-size: 18px;\">-1 的源码为 1 0000001 ，反码为 1 1111110, 现在再用反码来计算 1+(-1)</span></strong></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0000 0001</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>+&nbsp;&nbsp;&nbsp; 1111 1110</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>————————</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …………再转化为原码就是 1000 0000 = -0&nbsp; ，虽然反码解决了相减的问题，却又带来一个问题，-0 ，既然0000 0000 表示 0，那么就没有 -0 的必要， 出现 +0= -0=0 ，一个0 就够了，为了避免两个0的问题，计算机大师们又发明了补码，补码规定： 整数的补码是其本身，负数的补码为其反码加一 ，所以，<span style=\"color: rgb(255, 0, 0);\">负数转化为反码需两个步</span><span style=\"color: rgb(255, 0, 0);\">骤， 第一，先转化为反码，第二： 把反码加一</span>。。这样 -1 的补码为 1111 1111&nbsp;&nbsp;&nbsp; ，1+(-1)</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; 0000 0001</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>+&nbsp;&nbsp; 1111 1111</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>________________</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;1 &nbsp;0000 0000&nbsp; ……………………&nbsp; 这里变成了9位，由于char 为8位，最高位1 被丢弃 结果为0 ，运算正确</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"></span><strong>&nbsp;</strong></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><strong><span style=\"font-size: 18px;\">&nbsp;&nbsp;再看， -0 ：原码 1000 0000 的补码为1 0000 0000 ，由于char 是 八位 ，所以取低八位00000000,&nbsp;&nbsp; +0 ：原码为0000 00000</span><span style=\"font-size: 18px;\">&nbsp;，补码为也为 0000 0000 ，虽然补码0都是相同的，但是有两个0 ，既然有两个0 ，况且0既不是正数，也不是负数，&nbsp;用原码为0000 0000 表示就行了，</span><span style=\"font-size: 18px;\">&nbsp;这样一来，有符号的char&nbsp;,原码都用来表示-127~127 之间的数了，唯独剩下原码1000 0000 没有用，用排列组合也可以算出来，0？？？？？？？，能表示2^7=128个数，刚好是0~127, 1???????,也能表示128个数，总共signed char 有256 个数，这与-127~127 中间是两个0 刚好吻合。。现在再来探讨一下关于剩下的那个1000 0000，</span></strong></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>既然-127 ~0~ 127都有相应的原码与其对应，那么1000 0000 表示什么呢，当然是-128了，为什么是-128呢，网上有人说-0即</strong></span><span style=\"font-size: 18px;\"><strong>1000 0000 与128的补码相同，所以用1000 0000表示-128,，这我实在是不敢苟同，或者说-128没有原码，只有补码1000 0000,胡扯，既然没有原码何来补码，还有说-128的原码与-0(1000 0000)的原码相同，所以可以用1000 0000表示-128，</strong></span><span style=\"font-size: 18px;\"><strong>我只能说，回答的不要那么牵强， 原码1000 0000 与-128的原码实际上是不同的， 但为什么能用它表示-128进行运算，</strong></span><span style=\"font-size: 18px;\"><strong>如果不要限制为char 型（即不要限定是8位），再来看，-128的原码：1 1000 0000 ，9位，最高位符号位，再算它的反码：</strong></span><span style=\"font-size: 18px;\"><strong>1 0111 1111，进而，补码为：&nbsp;<span style=\"color: rgb(255, 0, 0);\">1 1000 0000,这是-128的补码</span>，发现和原码一样, 1 1000 0000和1000 0000 相同?如果说一样的人真是瞎了眼了，所以，-128的原码和-0(1000 000)的原码是不同的，但是在char 型中，是可以用1000 000 表示-128的，关键在于char 是8位，<span style=\"color: rgb(255, 0, 0);\">它把-128的最高位符号位1 丢弃了</span>，截断后-128的原码为1000 000 和-0的原码相同，也就是说</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong><span style=\"color: rgb(255, 0, 0);\">1000 0000&nbsp; 和-128丢弃最高位后余下的8位相同，所以才可以用-0 表示-128</span>，这样，当初剩余的-0(1000 0000)，被拿来表示截断后的-128,<span style=\"color: rgb(255, 0, 0);\">因为即使截断后的-128和char 型范围的其他数(-127~127)运算也不会影响结果</span>， 所以才敢这么表示-128。</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp; 比如 -128+(-1)</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; 1000 0000&nbsp; ------------------丢弃最高位的-128</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><strong>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 18px;\">1111&nbsp;&nbsp;1111&nbsp;&nbsp; -----------------&nbsp;&nbsp; -1</span></strong></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>________________</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;10111&nbsp; 1111&nbsp;&nbsp;&nbsp; ------------------char 取八位，这样结果不正确，不过没关系 ，结果-129本来就超出char型了，当然不能表示了。</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp; 比如 -128+127</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; 1000 0000</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;+ 0111 1111</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>————————</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; 1111 1111 --------------&nbsp; -1 结果正确， 所以，这就是为什么能用 1000 0000表示-128的原因。</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp; 从而也是为什么char 是-128~127，而不是-127~127 ，short int 同样如此 -32768~32767&nbsp; 因为在16位中，-32768为原码为17位，丢弃最高位剩下的16为- 0 的原码相同。。。。</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; 还有一个问题：</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; 既然-128最高位丢弃了。那么</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; char a=-128;&nbsp; //在内存中以补码1 1000 0000 存储，但由于是char ,所以只存储 1000 0000</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; printf(\"%d\",a); //既然最高位丢弃了，输出时应该是1000 000 的原码的十进制数-0 ，但为什么能输出-128呢。</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><strong><span style=\"font-size: 18px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还能打印出-128；</span></strong></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; 我猜想是计算机内部的一个约定，就像float一样 ，能用23位表示24位的精度 ，因为最高位默认为1，到时候把23位取出再加 1便可。</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp; -128也是同样的原理，当数据总线从内存中取出的是1000 000 ，CPU会给它再添最高一位，变为1 1000 0000 这样才能转化为</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp; -128输出，不然1000 0000 如何输出？这当然是我的一种推断，具体怎么实现还得问CPU的设计者了。。。。</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; 再看一个例子：</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char a=-129;</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(\"%d\",a)&nbsp; ;&nbsp;&nbsp;&nbsp; 会输入多少？？&nbsp;&nbsp;&nbsp; 结果为127 ，为什么呢？&nbsp;</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -129在补码为10 0111 1111 只取后八位存储，即 0111 111 这个值刚好是127了，同理-130 截断后为126.....</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>如此按模轮回，关于模就先不探讨了。。</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; char a=&nbsp; -1;</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; if( 1&gt;a)&nbsp;&nbsp; printf(\"大于\");</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(\"小于\");</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 结果是什么呢？&nbsp; 出人意料的是：&nbsp; 小于，而不是大于，猫腻在你哪呢，还是存储问题：</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp; a为unsigned 无符号， 它的八位都用来存储数值， 没有符号位，编译器把 -1 转换为补码为 1111 1111,但由于是无符号，计算机会把 1111 11111 当做是无符号来对待 ，自然就是 2^8 -1&nbsp; = 255 了，所以相当于是if( 1&gt;255) 肯定是</strong></span></p><p style=\"margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px;\"><span style=\"font-size: 18px;\"><strong>&nbsp;printf(\"小于\");了</strong></span></p><div><span style=\"font-size: 18px;\"><strong><br></strong></span></div></div></div><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><br style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span title=\"neteasefooter\" style=\"color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px;\"><span id=\"netease_mail_footer\"><div id=\"netease_mail_footer\"><div style=\"border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); padding: 10px 5px; color: rgb(102, 102, 102); line-height: 22px;\">来自网易手机号码邮箱<a id=\"mobile_set\" sys=\"1\" log=\"1\" logid=\"free_sms_20120504\" href=\"http://shouji.163.com/\" target=\"_blank\" style=\"color: rgb(0, 0, 255);\">了解更多</a></div></div></span></span>"
    }
  ]
}
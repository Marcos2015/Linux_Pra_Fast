{
  "title": "Unix编程/应用问答中文版",
  "cells": [
    {
      "type": "text",
      "data": "<pre style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: 微软雅黑, 宋体, 黑体, Arial, Helvetica, sans-serif; white-space: pre-wrap; word-wrap: break-word; color: rgb(47, 47, 47); font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">名称 -- Unix编程/应用问答中文版\n版本 -- 0.04 ( 2003-10-09 外发版 )\n维护 -- 小四 &lt;scz@nsfocus.com&gt;\n主页 -- http://www.nsfocus.com\n创建 -- 2001-02-05 13:49\n更新 -- 2003-10-08 10:13\n感谢 --\n感谢C语言的发明者、Unix操作系统的发明者、感谢全世界C程序员创造的Unix共\n享传统文化圈，她是如此强大、充满禁忌、而又魅力四射。\n感谢deepin &lt;deepin@nsfocus.com&gt;，在整个维护过程中的支持、帮助和鼓励。\n感谢所有NSFOCUS安全研究小组(security@nsfocus.com)的朋友。\n主要支持人员(字母顺序) --\nAndrew Gierth   &lt;andrew@erlenstar.demon.co.uk&gt;\nbackend         &lt;backend@nsfocus.com&gt;\nCasper H.S. Dik &lt;Casper.Dik@Sun.COM&gt;\ndeepin          &lt;deepin@nsfocus.com&gt;\nscz             &lt;scz@nsfocus.com&gt;\njbtzhm          &lt;jbtzhm@nsfocus.com&gt;\nsuxm            &lt;suxm@nsfocus.com&gt;\ntt              &lt;warning3@nsfocus.com&gt;\n简介 --\n这份文档不是FAQ(Frequently Answered Question)，不少问题属于FUQ(Freque-\nntly Unanswered Question)。换句话说，不一定是最常见的编程、应用问答，很可\n能其中的答案尚是一个构思，还没有成为现实，又或者根本是个错误的思想火花。但\n是，她的确在试图回答一些很有意义的问题，让更多的Unix/C程序员、系统管理员共\n享彼此的智慧，那是三十年前无数前辈精英做到过的，也是我们正试图做到的。\nQ -- Question\nA -- Answer\nD -- Discuss\n声明 --\n永久拒绝任何商业性质的转载、摘录、引用。在不对所有文字做任何修正的前提\n下，允许一切教育性质的转载、摘录、引用，无须提前知会维护者(就是me，faint)。\n一旦出现需要修正文字的情况，只能通过维护者修正。维护者会在下一次版本升级过\n程中正式增加这种修正，保留提供修正者应有信息。同时意味着提供修正者永久自愿\n放弃商业性质的所有权益。不接受这种条件的提供修正者，务必提前知会维护者，此\n类修正将不出现在下一次版本升级中。\n文中所附各种源代码，在严格意义上可能存在版权问题，所以事实上这份文档带\n有\"半地下\"性质，使用者务必自己小心卷入此类纠纷。\n文中技术可能涉及未公开的、未文档化的、非规范的编程、应用接口，文档提供\n的重在思想，而不保证是正确、高效、唯一的解答。\n维护者不对文中任何技术引起的任何灾难性后果负任何法律上的、道义上的责任。\nOk, Let‘s go.\n辅助说明 --\n2003-10-09 12:49\n辅助说明只在\"外发版\"中存在，稍微解释一下。\n一直没有单独出一份完整的，原因很多。如果搁在1995/1996/1997时的CERNET，\n这些原因都不成为原因，现在成为原因。不想多说为什么，明白的自然明白，不\n明白的当我白痴好了，反正别问我。\n出于\"声明\"中的某些理由，不能在单份完整文档中附带可能会带来麻烦的文字、\n代码，比如Solaris libproc编程接口。但是，在散篇中你能找到它们。如果你\n愿意，可以自己将散篇收回到该文档中，这将与我无关。一切索要残缺部分的邮\n件概不回复。\n本份文档的绝大多数内容在\"中国教育科研网华南地区网络中心BBS\"(bbs.gznet.\nedu.cn)的Solaris版发布过了，包括下面处理掉的目录列表。是该版前版主CPU\n师兄当年的风范促使我开始整理这份文档的，当还昔日指教之情谊。\n该份文档\"允许一切教育性质的自由转载、摘录、引用，无须提前知会维护者\"。\n我也只是义务维护一下，不对本文档拥有任何权益。如果不幸潜在拥有而践踏了\n某种信念，在你看到该辅助说明的同时，我将自动放弃这种潜在可能拥有的权益。\n同时意味着一切因本文档带来的麻烦，将由你个人承担。\n既然来自Unix共享传统文化圈，就让它彻底回到Unix共享传统文化圈中去吧。\n欢迎一切建设性的、非索要性质的Email交流。\n--------------------------------------------------------------------------\n目录\n0.    Unix/C传奇问题\n0.0\n0.1   Dennis Ritchie 和 Ken Thompson\n0.2   W. Richard Stevens 之死\n0.3   更多Unix传奇故事\n0.4   那些Unix传奇人物长什么样，不会都是三头六臂吧\n0.5   \"3y3\"是如何转换成\"eye\"的\n0.6\n1.    系统管理配置问题\n1.0   如何屏蔽power-button\n1.1   如何给SUN工作站增加eeprom硬件口令保护\n1.2   如何增加交换空间\n1.3   为什么我不能在/home目录下创建子目录\n1.4   如何改变一台主机的locale\n1.5   Solaris 7自动注销\n1.6   一个目录拥有setgid设置，怎么理解\n1.7   非Sun Console上有无等价Stop-A的按键\n1.8   如何让一个用户只能ftp而无法telnet\n1.9   Solaris 8上tftpd的使用\n1.10  为什么Sun工作站非要输入boot命令才能启动\n1.11  如何让Solaris识别新增加的硬件\n1.12  Solaris 9如何在命令行上增加新用户\n2.    堆栈相关问题\n2.0   理解SIGBUS与SIGSEGV\n2.1   如何理解pstack的输出信息\n2.2   Solaris的pstack实现源码\n2.3   Solaris中如何获取一个C程序的调用栈回溯\n2.4   如何编程获取栈底地址\n2.5   如何得到一个运行中进程的内存映像\n2.6   调试器如何工作的\n2.7   x86/Linux上如何处理SIGFPE信号\n2.8   GDB调试时没有符号表，如何设置断点\n3.    -lelf、-lkvm、-lkstat相关问题\n3.0\n3.1   如何判断可执行文件是否携带了调试信息\n3.2   mprotect如何用\n3.3   mmap如何用\n3.4   getrusage如何用\n3.5   setitimer如何用\n4.    系统资源相关问题\n4.0\n4.1   主流Unix操作系统上如何编程获取进程的内存、CPU利用状况\n4.2   Solaris下如何获知CPU速率\n4.3   如何编程获取Solaris系统当前内存大小\n5.    块设备相关问题\n5.0   Solaris/FreeBSD/Linux中如何mount ISO文件\n5.1   CDROM设备究竟在哪里\n5.2   如何弹出光驱\n5.3   如何利用超级块进行恢复工作\n5.4   Solaris root口令忘记了\n5.5   如何使用fmthard\n5.6   如何从光盘恢复Solaris 7的引导扇区\n5.7   Solaris支持类似微软autorun.inf文件的功能吗\n5.8   如何修改/dev/null的属性\n5.9   如何读取Solaris disk label信息\n5.10  如何自己制作Solaris启动软盘\n5.11  x86/Solaris如何访问FAT32分区\n5.12\n6.    /etc/system可调资源限制\n6.1   Solaris下如何限制每个用户可拥有的最大进程数\n6.2   如何配置系统使之支持更多的伪终端\n6.3   如何增加每个进程可打开文件句柄数\n6.4\n6.5   做了setuid()这类调用的程序如何产生core dump\n6.6   消息队列调整\n7.    DNS相关问题\n7.1   如何进行DNS区传输\n7.2   如何获知权威名字服务器\n7.3   如何配置DNS的委托解析\n7.4   如何获知BIND的版本号\n7.5   Solaris/FreeBSD/Linux如何指定域名解析的顺序\n8.    Solaris编程相关问题\n8.0   Solaris多线程编程与errno全局变量\n8.1   Solaris内核模块中如何getcwd\n8.2   Solaris下如何动态增加系统调用\n8.3   如何避免一个套接字进入TIME_WAIT状态\n8.4   结构在优化编译中的对齐问题\n8.5   kvm编程举例: 如何编程读取shmsys:shminfo_shmmax的值\n8.6   如何得到非局部变量列表\n8.7   内核可加载模块引用了无法解析的符号\n8.8   如何单独获得Solaris编译环境\n8.9   如何获取Solaris内核可调参数列表\n8.10  如何获取自Unix纪元以来的秒数，如何转换成可理解的表达方式\n8.11  如何页边界对齐式分配内存\n8.12  Solaris下究竟如何使用setuid/seteuid/setreuid\n8.13  compile()和step()怎么用\n8.14  Solaris系统中如何检查内存泄露、腐烂\n8.15  How to enable microstate accounting in order to use gethrvtime(3C)\n8.16  如何让普通用户可以绑定[1, 1023]闭区间上的特权端口\n8.17  SPARC/Solaris 7 64-bit kernel mode下dumpadm(1M)手册页\n8.18\n9.    图形界面相关问题\n9.1   如何避免进入Solaris的图形界面\n9.2   Solaris 7的锁屏\n9.3   如何调整键盘重复率\n9.4   如何拔掉键盘继续运行Solaris\n9.5   Solaris下如何设置显卡分辨率\n9.6   Solaris下如何设置显示刷新率\n9.7   在PC X Server上使用中文\n9.8   如何让Solaris Console保持在字符登录界面，同时可以远程使用PC X Server\n10.   网卡相关问题\n10.0  怎样将第二块网卡名改成hme0\n10.1  如何在程序中获取本机MAC地址\n10.2  如何在Sun工作站上安装3块网卡\n10.3  如何在Solaris x86上安装网卡驱动\n10.4  Solaris 单网卡多IP(以太网卡别名)\n10.5  如何修改主机名(hostname)\n10.6  SPARC/Solaris 2.5/2.6/7/8下如何设置网卡100Mb全双工\n10.7  Unix如何对抗ARP欺骗\n10.8  SPARC/Solaris 2.6/7/8下如何检查网卡混杂模式\n10.9  FreeBSD下ifconfig的man手册\n10.10 FreeBSD下arp的man手册\n10.11 x86/Solaris如何强制设定网卡速率\n10.12 Solaris/FreeBSD/Linux如何确定网卡Capability/Speed\n10.13 x86/FreeBSD 4.3-RELEASE下LINK_ADDR(3)手册页\n10.14 traceroute是怎么实现的\n10.15 SPARC/Solaris 8 snoop(1M)手册页\n10.16 x86/FreeBSD TCPDUMP(1)手册页\n10.17 Solaris系统中ip_strict_dst_multihoming的确切含义是什么\n11.   package相关问题\n11.0  在SPARC/Solaris 8上手工安装libpcap\n11.1  Solaris下如何将二进制软件包安装到指定目标路径下\n11.2  Solaris下如何自己定制二进制安装包\n11.3  如何恢复/usr/bin/su的缺省安装属性\n11.4  如何获知指定包与其他包之间的依赖关系\n11.5  如何获得Linux命令的源代码\n11.6  Solaris下如何知道某包中有哪些文件\n11.7  RedHat下如何检查文件是否被改动过\n12.   日志相关问题\n12.0  Solaris 8如何enable FTP session log\n12.1  如何查看/var/adm/utmp、/var/adm/wtmp、/var/adm/lastlog\n12.2  logger/syslogd问题\n12.3  如何关闭cron的日志\n12.4  /var/adm/lastlog文件看上去太大了\n13.   进程相关问题\n13.1  如何根据进程名获得PID\n13.2  如何在命令行上访问指定进程P、U两区，如何欺骗Solaris的ps\n13.3  getexecname(3C)是怎么实现的\n13.4  Solaris 7/8下ps输出中的问号\n13.5  如何根据某种原则终止一批进程\n13.6  利用libproc库编程举例\n13.7  给定一个PID，如何知道它对应一个运行中的进程\n13.8  Unix编程中所谓\"僵尸进程\"指什么\n13.9  x86/FreeBSD 4.3-RELEASE的ptrace(2)手册页\n13.10 如何知道哪个进程使用了哪个端口\n13.11 x86/FreeBSD如何快速获取指定用户拥有的进程数\n13.12 如何获取当前进程对应之静态映像文件的绝对路径\n13.13 x86/Linux Kernel 2.4.7-10的ptrace(2)手册页\n13.14 x86/Linux Kernel 2.4.7-10下如何欺骗ps\n14.   一些小工具的使用\n14.0\n14.1  如何在命令行上进行8进制、10进制、16进制之间的转换\n14.2  显示文件的三个时间戳(atime、mtime、ctime)\n14.3  只在本地文件系统上查找\n14.4  join命令\n14.5  反汇编\n15.   32-bit/64-bit相关问题\n15.0\n15.1  Solaris下如何识别当前内核版本\n15.2  如何启动Solaris 32-bit/64-bit内核\n15.3  gcc支持64-bit编译吗\n15.4  Solaris启动时内核文件找不到了\n15.5  64-bit驱动程序无法在8下关联，但在7下工作正常\n16.   库相关问题\n16.0  为什么用高版glibc编译生成的程序不能与低版glibc搭配运行\n16.1  在Solaris 7下编写网络程序需要链接哪些库\n16.2  SUID设置和LD_LIBRARY_PATH环境变量\n16.3  链接过程中库的顺序\n16.4  Solaris 2.x下如何构造动态链接库\n16.5  如何生成linux下的共享库\n16.6  /usr/lib/ld.so.1损坏或丢失\n16.7  Solaris下如何使用LD_PRELOAD环境变量\n16.8\n16.9  Solaris 8下如何配置运行时链接环境\n16.10 libcrypto.so.0.9.6是什么软件包里的\n16.11 共享库的动态加载/卸载\n16.12 编译时命令行指定-ldl，ldd观察时却是libdl.so.2，为什么\n16.13 如何进行部分静态链接\n17.   文件查看问题\n17.0  如何改变vi临时目录\n17.1  如何直接查看man文件\n17.2  .tex文件怎么读\n17.3  Solaris下怎么看.ps文件\n18.   补丁相关问题\n18.0\n18.1  如何根据补丁号从Sun主站下载补丁\n18.2  删除旧式补丁备份，释放被占用的磁盘空间\n18.3  patchdiag如何使用\n18.4  给Solaris 2.6安装推荐补丁集(未完成)\n18.5  已知补丁号，如何最快判断系统中是否已经安装该补丁\n18.6  如何安装补丁\n19.   终端相关问题\n19.0  如何将stdin、stdout、stderr重定向到/dev/null\n19.1  如何使Backspace键做删除操作，而不是显示^H\n19.2  telnet时如何关闭本地回显\n19.3  如何清空stdin的缓冲\n19.4  Linux Console下一按错键就叫，怎么关\n19.5  从stdin立即获取按键\n19.6  如何屏蔽Ctrl-D\n20.   shell script问题\n20.0  不用临时文件完成字符串替换\n20.1  如何获取一个字符串的长度\n20.2  读超时自动使用缺省值\n20.3  如何删除空行、空白符组成的行\n20.4  BASH中如何得到一个字符串的子串\n20.5  shell script中如何关闭stdout\n20.6  如何将一个文本文件开始的N行删除\n20.7  以字符串(非单个字符)为分隔的析取\n20.8  使用tr命令加密文件\n20.9  有哪些命令用于查找定位\n20.10 非递归删除目录树\n20.11 如何将大写文件名转换为小写文件名\n20.12 shell script中有办法实现段落注释吗\n20.13 批量文件字符串替换\n21.   BSD相关问题\n21.0  在x86/FreeBSD 4.5-RELEASE上安装nessus\n21.1  如何将/var文件系统mount成mfs并支持cron daemon\n21.2  如何将一个512字节的文件写入主引导扇区\n21.3  x86/FreeBSD 4.3-RELEASE下FDISK(8)手册页\n21.4  x86/FreeBSD 4.3-RELEASE下HEXDUMP(1)手册页\n21.5  x86/FreeBSD 4.3-RELEASE下DISKLABEL(8)手册页\n21.6  x86/FreeBSD 4.x下不能cp覆盖/kernel\n21.7  x86/FreeBSD下如何设置路由\n21.8  x86/FreeBSD 4.4-RELEASE下DIFF(1)手册页\n21.9  什么是locale\n21.10 用cvsup安装vim\n21.11 FreeBSD下显示、输入中文\n21.12 如何在OpenSSH中限制只允许某些用户登录\n21.13 在FreeBSD 4.3-RELEASE上安装libpcap、libnet\n21.14 如何使自己的BMP图象成为启动logo\n21.15 UDMA ICRC error是什么意思\n21.16 Limiting closed port RST response什么意思\n21.17 如何获取FreeBSD Kernel Source Code\n21.18 /boot/defaults/loader.conf中的技巧\n21.19 FreeBSD中sysctl可控内核参数\n21.20 x86/FreeBSD 4.3-RELEASE下GETIFADDRS(3)手册页\n21.21 FreeBSD下如何访问显存\n21.22 FreeBSD下如何为指定用户设定chroot的FTP环境\n21.23 如何利用FKLD动态增加一个新协议\n21.24 修改/etc/mail/sendmail.cf关闭ident功能\n21.25 FreeBSD下如何获取系统负载\n21.26 *BSD下如何屏敝远程登录时Copyright显示\n21.27 cvsup安装BASH\n21.28 配置core dump\n21.29 在OpenBSD 3.0上安装Gcc\n21.30 在NetBSD 1.5.2上安装BASH\n21.31 找不到何处启动了snmpd\n21.32 FreeBSD远程root访问\n22.   Linux Kernel Programming\n22.0\n22.1  直接访问内存[显存]地址\n22.2  /proc可控内核参数\n23.   Linux相关问题\n23.0  以POST方式提交URL请求\n23.1  RedHat 7.2远程root访问\n23.2  TELNET/FTP连接耗时过长\n23.3  Debian/Linux中如何修改本机IP\n23.4  如何确认是何种Unix Release\n23.5  vi/insert状态下copy/paste时不回车、只换行\n23.6  如何产生core dump\n23.7  Socket( PF_PACKET, SOCK_RAW, htons( ETH_P_ARP ) )报错\n24.   Unix编程相关问题\n24.0  如何知道fd是有效文件句柄\n24.1  如何使代码段可写\n24.2  建议性文件锁与强制性文件锁\n24.3  如何编写daemon程序\n24.4  将编译、链接过程分开\n25.   AIX相关问题\n25.0  如何查看AIX版本号\n25.1  如何在AIX命令行上修改IP地址\n25.2  如何查看RS/6000物理内存大小\n25.3  AIX 4.3.3中\"ls a*\"不正常\n25.4  AIX多线程编程与errno全局变量\n--------------------------------------------------------------------------\n0. Unix/C传奇问题\n0.1 Dennis Ritchie 和 Ken Thompson\nQ: 我想知道他们，为什么大家不断提到这两个名字？\nA: All of Unix Programmers\n我们也想知道，:-P\n1969年Dennis Ritchie 和 Ken Thompson在贝尔实验室创造性地发明了Unix操作系统，\n为此1983年他们获得了图灵奖。\n尽管Ritchie是C程序设计语言的发明者，但是他最喜欢的编程语言是Alef。而\nThompson是一名业余飞行员，曾到莫斯科驾驶过米格-29。\n欢迎访问\nhttp://cm.bell-labs.com/who/dmr/\nhttp://cm.bell-labs.com/who/ken/\n0.2 W. Richard Stevens 之死\nQ: David Johns &lt;odin@gte.net&gt;\n我是他的崇拜者，用www.google.com搜索他的讣告，但这份讣告没有提及死因，有人\n知道吗？\n真的仅仅是英年早逝吗？\nA: Nithyanandham &lt;m.nithyanandham@blr.spcnl.co.in&gt;\n他死于1999/09/01，家人不想让别人知道死因。讣告位于\nhttp://www.azstarnet.com/clips/richard_stevens.html\nA: joe broz &lt;jbroz@transarc.ibm.com&gt;\n似乎是一场攀岩事故，或者滑雪事故，我不确认。\nQ: W. 代表什么\nA: William. My parents wanted to name me after my Uncle Bill but also\nwanted to call me Richard. They figured \"William Richard\" sounded\nbetter than \"Richard William\".\nQ: 做为Guru of the Unix gurus，Stevens一生当中崇拜过什么人吗？\nA: http://www.salon.com/tech/feature/2000/09/01/rich_stevens/index.html\nStevens greatly admired and strove to emulate Donald Knuth, who wrote\n\"The Art of Computer Programming,\" and Brian Kernighan,\n\"The C Programming Language,\" whose books are as beautifully laid out as\nthey are brilliantly written.\nD: knightmare@bbs.apue.net 2002-04-08 15:54\n搞笑片段\n我现在越来越崇拜Stevens了，因为昨天我看的电影--反斗神鹰(hot shot)--的导演\n是Richard Stevens。\nD: Rachel Chalmers &lt;rachel@goop.org&gt;\n这个可与之比拟，不过这个是真的\nHis books are so good that they have come to symbolize intelligence. In\n\"Wayne‘s World II,\" Garth‘s girlfriend carries a copy of \"Unix Network\nProgramming.\" Stevens discovered this when he took his 13-year-old son to\nsee the film. His son grabbed his arm and said, \"Dad, that‘s your book!\"\n\"I couldn‘t believe it,\" he told programmer Trent Hein. \"My book was used\nto define the ultimate geek, and suddenly my son thinks I‘m really cool.\"\nHis son was right.\n0.3 更多Unix传奇故事\nA: http://www.salon.com/directory/topics/unix/index.html\n0.4 那些Unix传奇人物长什么样，不会都是三头六臂吧\nA: 长得并没有多帅，不过更多比他们帅的人没能在Unix历史上留下什么，我想他们\n还是蛮和蔼的嘛。这里是其中九位的照片\nFamous Hacker &amp; Engineer\nhttp://fsl.myetang.com/\n0.5 \"3y3\"是如何转换成\"eye\"的\nA:\n下面是一个基本转换表\n--------------------------------------------------------------------------\na 4 @ 4 4 @ @ 4 4 4 or @ or /-b |3 b 8 8 B |3 8 8 8 or |3\nc C c c k C ( &lt; &lt; (\nd |) |) D d D |) D c| |)\ne 3 3 3 3 3 3 3 3 3\nf |&gt;|-| f ph F F |[ F |= |= or pH\ng 6 G g 9 6 6 6 6 9\nh |-| |-| H |-| H |{ H |-| |-| or #\ni 1 1 i 1 ! | 1 ][ or 1 1 or | or !\nj _| j j j J _| J _] J\nk |&lt; |&lt; k |&lt; K |&lt; [&lt; |&lt; |{ or |&lt;\nl |_ 1 1 1 1 |_ |- 1 or | or [ or |_ |_ or []_\nm |\\/| |\\/| M /\\/\\ M |V| M |\\/| |\\/|\nn |\\| |\\| n |\\| N |\\| N |\\| |\\| or /\\/\no 0 o o 0 0 0 0 0 0\np |&gt; p P p P |o P |&gt; |&gt;\nq Q q Q q Q O, Q 0 Q\nr |2 r R |2 R |)\\ R |2 |2\ns 5 5 s 5 5 5 $ 5 or Z 5\nt 7 + + 7 7 7 7 7 or + + or 7\nu |_| u u u U |_| U |_| |_| or \\_/\nv \\/ v V \\/ V \\/ V \\/ \\/\nw \\/\\/ \\/\\/ W \\/\\/ W |/\\| W \\/\\/ \\/\\/\nx &gt;&lt; &gt;&lt; X &gt;&lt; X X &gt;&lt; X\ny `/ Y y ‘/ Y \\/\n| Y j or J or `/ Y\nz Z z Z z 2 -\\_ Z 5 Z\n--------------------------------------------------------------------------\n如果只进行字母到数字的转换，可以简化成\n--------------------------------------------------------------------------\na -&gt; 4\nb -&gt; 8\ne -&gt; 3\ng -&gt; 6\ni -&gt; 1\nl -&gt; 1\no -&gt; 0\ns -&gt; 5\nt -&gt; 7\n--------------------------------------------------------------------------\n这里有一个转换页面，由于存在一对多的现象，转换结果可能并不完全相符\nhttp://www.planetquake.com/turkey/l33translate.htm\n比如\"I‘m a programmer\"，将被转换成\"1‘/\\/\\ 4 p|209|24/\\/\\/\\/\\3|2\"\n更多信息参看如下链接\nhttp://www.cwru.edu/orgs/sigmataudelta/submissions/rome-relaxweunderstand.htm\nD: dfbb@bbs.tsinghua.edu.cn\n有个geekcode也差不多，http://www.geekcode.com/geek.html\n1. 系统管理配置问题\n1.0 如何屏蔽power-button\nQ: 如何屏蔽Sun键盘右上角的power-button\nA: Alan Coopersmith &lt;alanc@csua.berkeley.edu&gt; 2002年7月19日 22:12\n1) 为了只允许root执行sys-suspend命令shutdown/suspend系统，可以编辑\n/etc/default/sys-suspend\n2) 为了禁止通过power-button激活sys-suspend命令，编辑\n/usr/openwin/lib/speckeysd.map\n1.1 如何给SUN工作站增加eeprom硬件口令保护\nA: scz &lt;scz@nsfocus.com&gt;\nman -s 1M eeprom了解细节，要求当前是root身份\n# /usr/sbin/eeprom (显示当前eeprom配置)\n# /usr/sbin/eeprom security-mode=full ( 可选的有command, full, none)\n此时进入交互式设置口令过程，总共输入两次，如果两次口令输入不一致，则本次设\n置作废。成功设置之后除了go命令之外的其他ok状态下命令均需要口令，包括boot命\n令。\n设置成command时，同样进入交互式口令输入过程。此时，除了boot和go命令之外的\n其他ok状态下命令均需要口令。注意，如果仅仅输入boot命令，不需要口令，一旦\nboot命令后面带了参数，比如boot cdrom -s，同样需要输入口令。\n如果设置成none(缺省设置)，表示去掉这种口令保护。\n# /usr/sbin/eeprom security-password= (等号后面无其他字符，直接回车)\n如果想改变前面设置的口令，用这条命令，同样是交互式输入过程。\n# /usr/sbin/eeprom security-#badlogins=3 (缺省是0)\n设置口令输入尝试次数。\n警告：如果设置了eeprom硬件保护口令而又忘记，会带来很多麻烦，务必小心。\n一个可行的设置办法是，安全模式设置到command而不是full，这样至少可以正常启\n动系统。于是只要记得root口令或者还有其他机会获得root权限(缓冲区溢出？)，就\n可以通过设置安全模式为none而挽救回来。\n但是如果设置成full模式却忘记了eeprom口令，我想首先应该打电话给SUN的技术支\n持。如果出于某种理由你不想这样做，我不确认eeprom是否可以热插拔，先用一个无\n口令保护的eeprom启动系统，然后热插拔换上那个有口令保护的eeprom，然后用root\n权限抹去eeprom口令。\nD: bluesfisher@smth.org\n启动时Stop-N可以恢复OBP缺省设置，应该可以把这个密码去掉吧\n按住Stop-N，加电，直到键盘灯闪\nD: lose@smth.org 2002-03-22 01:45\n试了一下Stop-N，不可以。\n试了一下小四的办法是可以的，只是有几个小地方需要说一下。没有eeprom时机器是\n无法启动的，所以必须要有另一块没有口令的eeprom。第一次为了热插拔方便没有将\n新的eeprom插得很紧，启动之后报告IDPROM出错，不过没有关系，系统还是可以启动。\n换上eeprom之后，只有console窗口可以运行，其它命令窗口无法运行命令。在\nconsole下修改\n# /usr/sbin/eeprom security-mode=none\nreboot机器，一切OK。另外发现，只要你换上eeprom，都可以reboot机器而不需要口\n令，重新启动之后再修改也可以，不知道这算不算一个bug。\n1.2 如何增加交换空间\nA: WT &lt;wt@server.domain.top&gt;\n你无法改变分区大小，但是可以增加/删除交换文件，效果类似交换分区。下列命令\n在根目录下创建一个500MB的交换文件，名为swapfile\n# mkfile 500m /swapfile\n下列命令将使之生效\n# swap -a /swapfile\n现在你有了额外的500MB交换空间，为了每次重启后依旧有效，编辑/etc/vfstab文件\n增加如下行\n/swapfile - - swap - no -\n# swap -l\n这里\"-l\"意味着\"list\"，显示所有交换空间。仔细阅读\"swap\"和\"mkfile\"的手册页。\n1.3 为什么我不能在/home目录下创建子目录\nQ: Solaris 7下，root身份，当我试图在/home目录下创建子目录时，系统拒绝，为\n什么？\nA: mohansundarraj\n如果/etc/rc2.d/S74autofs脚本中automount(1M)守护进程已经mount了/home，就是\n这种现象，而这还是缺省安装后的情形。可以\n# /etc/init.d/autofs stop\n# umount /home\n然后你就可以用root身份在/home下创建子目录，增加文件了。为了永久取消autofs\n特性，可以将/etc/rc2.d/S74autofs脚本改名，并注释掉/etc/auto_home、\n/etc/auto_master两个文件中的入口点。\nSPARC/Solaris的缺省用户主目录是/export/home，而不是/home。\n1.4 如何改变一台主机的locale\nQ: 一台SPARC/Solaris 8运行在US locale环境中，现在我们想让它运行在\nIE(Ireland) locale环境中，以便可以使用欧洲日期格式，怎么办？\nA: Sharad Ramachandran &lt;estancio@hotmail.com&gt;\n运行sys-unconfig，在此之前请man -s 1M sys-unconfig，:-)\nA: chad schrock &lt;chad@radix.net&gt;\n天啊，为了拍死一只苍蝇，你要引爆原子弹吗？\n只需要做如下操作，在你的.cshrc/.profile/.bashrc等启动脚本中设置$LANG环境变\n量的值为en_UK，注销，重新登录即可。为了使这个设置全局有效，修改\n/etc/default/init文件，LANG=en_UK，重启动。\n--------------------------------------------------------------------------\n# @(#)init.dfl 1.2 92/11/26\n#\n# This file is /etc/default/init.  /etc/TIMEZONE is a symlink to this file.\n# This file looks like a shell script, but it is not.  To maintain\n# compatibility with old versions of /etc/TIMEZONE, some shell constructs\n# (i.e., export commands) are allowed in this file, but are ignored.\n#\n# Lines of this file should be of the form VAR=value, where VAR is one of\n# TZ, LANG, or any of the LC_* environment variables.\n#\nTZ=GMT+8\nLANG=zh.GBK\n--------------------------------------------------------------------------\n参看locale(1)和locale(5)，了解更多关于locale的信息。运行\"locale -a\"，查看\n当前系统所支持的所有locale。\nA: Sun Microsystems 2001-06-12\n有三种方式改变locale。首先用\"locale -a\"命令确认系统中已安装的locale\n1) 从CDE登录屏幕上修改locale\n选择 options -&gt; languages -&gt; choose the new locale\n注意，如果登录用户的初始化文件中有不同的locale设置，将优先于系统全局locale\n设置。\n2) 临时设置locale(shell相关的)\nksh : LANG=&lt;locale&gt;\nsh  : LANG=&lt;locale&gt;\nexport LANG\ncsh : setenv LANG &lt;locale&gt;\nbash: export LANG=en_US(zh.GBK)\n3) vi /etc/default/init\n增加如下内容\nLANG=&lt;locale&gt;\nLC_ALL=&lt;locale&gt;\n重启系统。\n运行\"locale\"命令确认改变生效。\n如果你希望使用的locale并未安装，参看如下文档安装locale\nSolaris 8  : &lt;&lt;International Language Environments Guide&gt;&gt;\nSolaris 7  : &lt;&lt;Solaris Internationalization Guide For Developers&gt;&gt;\nSolaris 2.6: &lt;&lt;Solaris Internationalization Guide for Developers&gt;&gt;\nD: scz &lt;scz@nsfocus.com&gt; 1998-08\nSPARC/Solaris 2.5下，为了在vi中正确看到中文需要设置环境变量\nsh\nLANG=C;export LANG\nLC_CTYPE=iso_8859_1;export LC_CTYPE\ncsh\nsetenv LANG zh\n关于设置LANG这个环境变量涉及到/usr/lib/locale下的目录权限。\n1.5 Solaris 7自动注销\nQ: 怎样设置才能30秒后自动注销\nA: shridhara\n不幸的是，Solaris对此没有什么好的支持。如果正在使用telnet会话，或许可以考\n虑\"logout\"变量，参看telnet的手册页。一个变通的办法，使用K-Shell，它支持\nTMOUT变量，用于指定非活动时限(以秒为单位)。比如，如果一个shell会话3分钟内\n不活动，则终止这个shell会话\n$ TMOUT=180;export TMOUT\n可以在用户的.profile文件中放置该行。缺点是你只能使用ksh。\nD: quack\nLinux、Solaris 2.6上的Bash试了也行。\nD: scz &lt;scz@nsfocus.com&gt;\nvi /etc/default/login\n# TIMEOUT sets the number of seconds (between 0 and 900) to wait before\n# abandoning a login session.\n#\nTIMEOUT=180\n这里的超时设置针对登录过程，而不是登录成功后的shell会话超时设置。\n1.6 一个目录拥有setgid设置，怎么理解\nQ: 对一个目录做了setgid设置，可我并没有发现这和正常情况有什么区别\nA: John Riddoch &lt;jr@scms.rgu.ac.uk&gt;\n在这种目录下创建新文件时将采用setgid设置对应的属组，比如\n$ ls -ld b\ndrwxrws---   2 jr       group     512 Mar 14 17:13 b/\n$ touch b/a\n$ ls -l b/a\n-rw-------   1 jr       group       0 Mar 14 17:13 b/a\n$ id\nuid=178(jr) gid=10(staff)\njr的缺省组是staff，而现在b/a文件属组是group。\nD: 小四 &lt;scz@nsfocus.com&gt;\nSPARC/Solaris 7下测试\n如果目录拥有SGID设置，那么该目录下新创建的文件将继承该目录的属组，而不是创\n建者所对应的GID。\n[root@ /export/home/scz]&gt; id\nuid=0(root) gid=1(other)  &lt;-- 注意当前用户的属组\n[root@ /export/home/scz]&gt; mkdir groupsgid\n[root@ /export/home/scz]&gt; ls -ld groupsgid\ndrwxr-xr-x root other groupsgid/\n[root@ /export/home/scz]&gt; chown scz:users groupsgid\n[root@ /export/home/scz]&gt; chmod g+s groupsgid\n[root@ /export/home/scz]&gt; ls -ld groupsgid\ndrwxr-sr-x scz users groupsgid/  &lt;-- 目录拥有SGID设置\n[root@ /export/home/scz]&gt; cd groupsgid/\n[root@ /export/home/scz/groupsgid]&gt; touch scz_0\n[root@ /export/home/scz/groupsgid]&gt; ls -l scz_0\n-rw-r--r-- root users scz_0  &lt;-- 注意属组变化\n[root@ /export/home/scz/groupsgid]&gt; chmod g-s ../groupsgid/\n[root@ /export/home/scz/groupsgid]&gt; ls -ld ../groupsgid/\ndrwxr-xr-x scz users ../groupsgid/\n[root@ /export/home/scz/groupsgid]&gt; touch scz_1\n[root@ /export/home/scz/groupsgid]&gt; ls -l scz_1\n-rw-r--r-- root other scz_1  &lt;-- 注意属组变化\n[root@ /export/home/scz/groupsgid]&gt;\n1.7 非Sun Console上有无等价Stop-A的按键\nA: neomilev\n如果是便携机，尝试alt/break 或者 ctrl/break。如果是vt100终端，尝试F11 或者\nbreak\n1.8 如何让一个用户只能ftp而无法telnet\nA: 小四 &lt;scz@nsfocus.com&gt;\n修改该用户在/etc/passwd中的shell为/bin/false，在/etc/shells文件中增加\n/bin/false，此时，该用户只能ftp，telnet失败。\n如果/bin/false不灵，干脆换成/bin/nonexist即可。其实/bin/false不灵只是暂时\n某些缓冲机制的结果，重启后必然有效，不重启的话可能要等待一定时间之后才见效\n果。\n如果将/bin/false换成/usr/bin/passwd，则用户可以远程telnet修改自己的口令，\n也可以ftp登录，但无法远程telnet登录获取shell。\n1.9 Solaris 8上tftpd的使用\nA: Solaris 8上in.tftpd(1M)手册页\n--------------------------------------------------------------------------\n维护命令                                                      in.tftpd(1M)\n名字\nin.tftpd, tftpd - Internet Trivial File Transfer Protocol Server\n摘要\nin.tftpd [ -s ] [ homedir ]\n抽述\ntftpd通常通过inetd.conf启动，缺省是注释掉的，需要手工开放。\n在响应请求之前，tftpd试图切换自身的当前目录到指定的\"homedir\"，缺省设置\n是/tftpboot。\ntftp不要求帐号、口令即可访问远程系统。由于缺乏身份认证信息，in.ftpd在\n处理get请求时只允许访问全局可读文件。而在处理put请求时，要求server端文\n件名已存在且全局可写。\nin.tftpd以nobody身份运行。\n选项\n-s 指定该选项时，tftpd切换自身当前目录到指定\"homedir\"必须成功，同时\ntftpd会以\"homedir\"为根做chroot操作。\n文件\n/etc/inetd.conf\n--------------------------------------------------------------------------\ntftpd在处理请求失败时会写/var/adm/messages，可用如下命令查看错误信息\n# tail -5 /var/adm/messages\ntftpd侦听69/udp口。\n1.10 为什么Sun工作站非要输入boot命令才能启动\nQ: 我有台Sun工作站，每次开机后停在ok状态下，需要手工输入boot命令才能启动，\n现在想避免这种效果，怎么办\nA: /usr/sbin/eeprom auto-boot?=true\n/usr/sbin/eeprom auto-boot?  &lt;-- 查询\nA: dengdai@SMTH\n进入OBP状态\nok setenv auto-boot? true\nok setenv boot-device disk\n反之\nok setenv auto-boot? false\n1.11 如何让Solaris识别新增加的硬件\nQ: 比如新增加了网卡、硬盘、光驱什么的，如何让Solaris意识到这种增加\nA: spp(低音炮) &amp; suxm &lt;suxm@gnuchina.org&gt;\n有三种办法\na. Stop-A进入OBP状态，输入boot -r\nb. sync(重复);reboot -- -r\nc. touch /reconfigure;sync(重复);reboot\n参看reboot(1M)、boot(1M)、eeprom(1M)、kernel(1M)、cfgadm(1M)、psradm(1M)手\n册页\nQ: 我新增加了一块硬盘，不想boot -r而立即生效，怎么办\nA: 老大 &lt;willxu@public.cs.hn.cn&gt; 2001-12-04 16:51\n直接将第二块硬盘接上去，然后顺序执行如下命令，不用重新启动机器\nmodunload -i 0\ndrvconfig(1M)\ndevlinks(1M)\ndisks(1M)\n如果需要重新格式化、分区、创建文件系统，就继续执行\nformat(1M)\nnewfs(1M)\n1.12 Solaris 9如何在命令行上增加新用户\nA:\nuseradd -u &lt;uid&gt; -g other -d /export/home/&lt;your&gt; -s /usr/bin/bash -c &lt;your&gt; -m &lt;your&gt;\n2. 堆栈相关问题\n2.0 理解SIGBUS与SIGSEGV\nQ: SIGSEGV我能理解，但有时碰上SIGBUS，这该如何理解。\nA: nkwht@smth\nnkwht用Google获取这样一些知识。有多种可能导致SIGBUS信号:\n1) 硬件故障，不用说，程序员最常碰上的肯定不是这种情形。\n2) Linux平台上执行malloc()，如果没有足够的RAM，Linux不是让malloc()失败返回，\n而是向当前进程分发SIGBUS信号。\n注: 对该点执怀疑态度，有机会可自行测试确认当前系统反应。\n3) 某些架构上访问数据时有对齐的要求，比如只能从4字节边界上读取一个4字节的\n数据类型。IA-32架构没有硬性要求对齐，尽管未对齐的访问降低执行效率。另外\n一些架构，比如SPARC、m68k，要求对齐访问，否则向当前进程分发SIGBUS信号。\nSIGBUS与SIGSEGV信号一样，可以正常捕获。SIGBUS的缺省行为是终止当前进程并产\n生core dump。\nA: Marc Rochkind &lt;rochkind@basepath.com&gt;\nSIGBUS与SIGSEGV信号的一般区别如下:\n1) SIGBUS(Bus error)意味着指针所对应的地址是有效地址，但总线不能正常使用该\n指针。通常是未对齐的数据访问所致。\n2) SIGSEGV(Segment fault)意味着指针所对应的地址是无效地址，没有物理内存对\n应该地址。\nA: scz &lt;scz@nsfocus.com&gt; 2002-11-20\n参\"2.4 如何编程获取栈底地址\"中如何捕获SIGBUS与SIGSEGV信号，并利用sigsetjmp、\nsiglongjmp重获控制权。\n测试表明，在x86/Linux、x86/Solaris、SPARC/Solaris平台上，越过栈底的地址访\n问导致SIGSEGV信号。在x86/FreeBSD、x86/NetBSD、x86/OpenBSD平台上，越过栈底\n的地址访问导致SIGBUS信号，而不是SIGSEGV信号。\n下面举例解释一下，什么叫未对齐的数据访问。\n--------------------------------------------------------------------------\n/*\n* Test: SPARC/Solaris 8 64-bit kernel mode\n* gcc -Wall -pipe -g -o bus bus.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main ( int argc, char * argv[] )\n{\nunsigned int        i = 0x12345678;\nunsigned short int *q = NULL;\nunsigned char      *p = ( unsigned char * )&amp;i;\n*p = 0x00;\nq  = ( unsigned short int * )( p + 1 );\n*q = 0x0000;\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n$ ./bus\n总线错误 (core dumped)\n$ gdb ./bus core\nGNU gdb 5.0\n#0  0x1084c in main (argc=1, argv=0xffbefc54) at bus.c:16\n16          *q = 0x0000;\n(gdb) disas main\nDump of assembler code for function main:\n0x10810 &lt;main&gt;   :      save  %sp, -128, %sp\n0x10814 &lt;main+4&gt; :      st  %i0, [ %fp + 0x44 ]\n0x10818 &lt;main+8&gt; :      st  %i1, [ %fp + 0x48 ]\n0x1081c &lt;main+12&gt;:      sethi  %hi(0x12345400), %o1\n0x10820 &lt;main+16&gt;:      or  %o1, 0x278, %o0     ! 0x12345678\n0x10824 &lt;main+20&gt;:      st  %o0, [ %fp + -20 ]\n0x10828 &lt;main+24&gt;:      clr  [ %fp + -24 ]\n0x1082c &lt;main+28&gt;:      add  %fp, -20, %o0\n0x10830 &lt;main+32&gt;:      st  %o0, [ %fp + -28 ]\n0x10834 &lt;main+36&gt;:      ld  [ %fp + -28 ], %o0\n0x10838 &lt;main+40&gt;:      clrb  [ %o0 ]\n0x1083c &lt;main+44&gt;:      ld  [ %fp + -28 ], %o0\n0x10840 &lt;main+48&gt;:      add  %o0, 1, %o1\n0x10844 &lt;main+52&gt;:      st  %o1, [ %fp + -24 ]\n0x10848 &lt;main+56&gt;:      ld  [ %fp + -24 ], %o0\n0x1084c &lt;main+60&gt;:      clrh  [ %o0 ]\n0x10850 &lt;main+64&gt;:      clr  %i0\n0x10854 &lt;main+68&gt;:      b  0x1085c &lt;main+76&gt;\n0x10858 &lt;main+72&gt;:      nop\n0x1085c &lt;main+76&gt;:      ret\n0x10860 &lt;main+80&gt;:      restore\nEnd of assembler dump.\n(gdb) i r pc\npc             0x1084c  67660\n(gdb) i r o0\no0             0xffbefbdd       -4260899\n(gdb) x/3bx 0xffbefbdd\n0xffbefbdd:     0x34    0x56    0x78\n(gdb)\n从C语言来说，执行\"*q = 0x0000;\"时导致SIGBUS了。从汇编指令来说，执行\"clrh [%o0]\"\n时导致SIGBUS了，寄存器%o0值为0xffbefbdd，这个地址未对齐在双字节边界上。\n注意，gcc编译时并未指定-O&lt;n&gt;进行优化，但仍然使用clrh，而不是两次clrb。类似\n的汇编指令有ldw、lduh等等。有人可能碰上读操作也导致SIGBUS，觉得不可理解，\n其实读写导致SIGBUS没有本质区别，比如ldw只能读4字节边界上的地址。\nbus.c是显式的未对齐。程序员实际最容易面对的是隐式未对齐，主要来自指针的强\n制类型转换。下面举例说明这种情形。\n--------------------------------------------------------------------------\n/*\n* Test: SPARC/Solaris 8 64-bit kernel mode\n* gcc -Wall -pipe -g -o other_bus other_bus.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main ( int argc, char * argv[] )\n{\nunsigned int        i = 0x12345678;\nunsigned short int  j = 0x0000;\nj = *( ( unsigned short int * )( ( ( unsigned char * )&amp;i  ) + 1 ) );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n$ ./other_bus\n总线错误 (core dumped)\n$ gdb ./other_bus core\nGNU gdb 5.0\n#0  main (argc=1, argv=0xffbefc44) at other_bus.c:13\n13          j = *( ( unsigned short int * )( ( ( unsigned char * )&amp;i  ) + 1 ) );\n(gdb) disas main\nDump of assembler code for function main:\n0x10810 &lt;main&gt;   :      save  %sp, -120, %sp\n0x10814 &lt;main+4&gt; :      st  %i0, [ %fp + 0x44 ]\n0x10818 &lt;main+8&gt; :      st  %i1, [ %fp + 0x48 ]\n0x1081c &lt;main+12&gt;:      sethi  %hi(0x12345400), %o1\n0x10820 &lt;main+16&gt;:      or  %o1, 0x278, %o0     ! 0x12345678\n0x10824 &lt;main+20&gt;:      st  %o0, [ %fp + -20 ]\n0x10828 &lt;main+24&gt;:      clrh  [ %fp + -22 ]\n0x1082c &lt;main+28&gt;:      lduh  [ %fp + -19 ], %o0\n0x10830 &lt;main+32&gt;:      sth  %o0, [ %fp + -22 ]\n0x10834 &lt;main+36&gt;:      clr  %i0\n0x10838 &lt;main+40&gt;:      b  0x10840 &lt;main+48&gt;\n0x1083c &lt;main+44&gt;:      nop\n0x10840 &lt;main+48&gt;:      ret\n0x10844 &lt;main+52&gt;:      restore\nEnd of assembler dump.\n(gdb) i r pc\npc             0x1082c  67628\n(gdb)\n因此在SPARC架构上编程，一定要留神强制类型转换，务必清楚自己正在干什么，有\n没有隐患。\n2.1 如何理解pstack的输出信息\nQ: 080603a7 main    (1, 80479b8, 80479c0)  + d53\n结尾的d53是什么\nA: Roger A. Faulkner &lt;raf@sunraf.Sun.COM&gt;\n在代码段绝对地址0x080603a7处，main()调用了一个函数，0x080603a7正是\nmain + 0xd53，换句话说，从main()函数开始的0xd53偏移处。\n2.3 Solaris中如何获取一个C程序的调用栈回溯\nQ: 我想在Solaris 2.6及其后续版本上获取一个C程序的调用栈回溯，类似如下输出\n(10)  0x00045e08  integ + 0x408    [./two_brn.e]\n(11)  0x0006468c  trajcem + 0x128  [./two_brn.e]\n(12)  0x00055490  fly_traj + 0xf58 [./two_brn.e]\n(13)  0x0004052c  top_level + 0x14 [./two_brn.e]\n(14)  0x000567e4  _start + 0x34    [./two_brn.e]\n这样我就可以知道当程序崩溃、死锁的时候代码执行到了何处。在HP-UX和IRIX上\n可以利用U_STACK_TRACE()和trace_back_stack_and_print()，Solaris上呢？\nQ: 有没有办法显示当前堆栈中的数据(GNU/Linux系统)？我希望自己的异常处理程序\n在进程结束前dump整个栈区(stack)，以便观察到栈顶是什么函数。对于调试意想\n不到的运行时错误而言，这很重要。\nQ: Is it possible to unwind the stack on Solaris 8? Is there an API that I\ncould use? I know that with TRU64(Digital UNIX) there are the exception\nhandling routines: except_virtual_unwind() and except_capture_context().\nBasically, what I am trying to do is print out the stack on demand,\njust as dbx or gdb would.\nA: Bjorn Reese &lt;breese@mail1.stofanet.dk&gt;\n用/usr/proc/bin/pstack [-F] &lt;pid ...&gt;\n参看这个例子代码，http://home1.stofanet.dk/breese/debug/debug.tar.gz\nQ: is there a way to access call stack information at run time from within\na program?  i‘ve been maintaining my own crude stack using __FUNCTION__\nand linked lists but can‘t help but think there‘s gotta be a better\nway...\nA: Nate Eldredge &lt;neldredge@hmc.edu&gt;\n这依赖于你的系统，如果使用glibc 2.1或更新版本，可以使用backtrace()函数，\n参看&lt;execinfo.h&gt;，其他系统可能有不同的技术支持。\n注意，你所使用的办法可能是唯一能够保证跨平台使用的\nA: Andrew Gabriel &lt;andrew@cucumber.demon.co.uk&gt; Consultant Software Engineer\n下面是一个backtrace()的应用举例，如果你使用Solaris 2.4及其后续版本，那么这\n个例子可以很好的工作。很可能无法工作在64-bit模式下，我没有尝试过，好像\nSolaris 7已经提供了一个类似的演示程序。还可以增加某些功能，我没有时间了。\n/*\n* Produce a stack trace for Solaris systems.\n*\n* Copyright (C) 1995-1998 Andrew Gabriel &lt;andrew@cucumber.demon.co.uk&gt;\n* Parts derived from Usenet postings of Bart Smaalders and Casper Dik.\n*\n*/\n/* ......................................................................... */\n#include &lt;setjmp.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/reg.h&gt;\n#include &lt;sys/frame.h&gt;\n#include &lt;dlfcn.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#if defined(sparc) || defined(__sparc)\n#define FLUSHWIN() asm(\"ta 3\");\n#define FRAME_PTR_INDEX 1\n#define SKIP_FRAMES 0\n#endif\n#if defined(i386) || defined(__i386)\n#define FLUSHWIN()\n#define FRAME_PTR_INDEX 3\n#define SKIP_FRAMES 1\n#endif\n#if defined(ppc) || defined(__ppc)\n#define FLUSHWIN()\n#define FRAME_PTR_INDEX 0\n#define SKIP_FRAMES 2\n#endif\n/* ......................................................................... */\nstatic void print_address ( void * pc )\n{\nDl_info info;\nif ( dladdr( pc, &amp;info ) == 0 )\n{\n/* not found */\nfprintf( stderr, \"***  %s:0x%x\\n\", \"??\", ( unsigned int )pc );\n}\nelse\n{\n/* found */\nfprintf( stderr, \"***  %s:%s+0x%x\\n\", info.dli_fname, info.dli_sname,\n( unsigned int )pc - ( unsigned int )info.dli_saddr );\n}\nreturn;\n}  /* end of print_address */\n/* ......................................................................... */\nstatic int validaddr ( void * addr )\n{\nstatic long pagemask = -1;\nchar        c;\nif ( pagemask == -1 )\n{\npagemask = ~( sysconf( _SC_PAGESIZE ) - 1 );\n}\naddr = ( void * )( ( long )addr &amp; pagemask );\nif ( mincore( ( char * )addr, 1, &amp;c ) == -1 &amp;&amp; errno == ENOMEM )\n{\nreturn 0;  /* invalid */\n}\nelse\n{\nreturn 1;  /* valid */\n}\n}  /* end of validaddr */\n/* ......................................................................... */\n/*\n* this function walks up call stack, calling print_addess\n* once for each stack frame, passing the pc as the argument.\n*/\nstatic void print_stack ( void )\n{\nstruct frame * sp;\njmp_buf        env;\nint            i;\nint *          iptr;\nFLUSHWIN();\nsetjmp( env );\niptr = ( int * )env;\nsp = ( struct frame * )iptr[ FRAME_PTR_INDEX ];\nfor ( i = 0; i &lt; SKIP_FRAMES &amp;&amp; sp; i++ )\n{\nif ( !validaddr( sp ) || !validaddr( &amp;sp-&gt;fr_savpc ) )\n{\nfprintf( stderr, \"***[stack pointer corrupt]\\n\" );\nreturn;\n}\nsp = ( struct frame * )sp-&gt;fr_savfp;\n}\ni = 100;  /* looping check */\nwhile ( validaddr( sp ) &amp;&amp; validaddr( &amp;sp-&gt;fr_savpc ) &amp;&amp; sp-&gt;fr_savpc &amp;&amp; --i )\n{\nprint_address( ( void * )sp-&gt;fr_savpc );\nsp = ( struct frame * )sp-&gt;fr_savfp;\n}\n}  /* end of print_stack */\n/* ......................................................................... */\nvoid backtrace( void )\n{\nfprintf( stderr, \"***backtrace...\\n\" );\nprint_stack();\nfprintf( stderr, \"***backtrace ends\\n\" );\n}\n/* ......................................................................... */\nQ: 我正在使用Solaris系统，\"uname -a\"显示如下\nSunOS usunnad01 5.8 Generic_108528-14 sun4u sparc SUNW,UltraAX-i2\n假设有如下代码\ncaller_func ()\n{\ncalled_func();\n}\ncalled_func ()\n{\nprintf( \"called_func() is being called from %s\\n\", some_magic_func() );\n}\n我期待着这样的执行输出\n\"called_func() is being called from caller_func()\"\n请问如何实现some_magic_func()，C或者汇编语言编程都可以。\nD: Paul Pluzhnikov &lt;ppluzhnikov@earthlink.net&gt;\n看看mpatrol的源代码，其中有traceback()函数可以给出整个调用栈回溯，而不仅仅\n是主调函数。\nD: Peter Ammon &lt;pa44@cornell.edu&gt;\n可以考虑使用宏，这是一个例子\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -g -o test test.c\n*/\n#include &lt;stdio.h&gt;\n#define CALL(x) (printf(\"Calling %s from %s\\n\", #x, __FUNCTION__), x)\nint main ( void )\n{\nchar buf[64];\nwhile ( CALL( fgets( buf, sizeof( buff ), stdin ) ) != NULL )\n{\nCALL( puts( buf ) );\n}\nreturn( 0 );\n}\n--------------------------------------------------------------------------\nA: Sun Microsystems 2000-06-13\n下面演示如何编程获取当前运行中线程调用栈回溯。惟一要做的就是在应用程序中调\n用csprintstack()，记得链接库选项-ldl。\n--------------------------------------------------------------------------\n/*\n* For SPARC/Solaris 8\n* gcc -D__sparc -Wall -pipe -g -o test test.c -ldl\n*\n* For x86/Solaris 9\n* gcc -D__i386 -Wall -pipe -g -o test test.c -ldl\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;ucontext.h&gt;\n#include &lt;dlfcn.h&gt;\n#include &lt;setjmp.h&gt;\n#include &lt;sys/frame.h&gt;\n#include &lt;sys/procfs_isa.h&gt;\n#if defined(sparc) || defined(__sparc)\n#define FRAME_PTR_REGISTER REG_SP\n#endif\n#if defined(i386) || defined(__i386)\n#define FRAME_PTR_REGISTER EBP\n#endif\nstruct frame * csgetframeptr ( void )\n{\nucontext_t u;\n( void )getcontext( &amp;u );\nreturn( ( struct frame * )( ( struct frame * )u.uc_mcontext.gregs[FRAME_PTR_REGISTER] )-&gt;fr_savfp );\n}  /* end of csgetframeptr */\nvoid cswalkstack ( struct frame *fp, int ( *operate_func ) ( void *, void * ), void *usrarg )\n{\nvoid *savpc;\nwhile ( fp &amp;&amp; ( savpc = ( void * )fp-&gt;fr_savpc )\n&amp;&amp; ( *operate_func )( savpc, usrarg ) == 0 )\n{\nfp = ( void * )fp-&gt;fr_savfp;\n}\n}  /* end of cswalkstack */\nstatic int csprintaddress ( void *pc, void *usrarg )\n{\nDl_info  info;\nchar    *func;\nchar    *lib;\nif ( dladdr( pc, &amp;info ) == 0 )\n{\nfunc = \"??\";\nlib  = \"??\";\n}\nelse\n{\nlib  = ( char * )info.dli_fname;\nfunc = ( char * )info.dli_sname;\n}\nfprintf( ( FILE * )usrarg, \"%s:%s+0x%x\\n\", lib, func,\n( unsigned int )pc - ( unsigned int )info.dli_saddr );\nreturn( 0 );\n}  /* end of csprintaddress */\nvoid csprintstack ( FILE *f )\n{\ncswalkstack( csgetframeptr(), csprintaddress, ( void * )f );\n}  /* end of csprintstack */\nvoid call_2 ( void )\n{\ncsprintstack( stderr );\n}  /* end of call_2 */\nvoid call_1 ( void )\n{\ncall_2();\n}  /* end of call_1 */\nvoid call_0 ( void )\n{\ncall_1();\n}  /* end of call_0 */\nint main ( void )\n{\ncall_0();\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n[scz@ /export/home/scz/src]&gt; gcc -D__sparc -Wall -pipe -g -o test test.c -ldl\n[scz@ /export/home/scz/src]&gt; ./test\ntest:call_2+0xc\ntest:call_1+0x4\ntest:call_0+0x4\ntest:main+0x4\ntest:_start+0x5c\n[scz@ /export/home/scz/src]&gt;\n[scz@ /export/home/scz/src]&gt; gcc -D__i386 -Wall -pipe -g -o test test.c -ldl\n[scz@ /export/home/scz/src]&gt; ./test\n/export/home/scz/src/test:call_2+0x13\n/export/home/scz/src/test:call_1+0xb\n/export/home/scz/src/test:call_0+0xb\n/export/home/scz/src/test:main+0x15\n/export/home/scz/src/test:_start+0x5d\n[scz@ /export/home/scz/src]&gt;\n2.4 如何编程获取栈底地址\nQ: 虽然很多操作系统的用户进程栈底地址固定，但是我需要写一个可广泛移植C程序\n获取这个栈底地址。\nA: tt &lt;warning3@nsfocus.com&gt; 2001-06-02 19:40\n假设堆栈(stack)向低地址方向增长，则所谓栈底指堆栈(stack)最高地址\nx86/Linux           栈底是0xc0000000 (栈底往低地址的4个字节总是零)\nSPARC/Solaris 7/8   栈底是0xffbf0000 (栈底往低地址的4个字节总是零)\nSPARC/Solaris 2.6   栈底是0xf0000000 (栈底往低地址的4个字节总是零)\nx86/Solaris 8       栈底是0x08048000\nx86/FreeBSD         栈底是0xbfc00000 (栈底往低地址的4个字节总是零)\nx86/NetBSD 1.5      栈底是0xbfbfe000\nx86/OpenBSD 2.8/3.0 栈底是0xdfbfe000\nD: jonah\n对于NetBSD 1.5，栈底是0xbfc00000。根据源码，最高用户地址是0xbfbfe000，因为\n最后4MB(2^22)的最后两页(0x2000字节，一页4096字节)保留用做U区，但是目前不再\n使用这块内存。因此，0xbfbfe000才是真正的栈底。\ntt在OpenBSD 2.8上测试结果，栈底是0xdfbfe000，注意和NetBSD 1.5相差很大。\nA: tt &lt;warning3@nsfocus.com&gt;\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o gstack gstack.c\n*\n* A simple example to get the current stack bottom address\n* warning3 &lt;warning3@nsfocus.com&gt;\n* 2001-06-01\n*\n* Modified by scz &lt;scz@nsfocus.com&gt;\n* 2001-06-02\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;setjmp.h&gt;\ntypedef void Sigfunc ( int );  /* for signal handlers */\nSigfunc * signal           ( int signo, Sigfunc * func );\nstatic Sigfunc * Signal           ( int signo, Sigfunc * func );\nstatic char    * get_stack_bottom ( void );\nstatic void      segfault         ( int signo );\nstatic sigjmp_buf             jmpbuf;\nstatic volatile sig_atomic_t  canjump = 0;\nstatic Sigfunc               *seg_handler;\nstatic Sigfunc               *bus_handler;  /* for xxxBSD */\nSigfunc * signal ( int signo, Sigfunc * func )\n{\nstruct sigaction act, oact;\nact.sa_handler = func;\nsigemptyset( &amp;act.sa_mask );\nact.sa_flags   = 0;\nif ( sigaction( signo, &amp;act, &amp;oact ) &lt; 0 )\n{\nreturn( SIG_ERR );\n}\nreturn( oact.sa_handler );\n}  /* end of signal */\nstatic Sigfunc * Signal ( int signo, Sigfunc * func )  /* for our signal() function */\n{\nSigfunc * sigfunc;\nif ( ( sigfunc = signal( signo, func ) ) == SIG_ERR )\n{\nexit( EXIT_FAILURE );\n}\nreturn( sigfunc );\n}  /* end of Signal */\nstatic char * get_stack_bottom ( void )\n{\nvolatile char *c;  /* for autovar, must be volatile */\nseg_handler = Signal( SIGSEGV, segfault );\nbus_handler = Signal( SIGBUS, segfault );\nc           = ( char * )&amp;c;\nif ( sigsetjmp( jmpbuf, 1 ) != 0 )\n{\nSignal( SIGSEGV, seg_handler );\nSignal( SIGBUS, bus_handler );\nreturn( ( char * )c );\n}\ncanjump = 1;  /* now sigsetjump() is OK */\nwhile ( 1 )\n{\n*c = *c;\nc++;\n}\nreturn( NULL );\n}  /* end of get_stack_bottom */\nstatic void segfault ( int signo )\n{\nif ( canjump == 0 )\n{\nreturn;  /* unexpected signal, ignore */\n}\ncanjump = 0;\nsiglongjmp( jmpbuf, signo );  /* jump back to main, don‘t return */\n}  /* end of segfault */\nint main ( int argc, char * argv[] )\n{\nfprintf( stderr, \"Current stack bottom is 0x%08x\\n\",\n( unsigned int )get_stack_bottom() );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nD: scz &lt;scz@nsfocus.com&gt; 2001-06-03 00:38\nW. Richard Stevens在&lt;&lt;Advanced Programming in the UNIX Environment&gt;&gt;中详细\n介绍了setjmp/longjmp以及sigsetjmp/siglongjmp函数。\n这个程序的原理很简单，不断向栈底方向取值，越过栈底的地址访问会导致SIGSEGV\n信号，然后利用长跳转回到主流程报告当前c值，自然对应栈底。\ntt测试表明，在x86/FreeBSD中导致SIGBUS信号。据jonah报告，不仅仅是FreeBSD，\nNetBSD 以及 OpenBSD 系统中上述程序越界访问也导致SIGBUS信号，而不是SIGSEGV\n信号。\n非局部转移，比如函数间转移的时候考虑使用setjmp/longjmp。但是如果涉及到信号\n句柄与主流程之间的转移，就不能使用longjmp了。当捕捉到信号进入信号句柄，此\n时当前信号被自动加入进程的信号屏蔽字中，阻止后来产生的这种信号干扰此信号句\n柄。如果用longjmp跳出信号句柄，此时进程的信号屏蔽字状态未知，有些系统做了\n保存恢复，有些系统没有做，比如x86/Linux Kernel 2.4.7-10的setjmp/longjmp没\n有做信号屏蔽字的保存恢复。根据POSIX.1，此时应该使用sigsetjmp/siglongjmp函\n数。下面是来自SPARC/Solaris 7的setjmp(3C)\n--------------------------------------------------------------------------\n#include &lt;setjmp.h&gt;\nint  setjmp     ( jmp_buf env );\nint  sigsetjmp  ( sigjmp_buf env, int savemask );\nvoid longjmp    ( jmp_buf env, int val );\nvoid siglongjmp ( sigjmp_buf env, int val );\n--------------------------------------------------------------------------\n如果savemask非0，sigsetjmp在env中保存进程当前信号屏蔽字，相应siglongjmp回\n来的时候从env中恢复信号屏蔽字。\n数据类型sig_atomic_t由ANSI C定义，在写时不会被中断。它意味着这种变量在具有\n虚存的系统上不会跨越页边界，可以用一条机器指令对其存取。这种类型的变量总是\n与ANSI类型修饰符volatile一并出现，防止编译器优化带来的不确定状态。\n在longjmp/siglongjmp中，全局、静态变量保持不变，声明为volatile的自动变量也\n保持不变。\n无论是否使用了编译优化开关，为了保证广泛兼容性，都应该在get_stack_bottom()\n中声明c为volatile变量。\n注意这里，必须使用长跳转，而不能从信号句柄中直接返回。因为导致信号SIGSEGV、\nSIGBUS分发的语句始终存在，直接从信号句柄中返回主流程，将回到引发信号的原指\n令处，而不是下一条指令(把这种情况理解成异常，而不是中断)，于是立即导致下一\n次信号分发，出现广义上的死循环，所谓程序僵住。可以简单修改上述程序，不利用\n长跳转，简单对一个全局变量做判断决定是否继续循环递增c，程序最终僵住；如果\n在信号句柄中输出调试信息，很容易发现这个广义上的无限循环。\nD: scz &lt;scz@nsfocus.com&gt; 2001-06-03 00:40\n在x86/Linux系统中用如下命令可以确定栈区所在\n# cat /proc/1/maps  &lt;-- 观察1号进程init\n... ...\nbfffe000-c0000000 rwxp fffff000 00:00 0\n#\n在SPARC/Solaris 7中用/usr/proc/bin/pmap命令确定栈区所在\n# /usr/proc/bin/pmap 1  &lt;-- 观察1号进程init\n... ...\nFFBEC000     16K read/write/exec     [ stack ]\n#\n16KB == 0x4000，0xFFBEC000 + 0x4000 == 0xFFBF0000\n与前面tt介绍的\nSPARC/Solaris 7/8 栈底是0xffbf0000( 栈底往低地址的4个字节总是零 )\n相符合。\n此外，在SPARC/Solaris 7下，可以这样验证之\n# /usr/ccs/bin/nm -nx /dev/ksyms | grep \"|_userlimit\"\n[7015]  |0x0000100546f8|0x000000000008|OBJT |GLOB |0    |ABS    |_userlimit\n[8051]  |0x000010054700|0x000000000008|OBJT |GLOB |0    |ABS    |_userlimit32\n# echo \"_userlimit /J\" | adb -k /dev/ksyms /dev/mem\nphysmem 3b72\n_userlimit:\n_userlimit:     ffffffff80000000\n# skd64 0x000010054700 8\nbyteArray [ 8 bytes ] ----&gt;\n0000000000000000  00 00 00 00 FF BF 00 00\n#                             ~~~~~~~~~~~ 对于32-bit应用程序来说，这是用户\n空间上限\n如果编译64-bit应用程序，用户空间上限是_userlimit，也就是0xffffffff80000000\n# /opt/SUNWspro/SC5.0/bin/cc -xarch=v9 -O -o gstack gstack.c\n# ./gstack\nCurrent stack bottom is at 0xffffffff80000000\n#\n对于SPARC/Solaris 2.6 32-bit kernel mode\n# echo \"_userlimit /X\" | adb -k /dev/ksyms /dev/mem\nphysmem 3d24\n_userlimit:\n_userlimit:     f0000000\n#\nQ: 在x86/Linux平台上如何定位栈区(stack)的栈底(高址)与栈顶(低址)位置。\nD: \"Andrew Gabriel\" &lt;andrew@cucumber.demon.co.uk&gt;\n试试getcontext(2)\nA: \"Shaun Clowes\" &lt;delius@zero.spam.progsoc.org&gt;\n检查/proc/&lt;pid&gt;/stat，其中有两个域对应栈底(非页对齐的)与栈顶。\n如果使用getcontext(2)，可以通过struct ucontext的uc_mcontext成员获取栈顶位\n置，参看/usr/include/sys/ucontext.h。不幸的是此时uc_stack成员未被设置，无\n法简单获取栈底位置，至少对于我所检测的版本而言，Redhat 2.4.18-3smp kernel\nwith glibc 2.2.5。\n2.5 如何得到一个运行中进程的内存映像\nA: Sun Microsystems 1998-03-30\n有些时候必须得到一个运行中进程的内存映像而不能停止该进程，Solaris系统了这\n样的工具，gcore为运行中进程创建一个core文件。假设我的bash进程号是5347\n# gcore 5347\ngcore: core.5347 dumped\n# file core.5347\ncore.5347:      ELF 32-位 MSB core文件 SPARC 版本 1，来自‘bash‘\n#\n注意，只能获取属主是你自己的进程的内存映像，除非你是root。\n2.6 调试器如何工作的\nQ: 我想在一个自己编写的程序中单步运行另外一个程序，换句话说，那是一个调试\n器，该如何做？\nA: Erik de Castro Lopo &lt;nospam@mega-nerd.com&gt;\n这是一个操作系统相关的问题。最一般的回答是使用ptrace()系统调用，尽管我\n不确认究竟这有多么普遍。Linux man手册上说SVr4、SVID EXT、AT&amp;T、X/OPEN\n和BSD 4.3都支持它。\n为了使用ptrace()，你的程序应该调用fork()，然后在子进程中做如下调用：\nptrace( PTRACE_TRACEME, 0, 0, 0 );\n接下来调用exec()家族的函数执行你最终企图跟踪的程序。\n为了单步进入子进程，在父进程中调用：\nptrace( PTRACE_SINGLESTEP, 0, 0, 0 );\n还有一些其他函数做恢复/设置寄存器、内存变量一类的工作。\nGDB的源代码足以回答这个问题。\n2.7 x86/Linux上如何处理SIGFPE信号\nQ: 参看如下程序\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o sigfpe_test_0 sigfpe_test_0.c\n*\n* 注意与下面的编译效果进行对比，去掉优化开关-O3\n*\n* gcc -Wall -pipe -o sigfpe_test_0 sigfpe_test_0.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;setjmp.h&gt;\n/*\n* for signal handlers\n*/\ntypedef void Sigfunc ( int );\nSigfunc * signal ( int signo, Sigfunc *func );\nstatic Sigfunc * Signal ( int signo, Sigfunc *func );\nstatic void      on_fpe ( int signo );\nSigfunc * signal ( int signo, Sigfunc *func )\n{\nstruct sigaction act, oact;\nact.sa_handler = func;\nsigemptyset( &amp;act.sa_mask );\nact.sa_flags   = 0;\nif ( signo == SIGALRM )\n{\n#ifdef  SA_INTERRUPT\nact.sa_flags |= SA_INTERRUPT;  /* SunOS 4.x */\n#endif\n}\nelse\n{\n#ifdef  SA_RESTART\nact.sa_flags |= SA_RESTART;  /* SVR4, 44BSD */\n#endif\n}\nif ( sigaction( signo, &amp;act, &amp;oact ) &lt; 0 )\n{\nreturn( SIG_ERR );\n}\nreturn( oact.sa_handler );\n}  /* end of signal */\nstatic Sigfunc * Signal ( int signo, Sigfunc *func )\n{\nSigfunc *sigfunc;\nif ( ( sigfunc = signal( signo, func ) ) == SIG_ERR )\n{\nperror( \"signal\" );\nexit( EXIT_FAILURE );\n}\nreturn( sigfunc );\n}  /* end of Signal */\nstatic void on_fpe ( int signo )\n{\nfprintf( stderr, \"here is on_fpe\\n\" );\nreturn;\n}  /* end of on_fpe */\nint main ( int argc, char * argv[] )\n{\nunsigned int i;\nSignal( SIGFPE, on_fpe );\ni = 51211314 / 0;\n/*\n* 另外，增加这行后，再次对比有-O3和无-O3的效果\n*\n* fprintf( stderr, \"i = %#X\\n\", i );\n*/\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n有-O3、无-O3，以及有无最后那条fprintf()语句，效果上有差别，自行对比。如果\n输出\"here is on_fpe\"，则会发现永不停止。\nD: 小四 &lt;scz@nsfocus.com&gt; 2001-12-14 18:25\n在上述代码中，on_fpe()直接返回了，再次触发除零错，所以无休止输出。事实上在\n所有的计算器处理程序中，都会对SIGFPE信号做相应处理，前些日子看yacc/lex的时\n候又碰上过。正确的做法是，利用远跳转转移，让开触发除零错的代码。\n代码修改如下\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o sigfpe_test_1 sigfpe_test_1.c\n*\n* 注意与下面的编译效果进行对比，去掉优化开关-O3\n*\n* gcc -Wall -pipe -o sigfpe_test_1 sigfpe_test_1.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;setjmp.h&gt;\n/*\n* for signal handlers\n*/\ntypedef void Sigfunc ( int );\nSigfunc * signal ( int signo, Sigfunc *func );\nstatic Sigfunc * Signal ( int signo, Sigfunc *func );\nstatic void      on_fpe ( int signo );\nstatic sigjmp_buf             jmpbuf;\nstatic volatile sig_atomic_t  canjump = 0;\nSigfunc * signal ( int signo, Sigfunc *func )\n{\nstruct sigaction act, oact;\nact.sa_handler = func;\nsigemptyset( &amp;act.sa_mask );\nact.sa_flags   = 0;\nif ( signo == SIGALRM )\n{\n#ifdef  SA_INTERRUPT\nact.sa_flags |= SA_INTERRUPT;  /* SunOS 4.x */\n#endif\n}\nelse\n{\n#ifdef  SA_RESTART\nact.sa_flags |= SA_RESTART;  /* SVR4, 44BSD */\n#endif\n}\nif ( sigaction( signo, &amp;act, &amp;oact ) &lt; 0 )\n{\nreturn( SIG_ERR );\n}\nreturn( oact.sa_handler );\n}  /* end of signal */\nstatic Sigfunc * Signal ( int signo, Sigfunc *func )\n{\nSigfunc *sigfunc;\nif ( ( sigfunc = signal( signo, func ) ) == SIG_ERR )\n{\nperror( \"signal\" );\nexit( EXIT_FAILURE );\n}\nreturn( sigfunc );\n}  /* end of Signal */\nstatic void on_fpe ( int signo )\n{\nif ( canjump == 0 )\n{\nreturn;  /* unexpected signal, ignore */\n}\ncanjump = 0;\nfprintf( stderr, \"here is on_fpe\\n\" );\nsiglongjmp( jmpbuf, signo );  /* jump back to main, don‘t return */\nreturn;\n}  /* end of on_fpe */\nint main ( int argc, char * argv[] )\n{\nunsigned int i;\nif ( sigsetjmp( jmpbuf, 1 ) != 0 )\n{\nfprintf( stderr, \"c u later\\n\" );\nreturn( EXIT_SUCCESS );\n}\n/*\n* now sigsetjump() is OK\n*/\ncanjump = 1;\nSignal( SIGFPE, on_fpe );\ni = 51211314 / 0;\n/*\n* 另外，增加这行后，再次对比有-O3和无-O3的效果\n*\n* fprintf( stderr, \"i = %#X\\n\", i );\n*/\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n关于-O3的讨论，对gcc编译器熟悉的朋友请继续，呵，我对Linux下的这此东西，实\n在缺乏兴趣。\n2.8 GDB调试时没有符号表，如何设置断点\nQ: 在OpenBSD 3.0下想用gdb跟踪/usr/bin/skeyaudit(一个setuid-to-root程序)，\n却因没有符号表无法设置断点\nA: tt &lt;warning3@nsfocus.com&gt;\n# objdump -f /usr/bin/skeyaudit\nstart address 0x00001020\n# gdb /usr/bin/skeyaudit\n(gdb) x/50i 0x1020\n0x1020: push   %ebp  &lt;-- 这是start\n0x1021: mov    %esp,%ebp\n0x1023: sub    $0xc,%esp\n0x1026: push   %edi\n0x1027: push   %esi\n0x1028: push   %ebx\n0x1029: lea    0x4(%ebp),%esi\n0x102c: lea    0x4(%esi),%edi\n0x102f: mov    (%esi),%eax\n0x1031: shl    $0x2,%eax\n0x1034: lea    0x4(%eax,%edi,1),%eax\n0x1038: mov    %eax,0x33f8\n0x103d: mov    0x4(%esi),%ebx\n0x1040: test   %ebx,%ebx\n0x1042: je     0x106a\n0x1044: add    $0xfffffff8,%esp\n0x1047: push   $0x2f\n0x1049: push   %ebx\n0x104a: call   0x1774  &lt;-- 这是一个错误处理入口\n0x104f: mov    %eax,0x3190\n0x1054: add    $0x10,%esp\n0x1057: test   %eax,%eax\n0x1059: jne    0x1064\n0x105b: mov    %ebx,0x3190\n0x1061: jmp    0x106a\n0x1063: nop\n0x1064: inc    %eax\n0x1065: mov    %eax,0x3190\n0x106a: movl   $0x3000,0xfffffffc(%ebp)\n0x1071: mov    0xfffffffc(%ebp),%eax\n0x1074: mov    0xfffffffc(%ebp),%eax\n0x1077: test   %eax,%eax\n0x1079: je     0x108b\n0x107b: add    $0xfffffff4,%esp\n0x107e: push   $0x3000\n0x1083: call   0x1150\n0x1088: add    $0x10,%esp\n0x108b: sub    $0x10,%esp\n0x108e: pushl  0x33f8  &lt;-- 可以先在OpenBSD用gcc编译一个带符号表的程序，找\n0x1094: push   %edi        出这种汇编指令特征\n0x1095: pushl  (%esi)\n0x1097: call   0x1840  &lt;-- 这就是main\n0x109c: push   %eax\n0x109d: call   0x307c\n0x10a2: pop    %ecx\n0x10a3: pop    %eax\n0x10a4: push   %ecx\n---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---(Ctrl-C)Quit\n(gdb) x/20i 0x1840  &lt;-- 这里不能用disas，因为没有符号表\n0x1840: push   %ebp\n0x1841: mov    %esp,%ebp\n0x1843: sub    $0x13c,%esp\n0x1849: push   %edi\n0x184a: push   %esi\n0x184b: push   %ebx\n0x184c: mov    0x8(%ebp),%ebx\n0x184f: mov    0xc(%ebp),%edi\n0x1852: call   0x205c\n0x1857: movl   $0x0,0xfffffee0(%ebp)\n0x1861: movl   $0x0,0xfffffedc(%ebp)\n0x186b: movl   $0x0,0xfffffed8(%ebp)\n0x1875: movl   $0x0,0xfffffed4(%ebp)\n0x187f: movl   $0xc,0xfffffed0(%ebp)\n0x1889: call   0x314c\n0x188e: test   %eax,%eax\n0x1890: je     0x18a4\n0x1892: add    $0xfffffff8,%esp\n0x1895: push   $0x1798\n0x189a: push   $0x1\n(gdb) (gdb) b *0x1840\nBreakpoint 1 at 0x1840\n(gdb) r\nStarting program: /usr/bin/skeyaudit\nBreakpoint 1, 0x1840 in ?? ()\n(gdb) x/20i $pc\n(gdb) q\nThe program is running.  Quit anyway (and kill it)? (y or n) y\n#\n3. -lelf、-lkvm、-lkstat相关问题\n3.1 如何判断可执行文件是否携带了调试信息\nQ: 某些时候需要知道编译可执行文件时是否携带了调试信息(比如是否指定了-g编译\n选项)。检查可执行文件中是否包含\".stab\" elf section，\".stab\" section用于\n保存相关调试信息。\nA: Sun Microsystems 2000-05-15\n下面这个脚本演示如何判断可执行文件是否携带调试信息\n--------------------------------------------------------------------------\n#! /bin/sh\n#\n# Script that test whether or not a given file has been built for\n# debug (-g option specified in the compilation)\nif [ $# -le 0 ]\nthen\necho \"Usage: $0 &lt;filename&gt;\"\nexit 1\nfi\nif [ ! -f $1 ]\nthen\necho \"File $1 does not exist\"\nexit 1\nfi\n/usr/ccs/bin/dump -hv $1 | /bin/egrep -s ‘.stab$‘\nif [ $? -eq 0 ]\nthen\necho \"File ‘$1‘ has been built for debug\"\nexit 0\nelse\necho \"File ‘$1‘ has not been built for debug\"\nexit 1\nfi\n--------------------------------------------------------------------------\n如果对ELF文件格式不熟悉，理解上述代码可能有点困难，参看\nhttp://www.digibel.org/~tompy/hacking/elf.txt，这是1.1版的ELF文件格式规范。\n3.2 mprotect如何用\nA: 小四 &lt;scz@nsfocus.com&gt;\n# truss prtconf 2&gt;&amp;1 | grep sysconf\nsysconfig(_CONFIG_PAGESIZE)                     = 8192\nsysconfig(_CONFIG_PHYS_PAGES)                   = 16384\n#\n由此可知当前系统页尺寸是8192字节。\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -g -static -o mtest mtest.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;sys/mman.h&gt;\nint main ( int argc, char * argv[] )\n{\nchar *buf;\nchar  c;\n/*\n* 分配一块内存，拥有缺省的rw-保护\n*/\nbuf = ( char * )malloc( 1024 + 8191 );\nif ( !buf )\n{\nperror( \"malloc\" );\nexit( errno );\n}\n/*\n* Align to a multiple of PAGESIZE, assumed to be a power of two\n*/\nbuf     = ( char * )( ( ( unsigned int )buf + 8191 ) &amp; ~8191 );\nc       = buf[77];\nbuf[77] = c;\nprintf( \"ok\\n\" );\n/*\n* Mark the buffer read-only.\n*\n* 必须保证这里buf位于页边界上，否则mprotect()失败，报告无效参数\n*/\nif ( mprotect( buf, 1024, PROT_READ ) )\n{\nperror( \"\\nmprotect\" );\nexit( errno );\n}\nc       = buf[77];\n/*\n* Write error, program dies on SIGSEGV\n*/\nbuf[77] = c;\nexit( 0 );\n}  /* end of main */\n--------------------------------------------------------------------------\n$ ./mtest\nok\n段错误 (core dumped)  &lt;-- 内存保护起作用了\n$\n3.3 mmap如何用\nA: 小四 &lt;scz@nsfocus.com&gt;\n下面写一个完成文件复制功能的小程序，利用mmap(2)，而不是标准文件I/O接口。\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o copy_mmap copy_mmap.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;  /* for memcpy */\n#include &lt;strings.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#define PERMS 0600\nint main ( int argc, char * argv[] )\n{\nint          src, dst;\nvoid        *sm, *dm;\nstruct stat  statbuf;\nif ( argc != 3 )\n{\nfprintf( stderr, \" Usage: %s &lt;source&gt; &lt;target&gt;\\n\", argv[0] );\nexit( EXIT_FAILURE );\n}\nif ( ( src = open( argv[1], O_RDONLY ) ) &lt; 0 )\n{\nperror( \"open source\" );\nexit( EXIT_FAILURE );\n}\n/*\n* 为了完成复制，必须包含读打开，否则mmap()失败\n*/\nif ( ( dst = open( argv[2], O_RDWR | O_CREAT | O_TRUNC, PERMS ) ) &lt; 0 )\n{\nperror( \"open target\" );\nexit( EXIT_FAILURE );\n}\nif ( fstat( src, &amp;statbuf ) &lt; 0 )\n{\nperror( \"fstat source\" );\nexit( EXIT_FAILURE );\n}\n/*\n* 参看前面man手册中的说明，mmap()不能用于扩展文件长度。所以这里必须事\n* 先扩大目标文件长度，准备一个空架子等待复制。\n*/\nif ( lseek( dst, statbuf.st_size - 1, SEEK_SET ) &lt; 0 )\n{\nperror( \"lseek target\" );\nexit( EXIT_FAILURE );\n}\nif ( write( dst, &amp;statbuf, 1 ) != 1 )\n{\nperror( \"write target\" );\nexit( EXIT_FAILURE );\n}\n/*\n* 读的时候指定 MAP_PRIVATE 即可\n*/\nsm = mmap( 0, ( size_t )statbuf.st_size, PROT_READ,\nMAP_PRIVATE | MAP_NORESERVE, src, 0 );\nif ( MAP_FAILED == sm )\n{\nperror( \"mmap source\" );\nexit( EXIT_FAILURE );\n}\n/*\n* 这里必须指定 MAP_SHARED 才可能真正改变静态文件\n*/\ndm = mmap( 0, ( size_t )statbuf.st_size, PROT_WRITE,\nMAP_SHARED, dst, 0 );\nif ( MAP_FAILED == dm )\n{\nperror( \"mmap target\" );\nexit( EXIT_FAILURE );\n}\nmemcpy( dm, sm, ( size_t )statbuf.st_size );\n/*\n* 可以不要这行代码\n*\n* msync( dm, ( size_t )statbuf.st_size, MS_SYNC );\n*/\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nmmap()好处是处理大文件时速度明显快于标准文件I/O，无论读写，都少了一次用户\n空间与内核空间之间的复制过程。操作内存还便于设计、优化算法。\n文件I/O操作/proc/self/mem不存在页边界对齐的问题。至少Linux的mmap()的最后一\n个形参offset并未强制要求页边界对齐，如果提供的值未对齐，系统自动向上舍入到\n页边界上。\nmalloc()分配得到的地址不见得对齐在页边界上。\n/proc/self/mem和/dev/kmem不同。root用户打开/dev/kmem就可以在用户空间访问到\n内核空间的数据，包括偏移0处的数据，系统提供了这样的支持。\n显然代码段经过/proc/self/mem可写映射后已经可写，无须mprotect()介入。\nD: scz &lt;scz@nsfocus.com&gt;\nSolaris 2.6下参看getpagesize(3C)手册页，关于如何获取页大小，一般是8192。\nLinux下参看getpagesize(2)手册页，一般是4096。\n3.4 getrusage如何用\nA: 小四 &lt;scz@nsfocus.com&gt;\n在SPARC/Solaris 2.6/7下结论一致，只支持了ru_utime和ru_stime成员，其他成员\n被设置成0。修改头文件后在FreeBSD 4.3-RELEASE上测试，则不只支持ru_utime和\nru_stime成员。从FreeBSD的getrusage(2)手册页可以看到，这个函数源自4.2 BSD。\n如此来说，至少对于SPARC/Solaris 2.6/7，getrusage(3C)并无多大意义。\n3.5 setitimer如何用\nD: scz &lt;scz@nsfocus.com&gt;\n为什么要学习使用setitimer(2)，因为alarm(3)属于被淘汰的定时器技术。\nA: 小四 &lt;scz@nsfocus.com&gt;\n下面是个x86/FreeBSD 4.3-RELEASE下的例子\n--------------------------------------------------------------------------\n/*\n* File     : timer_sample.c\n* Author   : Unknown (Don‘t ask me anything about this program)\n* Complie  : gcc -Wall -pipe -O3 -o timer_sample timer_sample.c\n* Platform : x86/FreeBSD 4.3-RELEASE\n* Date     : 2001-09-18 15:18\n*/\n/************************************************************************\n*                                                                      *\n*                               Head File                              *\n*                                                                      *\n************************************************************************/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;signal.h&gt;\n/************************************************************************\n*                                                                      *\n*                               Macro                                  *\n*                                                                      *\n************************************************************************/\n/*\n* for signal handlers\n*/\ntypedef void Sigfunc ( int );\n/************************************************************************\n*                                                                      *\n*                            Function Prototype                        *\n*                                                                      *\n************************************************************************/\nstatic void      Atexit       ( void ( *func ) ( void ) );\nstatic void      init_signal  ( void );\nstatic void      init_timer   ( void );\nstatic void      on_alarm     ( int signo );\nstatic void      on_terminate ( int signo );\nstatic int       Setitimer    ( int which, const struct itimerval *value,\nstruct itimerval *ovalue );\nSigfunc * signal       ( int signo, Sigfunc *func );\nstatic Sigfunc * Signal       ( int signo, Sigfunc *func );\nstatic void      terminate    ( void );\n/************************************************************************\n*                                                                      *\n*                            Static Global Var                         *\n*                                                                      *\n************************************************************************/\n/************************************************************************/\nstatic void Atexit ( void ( *func ) ( void ) )\n{\nif ( atexit( func ) != 0 )\n{\nperror( \"atexit\" );\nexit( EXIT_FAILURE );\n}\nreturn;\n}  /* end of Atexit */\n/*\n* 初始化信号句柄\n*/\nstatic void init_signal ( void )\n{\nint i;\nAtexit( terminate );\nfor ( i = 1; i &lt; 9; i++ )\n{\nSignal( i, on_terminate );\n}\nSignal( SIGTERM, on_terminate );\nSignal( SIGALRM, on_alarm );\nreturn;\n}  /* end of init_signal */\nstatic void init_timer ( void )\n{\nstruct itimerval value;\nvalue.it_value.tv_sec  = 1;\nvalue.it_value.tv_usec = 0;\nvalue.it_interval      = value.it_value;\nSetitimer( ITIMER_REAL, &amp;value, NULL );\nreturn;\n}  /* end of init_timer */\nstatic void on_alarm ( int signo )\n{\nstatic int count = 0;\n/*\n* 演示用，这很危险\n*/\nfprintf( stderr, \"count = %u\\n\", count++ );\nreturn;\n}\nstatic void on_terminate ( int signo )\n{\n/*\n* 这次我们使用atexit()函数\n*/\nexit( EXIT_SUCCESS );\n}  /* end of on_terminate */\nstatic int Setitimer ( int which, const struct itimerval *value,\nstruct itimerval *ovalue )\n{\nint ret;\nif ( ( ret = setitimer( which, value, ovalue ) ) &lt; 0 )\n{\nperror( \"setitimer error\" );\nexit( EXIT_FAILURE );\n}\nreturn( ret );\n}  /* end of Setitimer */\nSigfunc * signal ( int signo, Sigfunc *func )\n{\nstruct sigaction act, oact;\nact.sa_handler = func;\nsigemptyset( &amp;act.sa_mask );\nact.sa_flags   = 0;\nif ( signo == SIGALRM )\n{\n#ifdef  SA_INTERRUPT\nact.sa_flags |= SA_INTERRUPT;  /* SunOS 4.x */\n#endif\n}\nelse\n{\n#ifdef  SA_RESTART\nact.sa_flags |= SA_RESTART;  /* SVR4, 44BSD */\n#endif\n}\nif ( sigaction( signo, &amp;act, &amp;oact ) &lt; 0 )\n{\nreturn( SIG_ERR );\n}\nreturn( oact.sa_handler );\n}  /* end of signal */\nstatic Sigfunc * Signal ( int signo, Sigfunc *func )\n{\nSigfunc *sigfunc;\nif ( ( sigfunc = signal( signo, func ) ) == SIG_ERR )\n{\nperror( \"signal\" );\nexit( EXIT_FAILURE );\n}\nreturn( sigfunc );\n}  /* end of Signal */\nstatic void terminate ( void )\n{\nfprintf( stderr, \"\\n\" );\nreturn;\n}  /* end of terminate */\nint main ( int arg, char * argv[] )\n{\ninit_signal();\ninit_timer();\nwhile ( 1 )\n{\n/*\n* 形成阻塞，降低CPU占用率\n*/\ngetchar();\n}\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n/************************************************************************/\n--------------------------------------------------------------------------\nD: scz &lt;scz@nsfocus.com&gt;\n讨论一个问题。getchar()的作用是降低CPU占用率，可用top命令查看。\ntimer_sample.c中换用ITIMER_PROF/SIGPROF后，你会发现上述程序无输出，我据此\n认为getchar()形成的阻塞不计算在进程虚拟时钟中，也不认为系统正在为进程利益\n而运行。\n如果进一步将getchar()去掉，直接一个while()无限循环，即使换用\nITIMER_PROF/SIGPROF，程序还是有输出。不过top命令查看的结果让你吐血，CPU几\n乎无空闲。\nD: scz &lt;scz@nsfocus.com&gt;\nsetitimer( ITIMER_REAL, &amp;value, NULL )导致分发SIGALRM信号，如果同时使用\nalarm()，势毕造成冲突。此外注意sleep()、pause()等函数带来的冲突。\n4. 系统资源相关问题\n4.1 主流Unix操作系统上如何编程获取进程的内存、CPU利用状况\nQ: Solaris下如何编程获知CPU占用率和内存占用信息呢，可移植吗？\nQ: 我想写个程序遍历当前运行中的活动进程，Solaris提供相应系统调用了吗\nA: Nicholas Dronen &lt;ndronen@io.frii.com&gt;\n不可移植。man -s 4 proc，man -s 3k kstat\n如果不是编程，可以用top、mpstat、vmstat、sar(1)、cpustat(1M)等等，还有\n/usr/ucb/ps -aux，对于Solaris来说，后者更直接精炼，top不是标准配置。\n# /usr/bin/prstat (Solaris 8 prstat(1M)手册页)\n# /usr/ucb/ps -aux | head (Solaris 2.x)\nQ: 主流Unix操作系统上如何编程获取进程的内存、CPU利用状况，AIX、HP、SUN\nprocess memory usage\nprocess cpu time usage\nA: Nate Eldredge &lt;neldredge@hmc.edu&gt;\nman -s 3C getrusage\nD: 小四 &lt;scz@nsfocus.com&gt;\n在SPARC/Solaris 2.6/7下结论一致，只支持了ru_utime和ru_stime成员，其他成员\n被设置成0。FreeBSD 4.3-RELEASE上测试，则不只支持ru_utime和ru_stime成员。从\nFreeBSD的getrusage(2)手册页可以看到，这个函数源自4.2 BSD。\n至少对于SPARC/Solaris 2.6/7，getrusage(3C)并无多大意义。\nA: Robert Owen Thomas &lt;robt@cymru.com&gt;\n对于Solaris，可以利用procfs接口，下面的例子获取指定进程的内存占用情况\n--------------------------------------------------------------------------\n/*\n* @(#)memlook.c 1.0 10 Nov 1997\n* Robert Owen Thomas robt@cymru.com\n* memlook.c -- A process memory utilization reporting tool.\n*\n* gcc -Wall -pipe -O3 -o memlook memlook.c\n*/\n#pragma ident \"@(#)memlook.c 1.0 10 Nov 1997 Robert Owen Thomas robt@cymru.com\"\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/signal.h&gt;\n#include &lt;sys/syscall.h&gt;\n#include &lt;sys/procfs.h&gt;\n#include &lt;sys/param.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\nint counter = 10;\nint  showUsage ( const char * );\nvoid getInfo   ( int, int );\nint main ( int argc, char * argv[] )\n{\nint  fd, pid, timeloop = 0;\nchar pidpath[BUFSIZ];  /* /usr/include/stdio.h: #define BUFSIZ 1024 */\nswitch ( argc )\n{\ncase 2:\nbreak;\ncase 3:\ntimeloop = atoi( argv[2] );\nbreak;\ndefault:\nshowUsage( argv[0] );\nbreak;\n}  /* end of switch */\npid = atoi( argv[1] );\nsprintf( pidpath, \"/proc/%-d\", pid );  /* -表示向左靠 */\n/*\n* /proc/1/是目录，但在这种用法中，就是直接打开目录，不是打开文件\n*/\nif ( ( fd = open( pidpath, O_RDONLY ) ) &lt; 0 )\n{\nperror( pidpath );\nexit( 1 );\n}\nif ( 0 &lt; timeloop )\n{\nfor ( ; ; )\n{\ngetInfo( fd, pid );\nsleep( timeloop );\n}\n}\ngetInfo( fd, pid );\nclose( fd );\nexit( 0 );\n}  /* end of main */\nint showUsage ( const char * progname )\n{\nfprintf( stderr, \"%s: usage: %s &lt; PID &gt; [time delay]\\n\", progname, progname );\nexit( 3 );\n}  /* end of showUsage */\nvoid getInfo ( int fd, int pid )\n{\nprpsinfo_t prp;\nprstatus_t prs;\nif ( ioctl( fd, PIOCPSINFO, &amp;prp ) &lt; 0 )\n{\nperror( \"ioctl\" );\nexit( 5 );\n}\nif ( ioctl( fd, PIOCSTATUS, &amp;prs ) &lt; 0 )\n{\nperror( \"ioctl\" );\nexit( 7 );\n}\nif ( counter &gt; 9 )\n{\nfprintf( stdout, \"PID\\tIMAGE\\t\\tRSS\\t\\tHEAP\\t\\tSTACK\\n\" );\ncounter = 0;\n}\nfprintf( stdout, \"%u\\t%-9u\\t%-9u\\t%-15u\\t%-15u\\n\", pid,\n( unsigned int )prp.pr_bysize, ( unsigned int )prp.pr_byrssize,\n( unsigned int )prs.pr_brksize, ( unsigned int )prs.pr_stksize );\ncounter++;\n}  /* end of getInfo */\n--------------------------------------------------------------------------\n4.2 Solaris下如何获知CPU速率\nA: Philip Brown &lt;phil+s3@bolthole.no-bots.com&gt;\npsrinfo -v\npsrinfo | grep on-line | wc -l 简单给出CPU数目\nA: Philly Bob\n在OK提示符下输入\"module-info\"获知CPU数目以及频率\nA: scz &lt;scz@nsfocus.com&gt;\n# /usr/platform/`uname -i`/sbin/prtdiag -v\n# /usr/platform/`uname -m`/sbin/prtdiag -v\n# /usr/bin/netstat -k cpu_info0\nA: Tony Walton &lt;tony.walton@uk.sun.com&gt;\n如果你装了Sun Workshop，还可以尝试fpversion命令\n# /opt/SUNWspro/bin/fpversion\nA SPARC-based CPU is available.\nCPU‘s clock rate appears to be approximately 266.1 MHz.\nKernel says CPU‘s clock rate is 270.0 MHz.\nKernel says main memory‘s clock rate is 90.0 MHz.\nSun-4 floating-point controller version 0 found.\nAn UltraSPARC chip is available.\nFPU‘s frequency appears to be approximately 277.1 MHz.\nUse \"-xtarget=ultra2i -xcache=16/32/1:256/64/1\" code-generation option.\nHostid = 0x80BC3CB3.\n#\n4.3 如何编程获取Solaris系统当前内存大小\nQ: 如何编程(或者有什么现成命令)获取Solaris系统当前内存大小？\nA: Nithyanandham &lt;m.nithyanandham@blr.spcnl.co.in&gt;\n几个现成命令\n/usr/platform/`uname -m`/sbin/prtdiag -v | grep Memory\nprtconf -v | grep Memory\n如果装了GNU top，也可以直接用top命令看到。\nD: scz &lt;scz@nsfocus.com&gt;\ntruss prtconf的输出中有如下内容\nsysconfig(_CONFIG_PAGESIZE)                     = 8192\nsysconfig(_CONFIG_PHYS_PAGES)                   = 16384\nMemory size: 128 Megabytes\n# /usr/ccs/bin/nm -nx /dev/ksyms | grep \"|sysconfig$\"\n10626] |0x0000100ec110|0x0000000001bc|FUNC |GLOB |0    |ABS    |sysconfig\n# find /usr/include -type f -name \"*.h\" | xargs grep -l _CONFIG_PAGESIZE\n/usr/include/sys/sysconfig.h\n# vi -R /usr/include/sys/sysconfig.h\n/*\n* cmd values for _sysconfig system call.\n* WARNING: This is an undocumented system call,\n* therefore future compatibility can not\n* guaranteed.\n*/\n#define _CONFIG_PAGESIZE   6  /* system page size */\n#define _CONFIG_PHYS_PAGES 26 /* phys mem installed in pages */\n参看sysconf(3C)手册页。\n_SC_PAGESIZE\n_SC_PAGE_SIZE\n_SC_PHYS_PAGES\nA: Casper H.S. Dik &lt;Casper.Dik@Sun.COM&gt;\n--------------------------------------------------------------------------\n/*\n* Program to determine the size installed physical memory on Suns.\n*\n* Casper Dik.\n*/\n#define MEGABYTE 0x00100000\n#define MAXMEM   0x7ff00000\n#define THEMEM   \"/dev/mem\"\n#include &lt;stdio.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\nint main ( int argc, char * argv[] )\n{\nint           fd = open( THEMEM, O_RDONLY );\nchar          c;\nunsigned long pos, mapstart = 0;\nint           totmb = 0;\nif ( fd == -1 )\n{\nperror( THEMEM );\nexit( 1 );\n}\nfor ( pos = 0; pos &lt; MAXMEM; pos += MEGABYTE )\n{\nif (lseek( fd, pos, 0 ) == -1 )\n{\nperror( \"lseek\" );\nexit( 1 );\n}\nif ( read( fd, &amp;c, 1 ) == -1 )\n{\nint size = ( pos - mapstart ) / MEGABYTE;\nif ( size != 0 )\n{\nprintf( \"found %3d MB starting at 0x%p\\n\", size, ( void * )mapstart );\ntotmb += size;\n}\nmapstart = pos + MEGABYTE;  /* start of next possible mapping */\n}\n}\nprintf( \"Total memory size: %d MB\\n\", totmb );\nexit( 0 );\n}\n--------------------------------------------------------------------------\n由于需要读访问/dev/mem，普通用户用户无法使用该程序。\n5. 块设备相关问题\n5.0 Solaris/FreeBSD/Linux中如何mount ISO文件\nA: SMTH/Unix版 2003-04-11\nxfgavin@smth\n在Linux中\nmount -o loop your.iso &lt;your mount point&gt;\nbcl@smth\n在FreeBSD中\nvnconfig vn0 your.iso\nmount_cd9660 /dev/vn0c &lt;your mount point&gt;\n... ...\numount &lt;your mount point&gt;\nvnconfig -u vn0\nSoaris@smth\n在FreeBSD 5.0中\nmdconfig -a -t vnode -f your.iso -u 4 (then you have /dev/md4)\nmount_cd9660 /dev/md4 &lt;your mount point&gt;\nA: Sun Microsystems\nSunSolve CD-ROM Version 5.0.2 released August 2001包含一个BUG，影响了它的\n安装使用。当mount上这张光盘后，没有期待中的普通文件、目录，只有一个名为\npatch1或patch2的文件，这个文件实际是一个ISO映像文件。下面的操作在Solaris 8\n上进行。\n将SunSolve CD-ROM Version 5.0.2插入光驱，Volume Manager自动检测到光盘存在\n并mount上它\n$ su\n# cd /cdrom/sunsolve_patch_cd_5_0_2_1\n# ls\n这里是进入包含ISO文件所在目录，将会看到patch1或patch2文件，如果没有，可能\n光盘mount失败。可执行volcheck命令迫使Volume Manager检测光盘存在并mount它。\n执行如下命令，假设/directory-path/filename确定ISO文件\n# /usr/sbin/lofiadm -a /directory-path/filename\n比如这里就是\n# /usr/sbin/lofiadm -a /cdrom/sunsolve_patch_cd_5_0_2_1/patch1\n与ISO文件相关的node number将被显示出来，比如\n/dev/lofi/1\n执行如下命令，指定上条命令所得到的node number做本条命令的参数\n# /usr/sbin/mount -F hsfs node-number /mnt\n比如这里就是\n# /usr/sbin/mount -F hsfs /dev/lofi/1 /mnt\n于是利用loopback file driver将ISO映像文件mount成一个块设备，现在你可以进入\n/mnt目录正常使用其中的内容了。\n# cd /mnt\n# ls\n其相应的反过程如下\n$ su\n# cd /\n# /usr/sbin/umount /mnt\n释放ISO映像文件所用node，执行如下命令，假设/directory-path/filename确定ISO\n文件\n# /usr/sbin/lofiadm -d /directory-path/filename\nA: joerg@schily.isdn.cs.tu-berlin.de 1988-10\n这是一个德国的Unix Kernel Hacker\nhttp://www.fokus.gmd.de/research/cc/glone/employees/joerg.schilling/private/\n在这里他提供了如下驱动程序\nftp://ftp.fokus.gmd.de/pub/unix/kernel/fbk\nfbk是一个伪设备驱动程序，用于在Solaris上mount那些包含文件系统的文件，比如\nISO文件(文件模拟块设备)。FreeBSD有类似的vnode driver，Linux则是loopback\ndriver。但是fbk最早于1988年10月就推出了。\n5.1 CDROM设备究竟在哪里\nQ: 为了mount光驱，需要哪些包\nA: SUNWvolr SUNWcstl SUNWcstlx\nD: Dennis Clarke &lt;dclarke@blastwave.com&gt;\n1) su - root\n2) /etc/init.d/volmgt stop\n3) ls -1 /dev/dsk/c*s2\n4) mount -F hsfs -o ro /dev/dsk/c0t6d0s2 /cdrom\n或者\n1) /etc/init.d/volmgt stop\n2) /etc/init.d/volmgt start\n3) volcheck\n4) eject\n观察/etc/vold.conf\nQ: 如何才能知道哪个设备文件对应CDROM(c0t2d0s0?)。如果有一张光盘在CDROM里，\n可以用df命令看到对应的设备文件，但是没有光盘在光驱里的时候呢？\nA: /dev/sr0 是一个指向最终设备文件的符号链接，仅对SPARC有效，不包括x86\nA: Logan Shaw &lt;logan@cs.utexas.edu&gt;\n$ uname -sri\nSunOS 5.8 i86pc\n$ ls -l /dev/sr*\nlrwxrwxrwx /dev/sr0 -&gt; dsk/c1t0d0s2\n$\n我想x86下是一样的\nQ: E420R，Solaris 7 11/99，我从http://sunsolve.sun.com获得一些补丁并安装了，\n结果现在我的光驱出问题了。似乎mount成功了，但是找不到文件，/etc/mnttab\n中没有任何有关光驱的信息，插入一张光盘会弹出一个文件管理器窗口，但是没\n有文件。\nA: Danny Mann &lt;dma@wwa.com&gt;\n检查是否打了如下Solaris 7内核补丁106541-13和 -14。这两个补丁有问题。解\n决办法是禁止vold，手工mount光驱。\nA: rschicht@my-deja.com &lt;rschicht@my-deja.com&gt;\n试试volrmmount -d命令。用patchadd -p检查是否安装了补丁106541-14，访问如\n下链接\nhttp://sunsolve.Sun.COM/pub-cgi/show.pl?target=patches/patch-access\n获取补丁106541-14的说明，阅读NOTE 15。\nA: 补丁106541-14的说明，NOTE 15\n1. 首先禁止掉vold守护进程\n# /etc/init.d/volmgt stop\n2. 手工mount光驱(设备文件名可能不同)\n# /etc/mount -F hsfs -o ro /dev/dsk/c0t2d0s0 /cdrom\n查看/etc/vfstab、/dev/dsk确认光驱所在设备文件名。\n5.2 如何弹出光驱\nQ: 在安装Oracle 8i时，系统提示插入第二张光盘，但是此时无法成功eject第一张\n光盘，终端挂起，杀掉Oracle 8i的安装进程也无济于事。唯一的办法是reset。\nA: Sergey Kurganov &lt;mmerfi@home.com&gt;\n下面的操作或许有所帮助\n1) 终止卷管理器\n# /etc/init.d/volmgt stop\n2) unmount光驱，手动eject\n3) 重启卷管理器\n# /etc/init.d/volmgt start\nD: plane@smth.org 2002-02-26 01:03\n装Oracle 9的时候，安装文档特意提醒要用绝对路径才能换盘。\n5.3 如何利用超级块进行恢复工作\nQ: Sun工作站在reboot时掉电了，用安装光盘启动进入单用户模式，执行fsck命令时\n报错\nStop-A\nok boot cdrom -s\nINIT: SINGLE USER MODE\n# fsck -o b=32 /dev/rdsk/c0t5d0s*\nAlternate super block location: 32.\n** /dev/rdsk/c0t5d0s0\nBAD SUPER BLOCK: MAGIC NUMBER WRONG\nUSE AN ALTERNATE SUPER-BLOCK TO SUPPLY NEEDED INFORMATION;\neg. fsck [-F ufs] -o b=# [special ...]\nwhere # is the alternate super block. SEE fsck_ufs(1M).\nAlternate super block location: 32.\n** /dev/rdsk/c0t5d0s1\nBAD SUPER BLOCK: MAGIC NUMBER WRONG\nUSE AN ALTERNATE SUPER-BLOCK TO SUPPLY NEEDED INFORMATION;\neg. fsck [-F ufs] -o b=# [special ...]\nwhere # is the alternate super block. SEE fsck_ufs(1M).\nAlternate super block location: 32.\n** /dev/rdsk/c0t5d0s2\nBAD SUPER BLOCK: MAGIC NUMBER WRONG\nUSE AN ALTERNATE SUPER-BLOCK TO SUPPLY NEEDED INFORMATION;\neg. fsck [-F ufs] -o b=# [special ...]\nwhere # is the alternate super block. SEE fsck_ufs(1M).\nAlternate super block location: 32.\nA: Sree Mokkapati &lt;sree@broadcom.com&gt;\n正确的用法就在错误提示信息里，你应该使用另外的超级块进行恢复工作，32仅\n仅是常用备份超级块之一。\nfsck -F ufs -o b=32 device_name\n此外如果想知道还有哪些备份超级块可用，执行\nnewfs -Nv device_name\n(等价于 mkfs -F ufs -oN -m /dev/rdsk/cXtXdXsX )\n先用df等命令确认原始device_name。\nD: scz &lt;scz@nsfocus.com&gt; 2001-10-12 17:01 修订\nSPARC/Solaris的硬盘损坏多半是文件系统根区被破坏，并不需要拆卸硬盘到其他\n机器上mount后fsck，找一张Solaris安装光盘\nStop-A进入OBP状态，在ok提示符下输入\nok&gt; boot cdrom -s\n进入单用户模式。此时原有根文件系统并未mount上来，也不需要mount原有根文\n件系统，直接\nnewfs -Nv /dev/rdsk/c0t0d0s0\n找出原根文件系统所有备份超级块号\nfsck -y -F ufs -o b=&lt;任一备份超级块号&gt; /dev/rdsk/c0t0d0s0\n这里假设原根文件系统的原始设备名是/dev/rdsk/c0t0d0s0。其他文件系统的原\n始设备名可以在系统完好时 df -k 获取，或者从/etc/vfstab中获取信息。比如\n/dev/rdsk/c0t0d0s0    /\n/dev/rdsk/c0t0d0s1    /var\n/dev/rdsk/c0t0d0s6    /usr\n/dev/rdsk/c0t0d0s7    /export/home\n根文件系统一定是/dev/rdsk/c0t0d0s0，可以先用fsck处理根文件系统，然后\nmount -F ufs /dev/dsk/c0t0d0s0 /mnt\nmore /mnt/etc/vfstab\n这样就能得到其它文件系统的原始设备名了。此外，fsck使用的是/dev/rdsk/...\n而mount使用的是/dev/dsk/...，注意这个区别。\nvfstab(4)解释得很模糊，回头我上www.google.com去找找其他资料。\nThe fsck pass value of 2 means that the file system will be checked,\nbut not sequentially\nQ: /etc/vfstab轻微损坏，启动时只能输入root口令进入单用户模式，根文件系统被\n只读mount。不想动用Solaris安装光盘，怎么办。\nA: mount -F ufs -o remount,rw /dev/dsk/c0t0d0s0 /\n5.4 Solaris root口令忘记了\nQ: 忘记了root口令，怎么办\nA: Steve Menard &lt;opsmaster@yahoo.com&gt;\n启动时按Stop-A进入ok提示符\nok boot cdrom -s (放入启动安装光盘)\nmount -F ufs /dev/dsk/c0t0d0s0 /mnt (这里指定原根区对应的设备名)\nTERM=vt100;export TERM (这一步必须做，否则vi失败)\nvi /mnt/etc/shadow\n删除root口令加密串，比如\nroot:WxzL460hohWsU:10724::::::\n删除WxzL460hohWsU，确认你还有8个冒号，重启动\n或者 /usr/sbin/reboot -- \"cdrom -s\"\nA: Philip Brown &lt;phil+s3@bolthole.no-bots.com&gt;\n使用vi有很多麻烦的地方，可以考虑sed\nmount -F ufs /dev/dsk/c0t0d0s0 /mnt\nsed ‘s/:WxzL460hohWsU:/::/‘ /mnt/etc/shadow &gt; s\nmv s /mnt/etc/shadow\n或者使用ed\nmount -F ufs /dev/dsk/c0t0d0s0 /mnt\ned /mnt/etc/shadow\n1s/root:[^:]*:/root::/ (注意，前面是数字1，不是字母l)\nw\nq\n5.5 如何使用fmthard\nA: Seán Boran &lt;sean@boran.com&gt;\n如果希望对第二块物理硬盘的分区与第一块物理硬盘一样，考虑fmthard和prtvtoc的\n结合使用，要比手工format快得多。比如，第一块物理硬盘是target 3，第二块物理\n硬盘是target 1，我们希望第二块物理硬盘磁盘卷标是\"mirror\"，做如下操作：\n/usr/sbin/prtvtoc /dev/rdsk/c0t3d0s2 | /usr/sbin/fmthard -n mirror -s - /dev/rdsk/c0t1d0s2\nman -s 1M fmthard了解更多细节。\n5.6 如何从光盘恢复Solaris 7的引导扇区\nA: paranoid@bbs.tsinghua.edu.cn\n在安装盘里有一个tools目录，进去后有一个命令叫做installboot\nA: melonm@bbs.tsinghua.edu.cn\n比如\ninstallboot /usr/platform/`uname -i`/lib/fs/ufs/bootblk /dev/rdsk/c0t1d0s0\n5.7 Solaris支持类似微软autorun.inf文件的功能吗\nQ: 我自己制作了一张光盘，同时用于Solaris和Windows。在Windows环境下，可以利\n用autorun功能，当插入光盘的时候自动调用喜爱的浏览器打开一个文件。不知道\nSolaris 7/8下是否存在类似功能。\nA: hakteng\n是的，从Solaris 8(CDE version 1.4)开始支持类似功能了\no  创建一个名为\"volstart\"的脚本文件，比如\n--------------------------------------------------------------------------\n#! /bin/ksh\n#\n# This is a CD volume start script.  This start script is designed\n# to be automatically run when the CD is inserted into a Solaris\n# system‘s CDrom drive.\n#\n# Note: not all Solaris systems have an auto volstart ability.  If this\n# CD is inserted into a CDrom drive of a Solaris system without the\n# volstart ability, volstart can also be run manually by executing it\n# from either the desktop‘s file manager or from a Unix command line.\nfull_name=$0\ndir_name=`/usr/bin/dirname $full_name`\nif [[ -x /usr/dt/bin/dtaction ]]; then\n# Run the CDrom‘s installer program\n/usr/dt/bin/dtaction Run $dir_name/installer\nfi\n--------------------------------------------------------------------------\no  将\"volstart\"文件放在光盘根目录下\no  /usr/dt/bin/sdtvolcheck脚本中存在如下语句\nif [[ -x $mountPt/volstart ]];then exec $mountPt/volstart;\n于是，当插入光盘的时候volstart脚本被执行，对于上例，最终导致installer被\n执行\n5.8 如何修改/dev/null的属性\nQ: /devices/pseudo/mm@0:null的属性是0620 root tty，我想\nchmod 666 /devices/pseudo/mm@0:null ，但是几分钟后，属性被修改回\n0620 root tty，怎么办\nA: Markus Mayer &lt;mmayer@iname.com&gt;\n查看/etc/minor_perm文件，\n# grep -s null /etc/minor_perm\nmm:null 0620 root tty\n修改该文件中的这一行成\"mm:null 0666 root sys\"即可。\n5.9 如何读取Solaris disk label信息\n5.10 如何自己制作Solaris启动软盘\nQ: 我知道可以去\nhttp://soldc.sun.com/support/drivers/dca_diskettes/\n下载启动软盘的映象文件，可我还想知道它最初是如何制作出来的\nA: 小四 &lt;scz@nsfocus.com&gt;\n1) 用fdformt格式化软盘\n2) 用newfs在软盘上创建新的文件系统\n3) 将软盘mount上来\n4) 用cp命令复制the second-level disk booter(boot或者ufsboot)到软盘，比如\n/platform/sun4u/ufsboot。参看installboot(1M)、boot(1M)手册页\n5) 用installboot命令安装boot block到软盘，比如\ninstallboot /usr/platform/`uname -i`/lib/fs/ufs/bootblk /dev/rdsk/c1t0d0s0\n6) 用cp命令复制必要的工具文件到软盘\n7) unmount软盘\n8) 用eject命令弹出软盘\n5.11 x86/Solaris如何访问FAT32分区\nA: Dan Anderson &lt;dan@drydog.com&gt;\nmount -F pcfs /dev/dsk/c0t0d0p0:1 /mnt/&lt;...&gt; # SCSI\nmount -F pcfs /dev/dsk/c0d0p0:1   /mnt/&lt;...&gt; # ATAPI\nc0 控制器ID\nt0 SCSI ID (对于ATAPI省略)\nd0 对于SCSI总是0，对于ATAPI是硬盘号\np0 p0对应第一个主分区表项\n:1 对应逻辑驱动器(c - z 或 1 - 24)\n有些报告说如果FAT32分区不对应第一个主分区表项，mount失败，感觉x86/Solaris\n对pcfs支持混乱。\nA: spp(低音炮)\n在SPARC/Solaris 7上df -k\n# df -k\n/dev/dsk/c0t0d0s0 /\n/dev/dsk/c0t0d0s6 /usr\n/dev/dsk/c0t0d0s7 /export/home\n在x86/Solaris 8上df -k\n# df -k\n/dev/dsk/c0d0s0 /\n/dev/dsk/c0d0s7 /export/home\nc 硬盘控制器的位置，比如主板第二个IDE接口上的第一个硬盘(主盘)对应c1d0\nt 只SPARC有，SCSI ID\nd 某一确定硬盘控制器(c参数决定)上硬盘位置\np 只x86有，对应MS系统的Partition概念\ns slice号，Solaris系统的概念，不太好解释，如果和p一起出现，可以理解成类似\nMS逻辑驱动器的概念\n假设x86架构上某硬盘在主引导扇区有两个主分区表项，第一个为FAT32分区，第二个\n为Solaris分区，Solaris分区上划分了两个slice，一个为根文件系统/、一个为swap\n区，则分别表示为/dev/dsk/c1d0p0:1(FAT32)、/dev/dsk/c1d0p1s0(/)、\n/dev/dsk/c1d0p1s1(swap)\n在mount FAT32分区时应该用\nmount -F pcfs /dev/dsk/c1d0p0:1 /mnt/&lt;mount_point&gt;\nD: 小四 &lt;scz@nsfocus.com&gt;\n注意，Solaris的slice概念和FreeBSD的slice概念不同，FreeBSD的slice概念就是MS\n的partition概念，而Solaris的slice概念类似于MS扩展分区上的逻辑驱动器概念。\n6. /etc/system可调资源限制\n6.1 Solaris下如何限制每个用户可拥有的最大进程数\nA: Casper Dik\n在/etc/system设置\nset maxuprc = &lt;num&gt;\nQ: maxusers参数究竟影响了什么\nA: Casper Dik\n下面以/etc/system语法格式举例说明：\n*\nset maxusers = &lt;以MB为单位计的可用物理内存数量&gt;\n* 系统所允许的最大进程数，通常最多30000\nset max_nprocs = 10 + 16 * maxusers\n* 每个用户可以拥有的最大进程数(为超级用户保留5个)\nset maxuprc = max_nprocs - 5;\n# sysdef | sed -n ‘/System Configuration/,$p‘\n6.2 如何配置系统使之支持更多的伪终端\nA: Argoth\n不要试图通过‘/usr/bin/adb -k‘到达目的。\na. 如果Solaris版本小于7，修改/etc/system，增加如下行\nset pt_cnt=&lt;num&gt;\n执行/usr/sbin/reboot -- -r，或者Stop-A，执行boot -r\nb. 对于Solaris 8，支持的伪终端数目根据需要动态改变，系统依然有一个内部限制，\n但是这个值非常大。如果\"pt_cnt\"变量小于这个内部限制，将被忽略。一般情况\n下，不再需要指定\"pt_cnt\"变量。但还是有某些罕见的情形，需要设置\"pt_cnt\"\n变量大于内部限制。\n6.3 如何增加每个进程可打开文件句柄数\nA: Casper H.S. Dik &lt;Casper.Dik@Sun.COM&gt;\n从Solaris 2.4开始，可以通过修改/etc/system实现\n* set hard limit on file descriptors\nset rlim_fd_max = 4096\n* set soft limit on file descriptors\nset rlim_fd_cur = 1024\n软限制超过256时，某些应用程序会出问题，尤其BCP程序。软限制超过1024时，那些\n使用select()的应用程序可能会出问题。Solaris 7之前，select()使用的文件句柄\n数不能超过1024。Solaris 2.6的RPC代码被重写过了，使用poll()代替select()，可\n以使用超过1024的文件句柄。Solaris 2.6之前，如果软限制超过1024，所有RPC服务\n很可能崩溃。\nSolaris 7下select()可以使用最多达65536的文件句柄，64-bit应用程序缺省情况如\n此。如果是32-bit应用程序，需要指定给FD_SETSIZE一个更大的值，重新编译。\n如果程序使用标准输入/输出(stdio)，或者调用那些使用stdio的库函数，当打开的\n文件超过256时，程序可能会出问题，这个限制是stdio的限制。当程序需要大量文件\n句柄时，应该想办法保留一些小数字的文件句柄，让stdio使用它们。\nSolaris 7下64-bit应用程序不再受这个stdio限制的影响。如果你的确需要超过256\n个FILE *，而又不能使用Solaris 7，或者需要运行32-bit代码，考虑使用来自AT&amp;T\n的SFIO(http://www.research.att.com/sw/tools/sfio/)。\nA: qaz@smth.org\n检查当前设置\n# ulimit -H -n\n1024\n# ulimit -S -n\n64\n#\n对于Solaris，建议修改/etc/system后重启\n* set hard limit on file descriptors\nset rlim_fd_max=0x8000\n* set soft limit on file descriptors\nset rlim_fd_cur=0x8000\n然后 ulimit -S -n 8192\n对于Linux\necho 65536 &gt; /proc/sys/fs/file-max\n然后 ulimit -S -n 8192\n对于FreeBSD\n编辑/etc/sysctl.conf文件(或者sysctl -w，参看SYSCTL.CONF(5))\nkern.maxfiles=65536\nkern.maxfilesperproc=32768\nQ: Linux下如何加大系统可以打开的文件数\nA: planck.bbs@bbs.nju.edu.cn\necho &lt;num&gt; &gt; /proc/sys/fs/file-max\n6.5 做了setuid()这类调用的程序如何产生core dump\nQ: 做了setuid()这类调用的程序不会产生core文件，可我需要调试这个程序。\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o suidtest suidtest.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\nint main ( int argc, char * argv[] )\n{\nint *ptr = NULL;\nprintf( \"Current uid = %d euid = %d\\n\", ( int )getuid(), ( int )geteuid() );\nprintf( \"Result of seteuid( 500 ) = %d\\n\", seteuid( 500 ) );\nprintf( \"Current uid = %d euid = %d\\n\", ( int )getuid(), ( int )geteuid() );\ncreat( \"/tmp/scz_blah\", S_IRWXU );\nprintf( \"Result of setuid( 0 ) = %d\\n\", setuid( 0 ) );\nprintf( \"Current uid = %d euid = %d\\n\", ( int )getuid(), ( int )geteuid() );\n*ptr = 0;\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n# gcc -Wall -pipe -O3 -o suidtest suidtest.c\n# strip suidtest\n# file suidtest\nsuidtest:       ELF 32-位 MSB 可执行 SPARC 版本 1，动态链接，除去\n# ls -l suidtest\n-rwxr-xr-x   1 root     other       4988  6月 29 21:21 suidtest*\n# ./suidtest\nCurrent uid = 0 euid = 0\nResult of seteuid( 500 ) = 0\nCurrent uid = 0 euid = 500\nResult of setuid( 0 ) = 0\nCurrent uid = 0 euid = 0\n段错误\n# ls -l core\ncore: 无此文件或目录\n#\n这个程序应该core dump，但是现在没有core文件产生。注意，此时suidtest仅仅是\n自己调用了setuid()，并非被\"chmod u+s suidtest\"过。有无/etc/system内核可配\n置参数改变这种行为。\nA: Sun Microsystems 2001-04-11\n出于安全考虑，suid程序以及调用setuid()的程序缺省情况下不产生core dump。如\n果确实需要产生core dump以便进行调试，修改/etc/system文件并重启系统\n* 缺省该值为0，此时禁止suid程序以及调用setuid()的程序core dump\nset allow_setid_core = 1\n对于Solaris 2.6，需要先打补丁105181-22或更高版本，才能使用上述技术。对于\n7及其更高版本的Solaris操作系统，不需要任何补丁。\nA: 小四 &lt;scz@nsfocus.com&gt; 2001-07-30 20:14\n对于SPARC/Solaris 7，修改/etc/system\nset allow_setid_core = 1\n结果在boot的时候看到提示信息说这个内核参数已经废弃(obsolte)，推荐使用\ncoreadm(1M)。\n对于SPARC/Solaris 7来说，为了方便调试，执行coreadm -e proc-setid命令即可。\n6.6 消息队列调整\nQ: 在/etc/system中如何调整消息队列\nA: &lt;solaris@sean.de&gt;\n消息队列统一使用 msgsys:msginfo_ 前缀。你可以用sysdef获取一些缺省值，还可\n以参看/usr/include/sys/msg.h头文件了解更多信息。此外不要忘记&lt;&lt;APUE&gt;&gt;\nmsgsys:msginfo_msgmap\ndefault 100 max 2147483647 &lt;sys/msg.h&gt; 100\nmsgsys:msginfo_msgmax\ndefault 2048 max 2147483647 &lt;sys/msg.h&gt; 8192 typical value 2048\nmsgsys:msginfo_msgmnb\ndefault 4096 max 2147483647 &lt;sys/msg.h&gt; 2048 typical value 4096\nmsgsys:msginfo_msgmni\ndefault 50 max 2147483647 &lt;sys/msg.h&gt; 50 typical value 50\nmsgsys:msginfo_msgssz\ndefault 8 max 2147483647 &lt;sys/msg.h&gt; 8\nmsgsys:msginfo_msgtql\ndefault 40 max 2147483647 &lt;sys/msg.h&gt; 50 typical value 40\nmsgsys:msginfo_msgseg\ndefault 1024 max 32767 &lt;sys/msg.h&gt; 1024\n7. DNS相关问题\n7.1 如何进行DNS区传输\nA: scz &lt;scz@nsfocus.com&gt;\n用nslookup是最普遍适用的\nnslookup\n&gt; server ns.tsinghua.edu.cn\n&gt; set type=axfr\n&gt; ls -d tsinghua.edu.cn [&gt; tsinghua.txt] (方括号里的可选)\n有些系统提供了dig命令\ndig @ns.tsinghua.edu.cn axfr tsinghua.edu.cn\nA: lgwu\n有些系统提供了host命令，这个命令不太保险\nhost -l net.tsinghua.edu.cn (后面指定域)\nhost -l ncic.ac.cn\n7.2 如何获知权威名字服务器\nA: scz &lt;scz@nsfocus.com&gt;\nnslookup\n&gt; set query=ns\n&gt; ncic.ac.cn (获知管辖该域的权威名字服务器)\nAuthoritative answers can be found from:\ngatekeeper.ncic.ac.cn   internet address = 159.226.41.188\n&gt; server gatekeeper.ncic.ac.cn\n&gt; set type=axfr (准备区传输)\n&gt; ls -d ncic.ac.cn &gt; ncic.txt\n7.3 如何配置DNS的委托解析\nQ: 我想把子域DNS解析下放到下面去，在我这里如何配置\nA: zhangql@bbs.tsinghua.edu.cn\n子域  IN  NS  &lt;负责子域DNS解析的IP&gt;\n7.4 如何获知BIND的版本号\nQ: 如何识别当前运行的bind是什么版本\nA: M. Zuber &lt;helmlein@hotmail.com&gt;\ndig @&lt;victim_ip&gt; txt chaos VERSION.BIND\n或者\nnslookup\nserver &lt;victim_ip&gt;\nset query=txt\nset class=chaos\nVERSION.BIND\n但是这个返回结果可以通过/etc/named.conf自己设置，并不可靠。如果你正在运\n行BIND 8，可以执行\n/usr/sbin/ndc status\nD: scz &lt;scz@nsfocus.com&gt; 2002-11-27 16:30\nBIND支持如下查询请求，参看src/bin/named/ns_req.c中的req_query()函数\ndig @&lt;victim_ip&gt; txt chaos VERSION.BIND\ndig @&lt;victim_ip&gt; txt chaos HOSTNAME.BIND\nA: backend &lt;backend@nsfocus.com&gt;\n#! /bin/sh\n# bv (Bind Version) script\n# written by backend@nsfocus.com\nUSAGE=\"Usage: $0 &lt;address&gt;\"\nif [ $# -ne 1 ] ; then\necho $USAGE\nexit\nfi\nif [ ! -f /usr/bin/dig ]; then\necho -en \"\\\\033[1;31mCan‘t find \\\"dig\\\" program.\\\\033[0;39m\\n\\n\"\nexit\nfi\nVER=`/usr/bin/dig @$1 VERSION.BIND chaos txt | grep \"VERSION.BIND\"`\nif [ \"x$VER\" = \"x\" ]; then\necho -en \"\\\\033[1;31mSorry. Can‘t get BIND version.\\\\033[0;39m\\n\\n\"\nelse\necho -en \"BIND version of \\\\033[1;33m$1\\\\033[0;39m = \"\necho -en \"\\\\033[1;33m\"\necho $VER | awk ‘{print $5;}‘\necho -en \"\\\\033[0;39m\\n\"\nfi\nA: deepin &lt;deepin@nsfocus.com&gt;\n很多主机没有dig，最方便的办法是\nnslookup -q=txt -class=chaos VERSION.BIND IP-addr\n如果要美观一点，所以可以用这样的一个小脚本\n#! /bin/sh\nif [ $# = 0 ];then echo \"useage: $0 IP-Addr.\"; exit 1;fi\nVER=`nslookup -q=txt -class=chaos VERSION.BIND $1 | grep \"VERSION.BIND\"`\nif [ $? = 0 ] ; then\necho -en \"BIND version of \\\\033[1;33m$1\\\\033[0;39m = \" `echo $VER | awk ‘{print $4,$5,$6;}‘` \"\\\\033[0;39m\\n\"\nelse\necho -en \"\\\\033[1;31mSorry. Can‘t get BIND version.\\\\033[0;39m\\n\\n\"\nfi\n命令行上直接指定IP，会进行反向域名解析，有可能失败，进入nslookup之后server\n指定IP，则无此问题。\nQ: Solaris上怎么查看BIND版本号\nA: cc@水木清华 2002-04-03 10:33\n/usr/sbin/in.named -d 1\n然后Ctrl-C退出(如果不存在/etc/named.conf，它会自动退出)。在当前目录下多了\n一个文件named.run，其中前几行就有你要的版本号(grep Version named.run)\n可以先检查日志确定，grep BIND /var/adm/messages\n7.5 Solaris/FreeBSD/Linux如何指定域名解析的顺序\nQ: 如何在Solaris中使/etc/resolv.conf的设置生效\nA: cp /etc/nsswitch.dns /etc/nsswitch.conf\n或者\nvi /etc/nsswitch.conf\nhosts: files dns\nQ: FreeBSD中有类似Solaris的/etc/nsswitch.conf的文件吗\nA: /etc/host.conf\n--------------------------------------------------------------------------\n# First try the /etc/hosts file\nhosts\n# Now try the nameserver next.\n# 如果不希望做反向域名解析，则注释掉下面这行\n# bind\n# If you have YP/NIS configured, uncomment the next line\n# nis\n--------------------------------------------------------------------------\nQ: Linux中有类似Solaris的/etc/nsswitch.conf的文件吗\nD: /etc/host.conf\n--------------------------------------------------------------------------\norder hosts, bind, nis\nmulti on\n--------------------------------------------------------------------------\nD: rai@SMTH Unix 2001-11-28 09:42\n改了/etc/host.conf还是不行，后来试了一下/etc/nsswitch.conf就可以了，Linux\n也有这个文件的，必须保证下一行中有dns\n--------------------------------------------------------------------------\n# hosts:     db files nisplus nis dns\nhosts:      files nisplus nis dns\n--------------------------------------------------------------------------\n8. Solaris编程相关问题\n8.0 Solaris多线程编程与errno全局变量\nQ: 我正在进行Solaris多线程编程，如果errno是全局变量，则任意线程都可能修改\n其值，而我需要判断errno，此时应该注意什么问题。\nA: Casper H.S. Dik &lt;Casper.Dik@Sun.COM&gt; 2002-08-05 21:47\n使用gcc -D_REENTRANT，此时errno是每个线程相关的，不再是全局变量。当正确地\n包含&lt;errno.h&gt;之后，errno被重新定义过:\nextern int *___errno();\n#define errno (*(___errno()))\n这个函数返回一个指针，指向一个线程相关整数。注意，你仍然可以使用&amp;errno。\n8.1 Solaris内核模块中如何getcwd\nQ: 在Solaris 7 64-bit内核模块中如何获知一个进程的当前工作目录(cwd)，getcwd\n并不是一个系统调用\nA: Rich Teer &lt;rich@rite-group.com&gt;\n最好通过u-&gt;u_cdir获取当前工作目录(cwd)的vnode(v节点)。但这依赖于内核当前上\n下文，curproc可能并不对应你期望的进程。\n/usr/include/sys/user.h\ntypedef struct user\n{\n... ...\n/*\n* protected by p_lock\n*/\nstruct vnode * u_cdir;  /* current directory */\nstruct vnode * u_rdir;  /* root directory    */\n8.2 Solaris下如何动态增加系统调用\n8.3 如何避免一个套接字进入TIME_WAIT状态\nQ: 我正在写一个unix server程序，不是daemon，经常需要在命令行上重启它，绝大\n多数时候工作正常，但是某些时候会报告\"bind: address in use\"，于是重启失\n败。\nA: Andrew Gierth &lt;andrew@erlenstar.demon.co.uk&gt;\nserver程序总是应该在调用bind()之前设置SO_REUSEADDR套接字选项。至于\nTIME_WAIT状态，你无法避免，那是TCP协议的一部分。\nQ: 如何避免等待60秒之后才能重启服务\nA: Erik Max Francis &lt;max@alcyone.com&gt;\n使用setsockopt，比如\n--------------------------------------------------------------------------\nint option = 1;\nif ( setsockopt ( masterSocket, SOL_SOCKET, SO_REUSEADDR, &amp;option,\nsizeof( option ) ) &lt; 0 )\n{\ndie( \"setsockopt\" );\n}\n--------------------------------------------------------------------------\nQ: 编写 TCP/SOCK_STREAM 服务程序时，SO_REUSEADDR到底什么意思？\nA: 这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用\n端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息，\n指明\"地址已经使用中\"。如果你的服务程序停止后想立即重启，而新套接字依旧\n使用同一端口，此时 SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期\n望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不\n可能。\n一个套接字由相关五元组构成，协议、本地地址、本地端口、远程地址、远程端\n口。SO_REUSEADDR 仅仅表示可以重用本地本地地址、本地端口，整个相关五元组\n还是唯一确定的。所以，重启后的服务程序有可能收到非期望数据。必须慎重使\n用 SO_REUSEADDR 选项。\nQ: 在客户机/服务器编程中(TCP/SOCK_STREAM)，如何理解TCP自动机 TIME_WAIT 状\n态？\nA: W. Richard Stevens &lt;1999年逝世，享年49岁&gt;\n下面我来解释一下 TIME_WAIT 状态，这些在&lt;&lt;Unix Network Programming Vol I&gt;&gt;\n中2.6节解释很清楚了。\nMSL(最大分段生存期)指明TCP报文在Internet上最长生存时间，每个具体的TCP实现\n都必须选择一个确定的MSL值。RFC 1122建议是2分钟，但BSD传统实现采用了30秒。\nTIME_WAIT 状态最大保持时间是2 * MSL，也就是1-4分钟。\nIP头部有一个TTL，最大值255。尽管TTL的单位不是秒(根本和时间无关)，我们仍需\n假设，TTL为255的TCP报文在Internet上生存时间不能超过MSL。\nTCP报文在传送过程中可能因为路由故障被迫缓冲延迟、选择非最优路径等等，结果\n发送方TCP机制开始超时重传。前一个TCP报文可以称为\"漫游TCP重复报文\"，后一个\nTCP报文可以称为\"超时重传TCP重复报文\"，作为面向连接的可靠协议，TCP实现必须\n正确处理这种重复报文，因为二者可能最终都到达。\n一个通常的TCP连接终止可以用图描述如下：\nclient                     server\nFIN M\nclose  -----------------&gt;  (被动关闭)\nACK M+1\n&lt;-----------------\nFIN N\n&lt;-----------------  close\nACK N+1\n-----------------&gt;\n为什么需要 TIME_WAIT 状态？\n假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发\n最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连\n接的两个方向(全双工关闭)，client必须进入 TIME_WAIT 状态，因为client可能面\n临重发最终ACK的情形。\n{\nscz 2001-08-31 13:28\n先调用close()的一方会进入TIME_WAIT状态\n}\n此外，考虑一种情况，TCP实现可能面临先后两个同样的相关五元组。如果前一个连\n接处在 TIME_WAIT 状态，而允许另一个拥有相同相关五元组的连接出现，可能处理\nTCP报文时，两个连接互相干扰。使用 SO_REUSEADDR 选项就需要考虑这种情况。\n为什么 TIME_WAIT 状态需要保持 2MSL 这么长的时间？\n如果 TIME_WAIT 状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。\n第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二\n个连接。TCP实现必须防止某个连接的重复报文在连接终止后出现，所以让TIME_WAIT\n状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被\n丢弃。建立第二个连接的时候，不会混淆。\nA: 小四 &lt;scz@nsfocus.com&gt;\n在Solaris 7下有内核参数对应 TIME_WAIT 状态保持时间\n# ndd -get /dev/tcp tcp_time_wait_interval\n240000\n# ndd -set /dev/tcp tcp_time_wait_interval 1000\n缺省设置是240000ms，也就是4分钟。如果用ndd修改这个值，最小只能设置到1000ms，\n也就是1秒。显然内核做了限制，需要Kernel Hacking。\n# echo \"tcp_param_arr/W 0t0\" | adb -kw /dev/ksyms /dev/mem\nphysmem 3b72\ntcp_param_arr:  0x3e8           =       0x0\n# ndd -set /dev/tcp tcp_time_wait_interval 0\n我不知道这样做有什么灾难性后果，参看&lt;&lt;Unix编程/应用问答中文版&gt;&gt;的声明。\nQ: TIME_WAIT 状态保持时间为0会有什么灾难性后果？在普遍的现实应用中，好象也\n就是服务器不稳定点，不见得有什么灾难性后果吧？\nD: rain@bbs.whnet.edu.cn\nLinux 内核源码 /usr/src/linux/include/net/tcp.h 中\n#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to successfully\n* close the socket, about 60 seconds */\n最好不要改为0，改成1。端口分配是从上一次分配的端口号+1开始分配的，所以一般\n不会有什么问题。端口分配算法在tcp_ipv4.c中tcp_v4_get_port中。\nA: 小四 &lt;scz@nsfocus.com&gt; 2002-07-07 15:20\n写三个脚本自动清除所有TIME_WAIT状态TCP连接:\nSPARC/Solaris 8 64-bit kernel mode\n--------------------------------------------------------------------------\n#! /sbin/sh\nndd /dev/tcp tcp_status | nawk ‘{print $1 \" \" $2 \" \" $16 $17 \" \" $18}‘ | egrep ‘TIME_WAIT‘ | cut -d‘ ‘ -f1 | while read tcpb_addr\ndo\nadb -kw /dev/ksyms /dev/mem &lt;&lt; NSFOCUS_EOF\n$tcpb_addr+0x30/Z 0t6\n$tcpb_addr+0x40/W -6\n\\$q\nNSFOCUS_EOF\ndone\n--------------------------------------------------------------------------\nSPARC/Solaris 7 64-bit kernel mode\n--------------------------------------------------------------------------\n#! /sbin/sh\nndd /dev/tcp tcp_status | nawk ‘{print $1 \" \" $2 \" \" $16 $17 \" \" $18}‘ | egrep ‘TIME_WAIT‘ | cut -d‘ ‘ -f1 | while read tcp_addr\ndo\nadb -kw /dev/ksyms /dev/mem &lt;&lt; NSFOCUS_EOF\n$tcp_addr+0x50/Z 0t6\n$tcp_addr+0x58/W -6\n\\$q\nNSFOCUS_EOF\ndone\n--------------------------------------------------------------------------\nSPARC/Solaris 2.6 32-bit kernel mode\n--------------------------------------------------------------------------\n#! /sbin/sh\n/usr/sbin/ndd /dev/tcp tcp_status | nawk ‘{print $1 \" \" $2 \" \" $16 $17 \" \" $18}‘ | egrep ‘TIME_WAIT‘ | cut -d‘ ‘ -f1 | while read tcp_addr\ndo\nadb -kw /dev/ksyms /dev/mem &lt;&lt; NSFOCUS_EOF\n$tcp_addr+0x28/W 0t6\n$tcp_addr+0x2c/W -6\n\\$q\nNSFOCUS_EOF\ndone\n--------------------------------------------------------------------------\n8.4 结构在优化编译中的对齐问题\nQ: 什么是结构在优化编译中的对齐问题\nA: 小四 &lt;scz@nsfocus.com&gt;\n看这样两个结构定义\nstruct xxx\n{\nunsigned char a;\nunsigned int  b;\n};\nstruct yyy\n{\nunsigned char a;\nunsigned int  b;\n} __attribute__ ((packed));\n或者\n#pragma pack(1)\nstruct yyy\n{\nunsigned char a;\nunsigned int  b;\n};\n#pragma pack()\n假设是32-bit编译，则xxx占用8字节，而yyy占用5字节。xxx进行了所谓的结构成员\n优化对齐。我们可以定义一个宏来获取xxx和yyy中b成员的偏移量，你会发现这个偏\n移对于xxx是4，对于yyy则是1。\n#define OFFSETOF(TYPE, MEMBER) ((size_t)&amp;((TYPE)0)-&gt;MEMBER)\nOFFSETOF( struct xxx *, b ) -&gt; 4\nOFFSETOF( struct yyy *, b ) -&gt; 1\nQ: 我正在写一个流模块，其中用到了#pragma pack()，当使用\ngcc -D_KERNEL -c abc.c\nld -r -o abc abc.o\n编译链接时，一切正常。为了获得64-bit模块，我必须使用Sun Workshop 5.0，\n结果导致系统崩溃。访问\nhttp://docs.sun.com/htmlcoll/coll.32.8/iso-8859-1/CPPPG/Pragmas.html#15434\n上面说必须在编译链接应用程序的时候指定\"-misalign\"，所以我用了如下命令编译\n/opt/SUNWspro/bin/cc -D_KERNEL -misalign -c abc.c\n/usr/ccs/bin/ld -r -o abc abc.o\n但是我不知道该如何在链接时指定\"-misalign\"。使用的是\"/usr/ccs/bin/ld\"。\nA: Casper H.S. Dik - Network Security Engineer &lt;Casper.Dik@Holland.Sun.Com&gt;\n\"-misalign\"仅仅用于应用程序，无法应用到内核编程中。\"-misalign\"使得编译\n获得的代码增加了一些runtime glue，它们将指示内核模拟unaligned load(慢)。\n作为内核编程，没有等效技术。\nQ: 使用#pragma pack()是因为需要读取来自Windows客户端的报文，对端使用\n#pragma pack(1)压缩了所使用的数据结构\n#pragma pack(1)\ntypedef struct pkt_hdr_struct\n{\nuint8_t  pkt_ver;\nuint32_t pkt_type;\nuint32_t pkt_len;\n} pkt_hdr_t;\n#pragma pack()\n为了采用这个结构读取网络数据，Solaris端的服务程序需要强制转换匹配该结构，\n但是一旦企图读取紧接在pkt_ver成员之后的pkt_type成员，崩溃了。尝试过其他\n办法，首先用一个字符指针读取第一个字节，然后指针增一，把该指针强制类型\n转换成( uint32_t * )，然后读取数据，依然崩溃。\n此外，是否意味着无法在内核模块编程中使用#pragma pack()\nA: Ed L Cashin &lt;ecashin@coe.uga.edu&gt;\n我想你可以单独写一个pkt_header_read()函数，单字节读取然后拼装成相应的数\n据类型。如果你想避免函数调用，可以使用\"inline\"关键字。\nA: Casper H.S. Dik - Network Security Engineer &lt;Casper.Dik@Holland.Sun.Com&gt;\n你是否意识到pkt_hdr_t结构使得你必须自己转换字节序(对端是x86平台)\n我不认为#pragma pack()是最好的解决办法，考虑定义如下结构\nstruct phs\n{\nchar ver;\nchar type[4];\nchar len[4];\n}\n采用memcpy()读取数据\nmemcpy( &amp;phs.type[0], &amp;pkt.pkt_type, 4 );\nA: Andrew Gabriel &lt;andrew@cucumber.demon.co.uk&gt;\n采用字符指针是正确的，但是你犯了个错误，编写如下函数\nint read_misaligned_int ( int *iptr )\n{\nint   i;\nint   value;\nchar *ptr  = ( char * )iptr;\nchar *vptr = ( char * )&amp;value;\nfor ( i = 0; i &lt; sizeof( int ); i++ )\n{\n*vptr++ = *ptr++;\n}\nreturn( value );\n}\n此外，既然你提到对端是x86平台，可能还需要考虑字节序转换的问题\nA: W. Richard Stevens &lt;1999年逝世，享年49岁&gt;\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -s -o byte_order byte_order.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n/*\n* return value:\n*     1 big-endian\n*     2 little-endian\n*     3 unknow\n*     4 sizeof( unsigned short int ) != 2\n*/\nstatic int byte_order ( void )\n{\nunion\n{\nunsigned short int s;\nunsigned char      c[ sizeof( unsigned short int ) ];\n} un;\nun.s = 0x0201;\nif ( 2 == sizeof( unsigned short int ) )\n{\nif ( ( 2 == un.c[0] ) &amp;&amp; ( 1 == un.c[1] ) )\n{\nputs( \"big-endian\" );\nreturn( 1 );\n}\nelse if ( ( 1 == un.c[0] ) &amp;&amp; ( 2 == un.c[1] ) )\n{\nputs( \"little-endian\" );\nreturn( 2 );\n}\nelse\n{\nputs( \"unknow\" );\nreturn( 3 );\n}\n}\nelse\n{\nprintf( \"sizeof( unsigned short int ) = %u\\n\", ( unsigned int )sizeof( unsigned short int ) );\nreturn( 4 );\n}\nreturn( 3 );\n}  /* end of byte_order */\nint main ( int argc, char * argv[] )\n{\nprintf( \"byte_order() = %d\\n\", byte_order() );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nD: CERNET 华中地区网络中心 程序设计版 集体讨论汇总\n为了解决Unix自定义结构在GCC优化编译中对齐问题，一般解决办法是用如下宏封装\n自定义结构\n#pragma pack(1)\nstruct my_arphdr\n{\n};\n#pragma pack()\n如果是SPARC/Solaris，还可以这样\nstruct my_arphdr\n{\n} __attribute__ ((packed));\n两种办法其实都可以用在Unix系统/GCC编译器中。\nD: mbuf@smth\n关于结构中字节对齐问题，相应编译器选项为\nGCC/G++            : -fpack-struct\nSun Workshop cc/CC : -misalign\n最好不这样做，会大大降低程序效率，特别在某些架构中。应该尝试用位操作来处理。\nD: Unknown@smth\nGCC可以这么解决\n#ifdef __GCC__\n#define PACKED __attribute__((__packed__))\n#else\n#define PACKED\n#endif\nstruct msg\n{\nu_int16_t PACKED first;\n...\n};\nVC中#include &lt;pshpack1.h&gt;即可，与之相应的还有pshpack2.h、pshpack4.h。\nA: gfh_nuaa\nDEC   : #pragma pack(1)\nSUN   : #pragma pack(1)\nAIX   : 编译时 -q align=packed\nHP-UX : #pragma pack 1\nD: Joe Durusau\n在 Visual C++ 中，使用 \"-ZP1\" 就可以让编译器对自定义结构进行单字节对齐，实\n际就是取消了对齐优化。\nA: law@bbs.apue.net 2001-12-20 13:09\n1) 结构内部成员的pack\nstruct foo\n{\nchar a;\nint  b __attribute__ ((packed));\n};\n2) 整个结构的pack\nstruct foo\n{\nchar a;\nint  b;\n}__attribute__ ((packed));\n3) 文件范围的pack\n#pragma pack(1)\nstruct foo\n{\nchar a;\nint  b;\n};\n... ...\n4) 编译选项的pack\n-fpack-struct\n但这是最危险的做法，因为这样做可能会使库函数和你的程序对结构内成员的偏移理\n解不一致。\nQ: 谁支持push/pop这个用法\n#pragma pack(push)\n#pragma pack(n)\n... ...\n#pragma pack(pop)\nA: law@bbs.apue.net\n我没见过这个写法，VC和GCC都是这样写的\n#pragma (push, N)  // 把原来align设置压栈，并设新的pack为N\n#pragma (pop)      // align设置弹栈\n假设有如下定义:\nint x __attribute__ ((aligned (16))) = 0;\n编译器将在16字节边界上分配全局变量x的空间。\n8.5 kvm编程举例: 如何编程读取shmsys:shminfo_shmmax的值\nQ: 为了避免shmget()不必要的失败，想在C代码中获取shmsys:shminfo_shmmax的值。\n但是不能读取/etc/system，那样很不可靠。\nset shmsys:shminfo_shmmax = 0x2000000\nA: &lt;hume.spamfilter@bofh.halifax.ns.ca&gt;\n首先执行如下shell命令\n# echo ‘shminfo_shmmax/D‘ | adb -k (SPARC/Solaris 2.6 32-bit kernel mode)\nphysmem fddb\nshminfo_shmmax:\nshminfo_shmmax: 134217728\n于是我们可以编写如下C代码\n--------------------------------------------------------------------------\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;kvm.h&gt;\n#include &lt;nlist.h&gt;\n#include &lt;fcntl.h&gt;\n#define KERN_NAMELIST \"/dev/ksyms\"\n/*\n* should not be /dev/kmem\n*/\n#define KERN_CORE     \"/dev/mem\"\nint main ( int argc, char * argv[] )\n{\nkvm_t *      krn = NULL;\nstruct nlist nms[2];\nunsigned int val;\nif ( ( krn = kvm_open( KERN_NAMELIST, KERN_CORE, NULL, O_RDONLY, argv[0] ) ) == NULL )\n{\nexit( -1 );\n}\nnms[0].n_name  = \"shminfo_shmmax\";\nnms[0].n_value = 0;\nnms[0].n_type  = 0;\nnms[1].n_name  = NULL;\nnms[1].n_value = 0;\nnms[1].n_type  = 0;\nif ( kvm_nlist( krn, nms ) == 0 )\n{\nif ( nms[0].n_type != 0 )\n{\nif ( kvm_read( krn, nms[0].n_value, ( char * )&amp;val, sizeof( val ) ) != 4 )\n{\nfprintf( stderr, \"Unable to fetch shminfo_shmmax.\\n\" );\n}\nelse\n{\nfprintf( stdout, \"shminfo_shmmax = %ld\\n\", val );\n}\n}\nelse\n{\nfprintf( stderr, \"Unable to fetch shminfo_shmmax.\\n\" );\n}\n}\nkvm_close( krn );\nexit( 0 );\n}  /* end of main */\n--------------------------------------------------------------------------\n关于kvm_*()系列函数，可以man -s 3k kvm_nlist等等，但是Sun强烈反对利用\nkvm_*()函数，几乎没有兼容性、可移植性可言。\n个人不推荐在大型应用软件中使用kvm_*()系列函数。有些可配置系统参数可以通过\nsysconf(3C)获取。\n8.6 如何得到非局部变量列表\nQ: 什么工具可以从目标文件中提取非局部变量列表\nA: Donald McLachlan &lt;don@mars.dgrc.crc.ca&gt;\n最简单的就是nm，假设你有一个目标文件(或者已链接过的可执行文件)，nm -g将显\n示所有\"全局\"变量。下面是一个Solaris的例子：\n--------------------------------------------------------------------------\n/*\n* gcc -o junk junk.c\n*/\nint        var1;\nstatic int var2;\nint main ( void )\n{\nint var3;\nreturn( 0 );\n}  /* end of main */\n--------------------------------------------------------------------------\n$ nm -g junk\njunk:\n[Index]   Value      Size    Type  Bind  Other Shndx   Name\n[66]    |    133640|       0|OBJT |GLOB |0    |15     |_DYNAMIC\n[61]    |    133496|       0|OBJT |GLOB |0    |13     |_GLOBAL_OFFSET_TABLE_\n[71]    |    133528|       0|OBJT |GLOB |0    |14     |_PROCEDURE_LINKAGE_TABLE_\n[69]    |         0|       0|NOTY |WEAK |0    |UNDEF  |__deregister_frame_info\n[60]    |         0|       0|NOTY |WEAK |0    |UNDEF  |__register_frame_info\n[70]    |    133836|       0|OBJT |GLOB |0    |19     |_edata\n[59]    |    133872|       0|OBJT |GLOB |0    |20     |_end\n[58]    |    133864|       4|OBJT |GLOB |0    |20     |_environ\n[72]    |     67960|       0|OBJT |GLOB |0    |12     |_etext\n[67]    |    133600|       0|FUNC |GLOB |0    |UNDEF  |_exit\n[75]    |     67936|      20|FUNC |GLOB |0    |11     |_fini\n[64]    |     67908|      28|FUNC |GLOB |0    |10     |_init\n[73]    |     67956|       4|OBJT |GLOB |0    |12     |_lib_version\n[57]    |     67380|     116|FUNC |GLOB |0    |9      |_start\n[62]    |    133576|       0|FUNC |GLOB |0    |UNDEF  |atexit\n[68]    |    133864|       4|OBJT |WEAK |0    |20     |environ\n[63]    |    133588|       0|FUNC |GLOB |0    |UNDEF  |exit\n[74]    |     67784|      24|FUNC |GLOB |0    |9      |main\n[65]    |    133868|       4|OBJT |GLOB |0    |20     |var1\n$\n注意到var2这样的\"静态全局变量\"，由于仅仅在单个源文件中有效，nm -g并未显示\n它。如果不指定-g选项，将显示var2(当然会显示更多垃圾信息)。\n$ nm junk\njunk:\n[Index]   Value      Size    Type  Bind  Other Shndx   Name\n... ...\n[65]    |    133868|       4|OBJT |GLOB |0    |20     |var1\n[46]    |    133860|       4|OBJT |LOCL |0    |20     |var2\n$\n8.7 内核可加载模块引用了无法解析的符号\n8.8 如何单独获得Solaris编译环境\nQ: 我需要安装哪些包\nA: Seán Boran &lt;sean@boran.com&gt;\n需要下列Solaris安装包：\nSUNWbtool、SUNWsprot、SUNWtoo、SUNWhea、SUNWarc、SUNWlibm、SUNWlibms\n可以用pkginfo [-l]检查是否安装了这些包\n$ pkginfo SUNWbtool SUNWsprot SUNWtoo SUNWhea SUNWarc SUNWlibm SUNWlibms\nsystem      SUNWarc        Archive Libraries\nsystem      SUNWbtool      CCS tools bundled with SunOS\nsystem      SUNWhea        SunOS Header Files\nsystem      SUNWlibm       Sun WorkShop Bundled libm\nsystem      SUNWlibms      Sun WorkShop Bundled shared libm\nsystem      SUNWsprot      Solaris Bundled tools\nsystem      SUNWtoo        Programming Tools\n$\n可以从Solaris CD中单独安装缺少的包(pkgadd)\n象make这样的工具安装在/usr/ccs/bin，增加到$PATH环境变量中。但是这个make和\n某些工具相冲突，比如BIND，此时应该安装GNU make，确认GNU make的搜索路径位于\n/usr/ccs/bin/make之前。另外，$PATH环境变量中/usr/ccs/bin应该位于/usr/ucb之\n前。\n8.9 如何获取Solaris内核可调参数列表\nQ: 谁有Solaris内核可调参数列表\nA: Andrew Garman &lt;andrew_garman@ins.com&gt;\n执行\n/usr/xpg4/bin/nm /platform/sun4u/kernel/unix | egrep ‘OBJT \\|GLOB‘ | more\n显示结果中部分为Solaris内核可调参数，另外一些非可调内核参数。可以用ndd获取、\n设置网络相关参数。\nD: scz &lt;scz@nsfocus.com&gt;\n可以考虑\n/usr/ccs/bin/nm -nx /dev/ksyms | egrep ‘OBJT \\|GLOB‘ | more\n不知道二者区别何在？第二个报告内容应该包含了后来动态加载内核模块输出的符号，\n第一个才对应基本内核输出的符号。\n8.10 如何获取自Unix纪元以来的秒数，如何转换成可理解的表达方式\n8.11 如何页边界对齐式分配内存\nQ: 我希望在页边界上分配大块内存，要求普通用户、非特权进程亦能使用此技术。\n在mmap(2)手册页中没有明确表明返回地址边界对齐。它提到可以指定起始地址以\n保证页边界对齐，但没有说明如果由系统选定起始地址时是否也是页边界对齐的。\nMAP_ANON并非所有系统都支持，我需要在Solaris 2.x上运行。\nA: Andrew Gierth &lt;andrew@erlenstar.demon.co.uk&gt;\nmmap(2)即可满足要求。某些系统提供了valloc或者memalign，但它们的实现机制是，\n分配超过请求大小的内存，然后调整之，这相当浪费。\nmmap(2)应该始终是页边界对齐的。\n在那些不支持 MAP_ANON 的系统上，打开/dev/zero获取句柄，传递给mmap(2)，效果\n是一样的。\nmmap(2)的可移植性足够好，不过\"分配超过请求大小的内存并调整之\"可能更具有可\n移植性。\n8.12 Solaris下究竟如何使用setuid/seteuid/setreuid\nD: tt &lt;warning3@nsfocus.com&gt; 2001-06-07 14:04\n如果一个Solaris下的程序setuid-to-&lt;any&gt;，应该尽量使用setreuid()永久放弃特权，\n而不是setuid()，因为这样最通用。尤其当setuid-to-&lt;not root&gt;的时候，setuid()\n根本无法永久放弃特权。\n如果一个Solaris下的程序setgid-to-&lt;any&gt;，应该尽量使用setregid()永久放弃特权，\n而不是setgid()，因为这样最通用。尤其当整个过程中无法满足EUID为0的时候，\nsetgid()根本无法永久放弃特权。\n假设一个Solaris下的程序同时setuid、setgid过，较理想的释放顺序应该是先释放\nsetgid特权，后释放setuid特权。\n据tt报告，Linux下setuid()实现和Solaris明显不同，无论如何都同时设置RUID、\nEUID、SUID(假设权限允许)，注意区分不同系统下系统调用setuid()的不同表现。\nD: tt &lt;warning3@nsfocus.com&gt; 2003-05-22 10:42\n对于一个Solaris下setuid-to-root程序，假设有如下代码片段:\n[1] ... ...\n[2] seteuid( getuid() );\n[3] ... ...\n[4] execve( ... ... );\n在[1]处获得控制权就没什么好说的了。如果能在[3]处获得控制权，由于SUID的存在，\n可以执行\"seteuid(0)/setuid(0)\"重获root权限。但是，如果只能在[4]加载的进程\n里获得控制权，你无法重获root权限。因为执行到[4]时，RUID、EUID非0，只有SUID\n为0。而execve()加载的进程里RUID、EUID非0，SUID会被设置成当前的EUID，也非0。\n这个问题以前一直没有注意到。\n8.13 compile()和step()怎么用\nQ: 我知道这两个函数是Solaris对正则表达式的支持函数，可到底怎么用呢？\nA: microcat &lt;rotm@263.net&gt;\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o reg reg.c -lgen\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;regexpr.h&gt;\nint main ( int argc, char * argv[] )\n{\nchar * expbuf = NULL;\nif ( ( expbuf = compile( argv[1], NULL, NULL ) ) == NULL )\n{\nexit( EXIT_FAILURE );\n}\nif ( step( argv[2], expbuf ) )\n{\nprintf( \"Match at: %s\\n\", loc1 );\n}\nelse\n{\nprintf( \"No match.\\n\" );\n}\nfree( expbuf );\nexit( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n$ ./reg ‘^.*inetd$‘ ‘/usr/sbin/inetd‘\nMatch at: /usr/sbin/inetd\n$\n8.14 Solaris系统中如何检查内存泄露、腐烂\nA: Sun Microsystems 2001-04-25\nQ: 在一台Sun服务器上运行了好多程序，运行一段日子后发现内存空闲少了几百兆，\n基本上都用光了，怎么知道是那些程序干的\nA: lose@水木清华 2002-04-03 10:55\n既然已经少了几百兆，那么看一下哪个程序占的内存最大，运行\n/usr/dt/bin/sdtprocess，对这个进程进行采样，跑一小时或一天看看内存是否一直\n在增加。如果是，然后用purify去找问题出在哪里了。purify并不能保证所有的问题\n都能检查出来，所以你还要用上面的方法再检查。\n8.15 How to enable microstate accounting in order to use gethrvtime(3C)\nA: Sun Microsystems 2000-05-15\n库函数gethrvtime(3C)用于获取当前LWP的执行时间，以纳秒(10亿分之一秒)为单位。\n但是为了使用gethrvtime(3C)库函数，必须事先enable microstate accounting。参\n看ptime(1)手册页。\n下面利用ioctl(2)操作procfs，编程实现。\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o gethrvtime gethrvtime.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;strings.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys/procfs.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stropts.h&gt;\nstatic int ms_set ( int onoff )\n{\nchar buffer[80];\nint  fd;\nint  state = PR_MSACCT;\nsprintf( buffer, \"/proc/%d\", ( int )getpid() );\nif ( ( fd = open( buffer, O_RDWR ) ) == -1 )\n{\nperror( \"open\" );\nreturn( EXIT_FAILURE );\n}\nif ( ioctl( fd, ( onoff ? PIOCSET : PIOCRESET ), &amp;state ) == -1 )\n{\nperror( \"PIOCSET/PIOCRESET\" );\nclose( fd );\nreturn( EXIT_FAILURE );\n}\nclose( fd );\nreturn( EXIT_SUCCESS );\n}\nint main ( int argc, char * argv[] )\n{\nhrtime_t start, end;\nint      i, iters = 10000;\nms_set( 1 );\nstart = gethrvtime();\nfor ( i = 0; i &lt; iters; i++ )\n{\ngetpid();\n}\nend = gethrvtime();\nfprintf( stderr, \"start = %lld, end = %lld\\n\", start, end );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n8.16 如何让普通用户可以绑定[1, 1023]闭区间上的特权端口\n8.17 SPARC/Solaris 7 64-bit kernel mode下dumpadm(1M)手册页\n8.18\n9. 图形界面相关问题\n9.1 如何避免进入Solaris的图形界面\nQ: 我想让console保持在字符模式下，该如何做\nA: Darren Dunham &lt;ddunham@redwood.taos.com&gt;\n这里有一份很好的FAQ，http://www.wins.uva.nl/pub/solaris/solaris2.html\n下文引自http://www.science.uva.nl/pub/solaris/solaris2.html#q3.54\n如何允许/禁止dtlogin？\n是否启动dtlogin可以用/usr/dt/bin/dtconfig命令进行设置，不带任何参数执行该\n命令，提示如下：\n/usr/dt/bin/dtconfig -d        (disable auto-start)\n/usr/dt/bin/dtconfig -e        (enable auto-start)\n/usr/dt/bin/dtconfig -kill     (kill dtlogin)\n/usr/dt/bin/dtconfig -reset    (reset dtlogin)\n/usr/dt/bin/dtconfig -p        (printer action update)\n/usr/dt/bin/dtconfig -inetd    (inetd.conf /usr/dt daemons)\n/usr/dt/bin/dtconfig -inetd.ow (inetd.conf /usr/openwin daemons)\n如果绝大多数时间你并不想关闭图形模式，可以在\"session\"菜单上选择\n\"command line login\"。\nA: &lt;lucifer@nospam.org&gt;\n更省事的办法是\ncd /etc/rc2.d\nmv S99dtlogin s99dtlogin\nQ: Solaris CDE窗口的启动与关闭\nA: tenia@一塌糊涂 1999-11-03\n用/usr/dt/bin/dtlogin\ndtlogin -daemon  从命令行启动注册窗口\ndtlogin -e       使系统自动启动注册窗口\ndtlogin -d       取消自动启动\ndtlogin -kill    杀掉注册窗口\n9.2 Solaris 7的锁屏\nQ: Solaris 7中哪个进程负责锁屏效应。7以前的版本，某些人在console登录后锁屏，\n回家前忘记取消锁屏，我简单地杀掉xlock进程即可。但是我不知道Solaris 7中\n该怎么做。看了看dtsession和dtscreen的一些东西，但是无论我杀掉二者中哪个\n进程，console挂起在黑屏的无限循环中，只有鼠标光标可见\nA: &lt;buck_naked@NOiname.SPAMcom&gt;\n应该是dtscreen\n9.3 如何调整键盘重复率\nQ: Ultra 5 Solaris 8 如何设置键盘重复率？我想设置重复率到最大，延迟到最小。\nA: Alan Coopersmith &lt;alanc@alum.calberkeley.org&gt;\nhttp://soar.Berkeley.EDU/~alanc/\n如果是root想对系统中所有用户做此修改，编辑/etc/dt/config/Xservers，增加\n-ar1 和 -ar2选项。如果/etc/dt/config/Xservers不存在，从\n/usr/dt/config/Xservers复制一份过来。\n如果不是root，仅仅想修改自己的配置，用/usr/openwin/bin/accessx配置键盘和鼠\n标参数。\nman -M /usr/openwin/man Xsun\n-ar1 milliseconds\n这么多毫秒后按键开始自动重复。缺省500毫秒。参数对于x86或者PowerPC\n无效。\n-ar2 milliseconds\n两次自动重复之间的时间间隔(毫秒单位)。缺省50毫秒。参数对于x86或者\nPowerPC无效。\nman -M /usr/openwin/man accessx\n9.4 如何拔掉键盘继续运行Solaris\nQ: 我这里的E250/E3500装了Solaris后键盘都不能拔掉，一拔掉就进入OK状态。而老\n式的SparcServer 1000E是可以不要键盘运行的，不知道要在哪里设置才能够不要\n键盘运行？\nQ: 这里是一台Sun Ultra 5，拔掉键盘后，系统停止响应\nA: J.Keil\n拔掉键盘导致Ultra 5的console设备侦测到一次BREAK条件。BREAK条件将中断操作系\n统，使系统进入OBP(open boot prom)监视状态。如果启动内核时使用了kadb内核调\n试器，BREAK条件使系统进入kadb调试状态。\n参看kbd(1)手册页，有几种办法禁止这种行为：\na. 永久办法\nvi /etc/default/kbd\nKEYBOARD_ABORT=disable\n/usr/bin/kbd -i (不用重新启动机器)\nb. 临时办法\n/usr/bin/kbd -a disable\n与之对应的就是\n/usr/bin/kbd -a enable\nc. 看BSM的时候找到的另外一种解决办法，在/etc/system文件中增加如下行\nset abort_enable = 0\nA: dkoleary@mediaone.net 2001-06-02 22:09\n用kbd(1)命令\nkbd [ enable | disable | alternate ]\nenable    : 允许 STOP-A\ndisable   : 禁止 STOP-A\nalternate : 允许拔掉键盘，但不禁止 STOP-A\n为了使用 alternate 选项，需要安装下列补丁\nSolaris 2.6 105924-10\nSolaris 7   107589-03\n9.5 Solaris下如何设置显卡分辨率\nA: kougar@smth.org\n/etc/openwin/server/etc/OWconfig\n/usr/openwin/server/etc/OWconfig\nA: hycan@smth.org\n/usr/sbin/m64config -prconf -propt\n/usr/sbin/m64config -res ‘?‘\nls -l /dev/fb (一个符号链接)\nls -l /dev/fbs/m640 (一个符号链接)\nprtconf -F (Return the device pathname of the console frame buffer)\nm64config -res 1152x900x76 -depth 8\nls -l /dev/fbs/ffb0 (一个符号链接)\n/usr/sbin/ffbconfig -prconf -propt (当前设置1152x900x76x8)\n参看m64config(1M)、ffbconfig(1M)手册页\n9.6 Solaris下如何设置显示刷新率\nA: CERNET 华中地区网络中心 UNIX版 domyself 2001-08-16\n除了m64config(1M)，还有一种办法，就是进入OBP状态设置分辨率、刷新率。进入\nOBP状态至少有两种方法\n# sync    &lt;-- 同步文件系统，准备重启\n# init 0  &lt;-- 关闭系统后将停留在OBP状态，也就是ok提示符下\n其实我们最常用的做法是Stop-A进入OBP状态\nok&gt; show-displays\n这里可以看到当前的显示设备，如果你只有一个显示设备，那么这里有两个提示，选\n择a就选择了当前显示设备，选择q表示退出，你只能选择a。选择之后可以Ctrl-Y输\n入那个很长的设备路径全名。\nok&gt; dev &lt;设备路径全名&gt; (用Ctrl-Y输入)\n选择并设置成当前结点，后面的words命令只处理当前结点，不接受指定\nok&gt; pwd  (验证当前路径是否正确)\nok&gt; words\n列出当前结点的方法名，分辨率和刷新率是作为方法提供的。比如你可能看到\nr1024x768x77x24\nr1152x900x76x8\n注意，数字前面有一个小写的‘r‘，表示resolution。假设我们以前的设置是\n1152x900x76x8，现在想改成1024x768x77x24，用如下命令\nok&gt; setenv output-device screen:r1024x768x77x24\nok&gt; boot -r\n再次注意，\"screen:\"之后指定的是方法名，也就是说前面有那个小写的‘r‘。你用\nwords看到什么就指定什么。自己估计显存大小，分辨率、刷新率、颜色深度是相互\n制约的。最好不要自己调节这些参数，很容易损坏显示设备。OBP状态下设置分辨率、\n刷新率的命令普遍描述如下\nok&gt; setenv output-device &lt;device-path&gt;:&lt;resolution&gt;\n上面screen是个别名，可以用devalias看到本来的设备路径全名，也就是\nshow-displays看到的那个设备路径全名。指定设备路径全名也可以，如果你撑着了\n的话。\nok&gt; devalias  (检查设备别名)\n启动之后可以用如下命令检查当前设置\n# m64config -prconf | grep Current\nCurrent resolution setting: 1024x768x77\nCurrent depth: 24\n#\n警告：和调节PC机所配显示设备一样，这种调节具有破坏性，务必小心。对于高版本\n的Solaris，建议使用m64config等工具调节显示刷新率，低版本Solaris才考\n虑进入OBP状态设置。\nA: 水木清华 humvee\nx86/Solaris下可用kdmconfig\n9.7 在PC X Server上使用中文\nQ: 我用WinaXe Plus 6.2做X Server，远程登录SPARC/Solaris 8，经常看到的是乱\n码，不得已只好用英文方式登录，有何好的解决办法\nA: watercloud &lt;watercloud@nsfocus.com&gt; 2001-01-07\n其实能支持中文，只是默认没有相应字体而已，但此时Unix Server上不是有相应字\n体吗？拿过来就有了。\ncd /usr/openwin/lib/locale/zh/X11/fonts/75dpi\ntar cvf /tmp/solaris.tar *\nFTP取回到PC，比如解压到WinaXe_Plus\\FONTS\\solaris目录下，\n1) 重命名fonts.alias为fonts.ali\n2) 将该目录下的.Z压缩文件都解开，一堆.pcf文件\n3) 修改fonts.dir，将其中第一列的文件名改成不带.Z的\n4) 运行XSettings，设置X Server的字体路径，将该目录添加进去\n5) 运行XSession启动PC X Server，通过XDMCP登录Solaris 8\n6) /opt/SUNWspro/WS5.0/bin/workshop启动无误\n注意，这里有一个到PC的TCP连接，如有防火墙设置，请自行修改。此外，有必要提\n醒的是，PC X Server缺省安装后几乎没有访问控制，历史上那些著名的X攻击......\nA: knightmare@smth\n还有一种方法就是xfs server。在目标主机上启动xfs server，在PC X Server中指\n定目标主机提供的xfs server，这样就可以显示中文了。\n9.8 如何让Solaris Console保持在字符登录界面，同时可以远程使用PC X Server\nQ: 我在VMware Workstation 3.0上装了一个x86/Solaris 8，想让console保持在字\n符登录界面，同时启动PC X Server通过XDMCP远程登录CDE，不成功\nA: 小四 &lt;scz@nsfocus.com&gt; 2002-07-03 21:13\n执行/usr/dt/bin/dtconfig -d，这样console保持在字符登录界面。需要远程使用\nCDE时，手工执行\"/usr/dt/bin/dtlogin -daemon &amp;\"即可。\n检查/etc/rc2.d/S99dtlogin是否存在，如果不存在，执行/usr/dt/bin/dtconfig -e\n之后会看到这个启动脚本(反之如果执行/usr/dt/bin/dtconfig -d，将删除该启动脚\n本)，接着执行/etc/rc2.d/S99dtlogin stop;/etc/rc2.d/S99dtlogin start即可。\n观察这个脚本，实际执行了\"/usr/dt/bin/dtlogin -daemon &amp;\"\n问题在于如果运行了该脚本，console将僵死在dtlogin登录界面处，无法正常以字符\n模式登录系统。所以不建议允许自动启动/etc/rc2.d/S99dtlogin，可以改名后在需\n要时手工启动。\n执行/usr/dt/bin/dtconfig -inetd后，将在/etc/inetd.conf中生成三个入口项\n/usr/dt/bin/dtspcd、/usr/dt/bin/rpc.cmsd、/usr/dt/bin/rpc.ttdbserverd，其\n中第一个与在console上启动CDE相关，在6112/tcp上侦听。不过这三个入口项屏敝后\n与远程登录CDE无关。\nXDMCP侦听在177/UDP，在Solaris上执行如下命令\n# netstat -na -f inet -P udp | grep 177\n10. 网卡相关问题\n10.0 怎样将第二块网卡名改成hme0\nQ: 主板上的网卡坏了，新插一块，但名称怎么改过来\nA: lisuit from gceclub.sun.com.cn 2002-10-3 22:12\n编辑/etc/path_to_inst文件，查找hme字样，将instance number为0的改为1，1改为\n0，然后reboot -- -r。参看path_to_inst(4)手册页。\n10.1 如何在程序中获取本机MAC地址\nQ: 如何在C代码中获取本机MAC地址，我用strace跟踪ifconfig\nioctl(4, SIOCGIFHWADDR, 0xbffffb80)     = 0\nioctl(4, SIOCGIFADDR, 0xbffffb80)       = 0\nioctl(4, SIOCGIFBRDADDR, 0xbffffb80)    = 0\nioctl(4, SIOCGIFNETMASK, 0xbffffb80)    = 0\nD: Unix Programmer\n用gethostname()/gethostbyname()依赖于本机的域名解析系统，比如/etc/hosts文\n件、/etc/nsswitch.conf文件、/etc/resolv.conf文件。这样获取本机IP是不可靠的。\n如果/etc/hosts文件中没有指定本机IP，则依赖DNS是否配置了PTR资源记录。可靠的\n办法应该是strace ifconfig、truss ifconfig，实际就是照ifconfig的实现去获取\n本机IP。\nA: David Peter &lt;dave.peter@eu.citrix.com&gt;\nstrace是Linux下的工具，由于HP-UX 10.20的ioctl不支持SIOCGIFHWADDR，可能需要\nDLPI接口或者针对/dev/lan0的NETSTAT ioctl，为了使用NETSTAT ioctl还需要重启\n动，而且HP不赞成继续使用NETSTAT ioctl，HP-UX 11.00不再支持。\n根据手头一个古老的工具，Digital Unix下ioctl支持SIOCRPHYSADDR。至于SGI上的\nIRIX，我想可能需要一个原始套接字，比如：\ns = socket( PF_RAW, SOCK_RAW, RAWPROTO_SNOOP )\nA: Floyd Davidson &lt;floyd@ptialaska.net&gt;\n--------------------------------------------------------------------------\n/*\n* display info about network interfaces\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;sys/ioctl.h&gt;\n#include &lt;net/if.h&gt;\n#include &lt;net/if_arp.h&gt;\n#include &lt;arpa/inet.h&gt;\n/*\n* 为什么要这样定义宏，直接做强加型转换不好么\n*/\n#define inaddrr( x ) ( *( struct in_addr * )&amp;ifr-&gt;x[ sizeof( sa.sin_port ) ] )\n/*\n* 注意，这里IFRSIZE是变化的，依赖于size的取值\n*/\n#define IFRSIZE      ( ( int )( size * sizeof( struct ifreq ) ) )\nint main ( void )\n{\nunsigned char *    u;\nint                sockfd, size = 1;\nstruct ifreq *     ifr;\nstruct ifconf      ifc;\nstruct sockaddr_in sa;\nif ( 0 &gt; ( sockfd = socket( AF_INET, SOCK_DGRAM, IPPROTO_IP ) ) )\n{\nfprintf( stderr, \"Cannot open socket.\\n\" );\nexit( EXIT_FAILURE );\n}\nifc.ifc_req = NULL;\ndo\n{\n++size;\n/*\n* realloc buffer size until no overflow occurs\n*/\nif ( NULL == ( ifc.ifc_req = realloc( ifc.ifc_req, IFRSIZE ) ) )\n{\nfprintf( stderr, \"Out of memory.\\n\" );\nexit( EXIT_FAILURE );\n}\nifc.ifc_len = IFRSIZE;\nif ( ioctl( sockfd, SIOCGIFCONF, &amp;ifc ) )\n{\nperror( \"ioctl SIOCFIFCONF\" );\nexit( EXIT_FAILURE );\n}\n} while ( IFRSIZE &lt;= ifc.ifc_len );\nifr = ifc.ifc_req;\nfor ( ; ( char * )ifr &lt; ( char * )ifc.ifc_req + ifc.ifc_len; ++ifr )\n{\nif ( ifr-&gt;ifr_addr.sa_data == ( ifr + 1 )-&gt;ifr_addr.sa_data )\n{\n/*\n* duplicate, skip it\n*/\ncontinue;\n}\nif ( ioctl( sockfd, SIOCGIFFLAGS, ifr ) )\n{\n/*\n* failed to get flags, skip it\n*/\ncontinue;\n}\nprintf( \"Interface:  %s\\n\", ifr-&gt;ifr_name );\nprintf( \"IP Address: %s\\n\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) );\n/*\nFrom: David Peter &lt;dave.peter@eu.citrix.com&gt;\nThis won‘t work on HP-UX 10.20 as there‘s no SIOCGIFHWADDR ioctl. You‘ll\nneed to use DLPI or the NETSTAT ioctl on /dev/lan0, etc (and you‘ll need\nto be root to use the NETSTAT ioctl. Also this is deprecated and doesn‘t\nwork on 11.00).\nOn Digital Unix you can use the SIOCRPHYSADDR ioctl according to an old\nutility I have. Also on SGI I think you need to use a raw socket, e.g. s\n= socket(PF_RAW, SOCK_RAW, RAWPROTO_SNOOP)\nDave\n*/\nif ( 0 == ioctl( sockfd, SIOCGIFHWADDR, ifr ) )\n{\n/* Select which  hardware types to process.\n*\n*    See list in system include file included from\n*    /usr/include/net/if_arp.h  (For example, on\n*    Linux see file /usr/include/linux/if_arp.h to\n*    get the list.)\n*/\nswitch ( ifr-&gt;ifr_hwaddr.sa_family )\n{\ncase ARPHRD_NETROM:\ncase ARPHRD_ETHER:\ncase ARPHRD_PPP:\ncase ARPHRD_EETHER:\ncase ARPHRD_IEEE802:\nbreak;\ndefault:\nprintf( \"\\n\" );\ncontinue;\n}\nu = ( unsigned char * )&amp;ifr-&gt;ifr_addr.sa_data;\nif ( u[0] + u[1] + u[2] + u[3] + u[4] + u[5] )\n{\n/*\n* 这里使用%2.2x还不如使用%02x\n*/\nprintf( \"HW Address: %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\",\nu[0], u[1], u[2], u[3], u[4], u[5] );\n}\n}\n/*\n* 为什么要做第二个判断，全1的掩码也不是不可能\n*/\nif ( 0 == ioctl( sockfd, SIOCGIFNETMASK, ifr ) &amp;&amp;\nstrcmp( \"255.255.255.255\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) ) )\n{\nprintf( \"Netmask:    %s\\n\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) );\n}\n/*\n* 如果设置了广播地址，才继续ioctl\n*/\nif ( ifr-&gt;ifr_flags &amp; IFF_BROADCAST )\n{\nif ( 0 == ioctl( sockfd, SIOCGIFBRDADDR, ifr ) &amp;&amp;\nstrcmp( \"0.0.0.0\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) ) )\n{\nprintf( \"Broadcast:  %s\\n\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) );\n}\n}\nif ( 0 == ioctl( sockfd, SIOCGIFMTU, ifr ) )\n{\nprintf( \"MTU:        %u\\n\", ifr-&gt;ifr_mtu );\n}\nif ( 0 == ioctl( sockfd, SIOCGIFMETRIC, ifr ) )\n{\nprintf( \"Metric:     %u\\n\", ifr-&gt;ifr_metric );\n}\nprintf( \"\\n\" );\n}  /* end of for */\nclose( sockfd );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nA: scz &lt;scz@nsfocus.com&gt;\n上例在Linux下gcc -Wall -pipe -O3 -o getinfo getinfo.c编译即可。\n如果用于SPARC/Solaris，需要修改一些地方，最主要的是如何获取本机MAC地址。然\n后用如下命令编译\ngcc -Wall -pipe -O3 -o getinfo getinfo.c -lsocket -lnsl\n--------------------------------------------------------------------------\n/*\n* display info about network interfaces\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/socket.h&gt;\n/*\n* 对于Solaris移植，必须包含该头文件\n*/\n#include &lt;sys/sockio.h&gt;\n#include &lt;sys/ioctl.h&gt;\n#include &lt;net/if.h&gt;\n#include &lt;net/if_arp.h&gt;\n#include &lt;arpa/inet.h&gt;\n#define inaddrr( x ) ( *( struct in_addr * )&amp;ifr-&gt;x[ sizeof( sa.sin_port ) ] )\n/*\n* 注意，这里IFRSIZE是变化的，依赖于size的取值\n*/\n#define IFRSIZE      ( ( int )( size * sizeof( struct ifreq ) ) )\nint main ( void )\n{\nunsigned char *    u;\nint                sockfd, size = 1;\nstruct ifreq *     ifr;\nstruct ifconf      ifc;\nstruct sockaddr_in sa;\nif ( 0 &gt; ( sockfd = socket( AF_INET, SOCK_DGRAM, IPPROTO_IP ) ) )\n{\nfprintf( stderr, \"Cannot open socket.\\n\" );\nexit( EXIT_FAILURE );\n}\nifc.ifc_req = NULL;\ndo\n{\n++size;\n/*\n* realloc buffer size until no overflow occurs\n*/\nif ( NULL == ( ifc.ifc_req = realloc( ifc.ifc_req, IFRSIZE ) ) )\n{\nfprintf( stderr, \"Out of memory.\\n\" );\nexit( EXIT_FAILURE );\n}\nifc.ifc_len = IFRSIZE;\nif ( ioctl( sockfd, SIOCGIFCONF, &amp;ifc ) )\n{\nperror( \"ioctl SIOCFIFCONF\" );\nexit( EXIT_FAILURE );\n}\n} while ( IFRSIZE &lt;= ifc.ifc_len );\nifr = ifc.ifc_req;\nfor ( ; ( char * )ifr &lt; ( char * )ifc.ifc_req + ifc.ifc_len; ++ifr )\n{\nif ( ifr-&gt;ifr_addr.sa_data == ( ifr + 1 )-&gt;ifr_addr.sa_data )\n{\n/*\n* duplicate, skip it\n*/\ncontinue;\n}\nif ( ioctl( sockfd, SIOCGIFFLAGS, ifr ) )\n{\n/*\n* failed to get flags, skip it\n*/\ncontinue;\n}\nprintf( \"Interface:  %s\\n\", ifr-&gt;ifr_name );\nprintf( \"IP Address: %s\\n\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) );\n{\n/*\n* added by scz &lt;scz@nsfocus.com&gt; 2001-02-22\n*/\nint                  s;\nstruct arpreq        arpreq;\nstruct sockaddr_in * psa;\ns = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );\nif ( s == -1 )\n{\n/*\n* perror( \"socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP )\" );\n*/\n}\nelse\n{\nmemset( &amp;arpreq, 0, sizeof( struct arpreq ) );\npsa             = ( struct sockaddr_in * )&amp;arpreq.arp_pa;\npsa-&gt;sin_family = AF_INET;\n/*\n* IP地址\n*/\npsa-&gt;sin_addr   = inaddrr( ifr_addr.sa_data );\nif ( ioctl( s, SIOCGARP, &amp;arpreq ) == -1 )\n{\n/*\n* perror( \"SIOCGARP\" );\n*/\n}\nelse\n{\nu = ( unsigned char * )&amp;arpreq.arp_ha.sa_data;\nprintf( \"HW Address: %02x:%02x:%02x:%02x:%02x:%02x\\n\",\nu[0], u[1], u[2], u[3], u[4], u[5] );\n}\nclose( s );\n}\n}\nif ( 0 == ioctl( sockfd, SIOCGIFNETMASK, ifr ) &amp;&amp;\nstrcmp( \"255.255.255.255\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) ) )\n{\nprintf( \"Netmask:    %s\\n\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) );\n}\n/*\n* 如果设置了广播地址，才继续ioctl\n*/\nif ( ifr-&gt;ifr_flags &amp; IFF_BROADCAST )\n{\nif ( 0 == ioctl( sockfd, SIOCGIFBRDADDR, ifr ) &amp;&amp;\nstrcmp( \"0.0.0.0\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) ) )\n{\nprintf( \"Broadcast:  %s\\n\", inet_ntoa( inaddrr( ifr_addr.sa_data ) ) );\n}\n}\nif ( 0 == ioctl( sockfd, SIOCGIFMTU, ifr ) )\n{\n/*\n* 由于MTU是一个int，而Solaris的&lt;net/if.h&gt;联合中没有定义相应成员，\n* 所以用ifr_metric(也是一个int)代替，对于联合，这是无所谓的\n*/\nprintf( \"MTU:        %u\\n\", ifr-&gt;ifr_metric );\n}\nif ( 0 == ioctl( sockfd, SIOCGIFMETRIC, ifr ) )\n{\nprintf( \"Metric:     %u\\n\", ifr-&gt;ifr_metric );\n}\nprintf( \"\\n\" );\n}  /* end of for */\nclose( sockfd );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n这里演示的技术适用于普通用户，不再需要root权限ifconfig -a查看本机MAC地址。\nA: 小四 &lt;scz@nsfocus.com&gt; 2001-12-18 00:49\n前面演示了x86/Linux、SPARC/Solaris上如何获取某些网卡配置信息，昨天发现在\nx86/FreeBSD上大有不同，确切地说，是Berkeley-derived实现与System V实现有不\n少区别，更多细节请参看&lt;&lt;Unix Network Programming&gt;&gt;卷I的16.6节以及17章。重\n写代码如下\n--------------------------------------------------------------------------\n/*\n* Copyright (c) 1983, 1993\n* The Regents of the University of California. All rights reserved.\n* -----------------------------------------------------------------------\n*\n* gcc -static -Wall -pipe -O3 -o freebsd_ifconfig freebsd_ifconfig.c\n* strip freebsd_ifconfig\n*\n* Fix  : NSFocus Security Team\n*      : http://www.nsfocus.com\n*      : scz@nsfocus.com\n* Date : 2001-12-19 16:27\n*/\n/************************************************************************\n*                                                                      *\n*                               Head File                              *\n*                                                                      *\n************************************************************************/\n#define _GNU_SOURCE\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;     /* 使用getopt(3) man -S 3 getopt */\n#include &lt;err.h&gt;        /* for errx()                    */\n#include &lt;sys/param.h&gt;  /* for htonl()                   */\n#include &lt;sys/ioctl.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/sysctl.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;sys/module.h&gt;\n#include &lt;sys/linker.h&gt;\n#include &lt;net/ethernet.h&gt;\n#include &lt;net/if.h&gt;\n#include &lt;net/if_var.h&gt;\n#include &lt;net/if_dl.h&gt;\n#include &lt;net/if_types.h&gt;\n#include &lt;net/route.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;netinet/in_var.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;netdb.h&gt;\n#include &lt;errno.h&gt;\n/************************************************************************\n*                                                                      *\n*                               Macro                                  *\n*                                                                      *\n************************************************************************/\ntypedef void af_status __P( ( int, struct rt_addrinfo * ) );\n/*\n* Expand the compacted form of addresses as returned via the\n* configuration read via sysctl().\n*/\n#define ROUNDUP(a) ((a) &gt; 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))\n#define ADVANCE(x, n) (x += ROUNDUP((n)-&gt;sa_len))\n#define IFFBITS \"\\020\\1UP\\2BROADCAST\\3DEBUG\\4LOOPBACK\\7RUNNING\" \"\\10NOARP\\11PROMISC\\13OACTIVE\\20MULTICAST\"\n/************************************************************************\n*                                                                      *\n*                            Function Prototype                        *\n*                                                                      *\n************************************************************************/\nstatic void ether_status ( int s __unused, struct rt_addrinfo *info );\nstatic void in_status    ( int s __unused, struct rt_addrinfo *info );\nstatic void rt_xaddrs    ( caddr_t cp, caddr_t cplim, struct rt_addrinfo *info );\nstatic void showflags    ( unsigned int v, const char *bits );\nstatic void status       ( int addrcount, struct sockaddr_dl *sdl,\nstruct if_msghdr *ifm, struct ifa_msghdr *ifam );\nstatic void usage        ( char *arg );\n/************************************************************************\n*                                                                      *\n*                            Static Global Var                         *\n*                                                                      *\n************************************************************************/\n/*\n* Known address families\n*/\nstatic const struct afswtch\n{\nconst char   *af_name;\nshort         af_af;\naf_status    *af_status;\n} afs[] =\n{\n{ \"inet\", AF_INET, in_status, },\n{ \"ether\", AF_LINK, ether_status, },\n{ 0, 0, 0, }\n};\n/*\n* 接口名，比如fxp0\n*/\nstatic char          name[32];\nstatic char         *interface = NULL;\nstatic int           flags;\nstatic struct ifreq  ifr;\n/************************************************************************/\n/*\n* __unused避免Warning信息\n*/\nstatic void ether_status ( int s __unused, struct rt_addrinfo *info )\n{\nchar               *cp;\nint                 n;\nstruct sockaddr_dl *sdl = ( struct sockaddr_dl * )info;\n/*\n* 经过宏处理，cp指向MAC地址\n*/\ncp = ( char * )LLADDR( sdl );\n/*\n* 靠成员sdl_alen标识长度\n*/\nif ( ( n = sdl-&gt;sdl_alen ) &gt; 0 )\n{\nfprintf( stderr, \"MAC       : \" );\nwhile ( --n &gt;= 0 )\n{\nfprintf( stderr, \"%02X%c\", *cp++ &amp; 0xff, n &gt; 0 ? ‘:‘ : ‘\\n‘ );\n}\n}\n}  /* end of ether_status */\nstatic void in_status ( int s __unused, struct rt_addrinfo *info )\n{\nstruct sockaddr_in *sin, null_sin;\nmemset( &amp;null_sin, 0, sizeof( null_sin ) );\n/*\n* IP地址(CIDR)\n*\n* 参看UNP vol I 图17.8 理解这个函数\n*/\nsin = ( struct sockaddr_in * )info-&gt;rti_info[ RTAX_IFA ];\nfprintf( stderr, \"IP        : %s/\", inet_ntoa( sin-&gt;sin_addr ) );\n/*\n* 子网掩码\n*/\nsin = ( struct sockaddr_in * )info-&gt;rti_info[ RTAX_NETMASK ];\nif ( !sin )\n{\nsin = &amp;null_sin;\n}\nfprintf( stderr, \"%s/\", inet_ntoa( sin-&gt;sin_addr ) );\n/*\n* 广播地址\n*/\nsin = ( struct sockaddr_in * )info-&gt;rti_info[ RTAX_BRD ];\nif ( !sin )\n{\nsin = &amp;null_sin;\n}\nfprintf( stderr, \"%s\\n\", inet_ntoa( sin-&gt;sin_addr ) );\n}  /* end of in_status */\n/*\n* 第二形参指定上限\n*\n* 参看 UNP vol I 图17.9 的代码理解这里\n*/\nstatic void rt_xaddrs ( caddr_t cp, caddr_t cplim, struct rt_addrinfo *info )\n{\nstruct sockaddr *sa;\nint              i;\n/*\n* 指针数组清零\n*/\nmemset( info-&gt;rti_info, 0, sizeof( info-&gt;rti_info ) );\nfor ( i = 0; ( i &lt; RTAX_MAX ) &amp;&amp; ( cp &lt; cplim ); i++ )\n{\n/*\n* rti_addrs是个掩码的概念\n*/\nif ( ( info-&gt;rti_addrs &amp; ( 1 &lt;&lt; i ) ) == 0 )\n{\ncontinue;\n}\n/*\n* 指针数组赋值\n*/\ninfo-&gt;rti_info[ i ] = sa = ( struct sockaddr * )cp;\nADVANCE( cp, sa );\n}\nreturn;\n}  /* end of rt_xaddrs */\nstatic void showflags ( unsigned int v, const char *bits )\n{\nregister int  i, any = 0;\nregister char c;\nif ( *bits == 8 )\n{\nfprintf( stderr, \"Flags     : %#o \", v );\n}\nelse\n{\nfprintf( stderr, \"Flags     : %#x \", v );\n}\nbits++;\nfprintf( stderr, \"&lt;\" );\nwhile ( ( i = *bits++ ) != ‘\\0‘ )\n{\n/*\n* 这后面是掩码的概念\n*/\nif ( v &amp; ( 1 &lt;&lt; ( i - 1 ) ) )\n{\nif ( any )\n{\nfprintf( stderr, \",\" );\n}\nany = 1;\nfor ( ; ( c = *bits ) &gt; 32; bits++ )\n{\nfprintf( stderr, \"%c\", c );\n}\n}\nelse\n{\nfor ( ; *bits &gt; 32; bits++ )\n{\n;\n}\n}\n}  /* end of while */\nfprintf( stderr, \"&gt;\\n\" );\nreturn;\n}  /* end of showflags */\n/*\n* Print the status of the interface. If an address family was specified,\n* show it and it only; otherwise, show them all.\n*/\nstatic void status ( int addrcount, struct sockaddr_dl *sdl,\nstruct if_msghdr *ifm, struct ifa_msghdr *ifam )\n{\nstruct rt_addrinfo    info;\nconst struct afswtch *afp;\nconst struct afswtch *p = NULL;\nint                   s;\nfprintf( stderr, \"\\nInterface : %s\\n\", name );\nshowflags( flags, IFFBITS );\nafp                    = &amp;afs[0];\nifr.ifr_addr.sa_family = AF_INET;\nstrncpy( ifr.ifr_name, name, sizeof( ifr.ifr_name ) );\nif ( ( s = socket( ifr.ifr_addr.sa_family, SOCK_DGRAM, 0 ) ) &lt; 0 )\n{\nerr( 1, \"socket\" );\n}\nif ( ioctl( s, SIOCGIFMETRIC, ( caddr_t )&amp;ifr ) == 0 )\n{\nfprintf( stderr, \"Metric    : %d\\n\", ifr.ifr_metric );\n}\nif ( ioctl( s, SIOCGIFMTU, ( caddr_t )&amp;ifr ) == 0 )\n{\nfprintf( stderr, \"MTU       : %d\\n\", ifr.ifr_mtu );\n}\nwhile ( addrcount &gt; 0 )\n{\n/*\n* rti_addrs是个掩码的概念\n*/\ninfo.rti_addrs = ifam-&gt;ifam_addrs;\n/*\n* Expand the compacted addresses\n*\n* 第二形参指定上限，第一形参指向 struct ifa_msghdr 之后的位置\n*/\nrt_xaddrs( ( char * )( ifam + 1 ), ( char * )ifam + ifam-&gt;ifam_msglen,\n&amp;info );\nfor ( p = afs; p-&gt;af_name; p++ )\n{\nif ( info.rti_info[ RTAX_IFA ]-&gt;sa_family == p-&gt;af_af )\n{\n/*\n* 一个函数指针\n*/\n( *p-&gt;af_status )( s, &amp;info );\n}\n}\naddrcount--;\nifam = ( struct ifa_msghdr * )( ( char * )ifam + ifam-&gt;ifam_msglen );\n}  /* end of while */\n/*\n* 第二形参做强加型转换，仅仅是为了统一到struct afswtch中\n*/\nether_status( s, ( struct rt_addrinfo * )sdl );\nclose( s );\nreturn;\n}  /* end of status */\nstatic void usage ( char *arg )\n{\nfprintf( stderr, \"Usage: %s [-i &lt;interface&gt;]\\n\", arg );\nexit( EXIT_FAILURE );\n}  /* end of usage */\nint main ( int argc, char * argv[] )\n{\nint                  c;\nint                  addrcount;\nint                  mib[6];\nsize_t               need      = 0;\nchar                *buf       = NULL;\nchar                *lim, *next;\nstruct  if_msghdr   *ifm;\nstruct  ifa_msghdr  *ifam, *nextifam;\nstruct  sockaddr_dl *sdl;\nopterr = 0;  /* don‘t want getopt() writing to stderr */\nwhile ( ( c = getopt( argc, argv, \"hi:\" ) ) != EOF )\n{\nswitch ( c )\n{\ncase ‘i‘:\ninterface = optarg;\nbreak;\ncase ‘h‘:\ncase ‘?‘:\nusage( argv[0] );\nbreak;\n}  /* end of switch */\n}  /* end of while */\nargc -= optind;\nargv += optind;\n/*\n* 参看&lt;&lt;Unix Network Programming&gt;&gt; vol I 17章\n*/\nmib[0] = CTL_NET;\nmib[1] = PF_ROUTE;\nmib[2] = 0;\nmib[3] = 0;  /* address family */\nmib[4] = NET_RT_IFLIST;\nmib[5] = 0;\n/*\n* first get size, we should do the second call，返回值在need中\n*/\nif ( sysctl( mib, 6, NULL, &amp;need, NULL, 0 ) &lt; 0 )\n{\nerrx( 1, \"first sysctl\" );\n}\nif ( ( buf = ( char * )malloc( need ) ) == NULL )\n{\nerrx( 1, \"malloc\" );\n}\nif ( sysctl( mib, 6, buf, &amp;need, NULL, 0 ) &lt; 0 )\n{\nerrx( 1, \"second sysctl\");\n}\nlim  = buf + need;\nnext = buf;\nwhile ( next &lt; lim )\n{\nifm = ( struct if_msghdr * )next;\n/*\n* 每个接口一个RTM_IFINFO\n*/\nif ( ifm-&gt;ifm_type == RTM_IFINFO )\n{\n/*\n* struct sockaddr_dl 位于 struct if_msghdr 之后\n*/\nsdl   = ( struct sockaddr_dl * )( ifm + 1 );\n/*\n* flags 位于 struct if_msghdr 之中\n*/\nflags = ifm-&gt;ifm_flags;\n}\nelse\n{\nfprintf( stderr, \"Some error\\n\" );\nexit( EXIT_FAILURE );\n}\nnext      += ifm-&gt;ifm_msglen;\nifam       = NULL;\naddrcount  = 0;\nwhile ( next &lt; lim )\n{\n/*\n* 参看UNP vol I 图17.13，理解这里的while循环\n*/\nnextifam = ( struct ifa_msghdr * )next;\n/*\n* 本接口每个已配置的IP对应一个RTM_NEWADDR\n*/\nif ( nextifam-&gt;ifam_type != RTM_NEWADDR )\n{\nbreak;\n}\n/*\n* ifam指向本接口IP链表的第一个位置\n*/\nif ( ifam == NULL )\n{\nifam = nextifam;\n}\n/*\n* 统计IP个数，包括主IP\n*/\naddrcount++;\nnext += nextifam-&gt;ifam_msglen;\n}  /* end of while */\n/*\n* 接口名，比如fxp0，注意这里不以‘\\0‘结尾，靠成员sdl_nlen标识长度\n*/\nstrncpy( name, sdl-&gt;sdl_data, sdl-&gt;sdl_nlen );\nname[ sdl-&gt;sdl_nlen ] = ‘\\0‘;\nif ( NULL == interface )\n{\n/*\n* 遍历所有接口\n*/\nstatus( addrcount, sdl, ifm, ifam );\n}\nelse\n{\nif ( strcmp( interface, name ) == 0 )\n{\n/*\n* 检查指定接口\n*/\nstatus( addrcount, sdl, ifm, ifam );\n}\n}\n}  /* end of while */\nfree( buf );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n/************************************************************************/\n--------------------------------------------------------------------------\nA: Sun Microsystems 2001-01-03\n如果不想通过ARP表获取MAC地址，就只能通过DLPI实现。此时必须以root身份运行该\n程序。\n--------------------------------------------------------------------------\n/*\n* Usage : &lt;program name&gt; &lt;device name&gt; &lt;instance number&gt;\n*\n* The program opens the Data Link provider, attaches to the PPA (Physical\n* Point of Attachment) &amp; uses the DL_PHYS_ADDR_REQ DLPI primitive to\n* request the current physical address which is returned in the\n* DL_PHYS_ADDR_ACK message. The MAC address is converted to ASCII format\n* using the ether_ntoa(3N) function and printed.\n*\n* The program needs to be compiled with the \"-lsocket -lnsl\" flags.\n* # gcc -Wall -pipe -O3 -o ether ether.c -lsocket -lnsl\n*\n* The output of the program will be as shown below.\n*\n* # ./ether /dev/hme 0\n* Mac Address 8:0:20:a8:2e:ac\n*\n* This program has been tested on SPARC machines running Solaris 2.5.1,\n* 2.6, 7 and 8 with the /dev/le and /dev/hme interfaces.\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stropts.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;net/if.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;netinet/if_ether.h&gt;\n#include &lt;sys/errno.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/dlpi.h&gt;\n#define MAXDLBUF 256\nint                  ppa, fd, flags, errno;\nlong                 buffer[ MAXDLBUF ];\nstruct strbuf        ctl;\ndl_phys_addr_req_t   phys_addr_req;\ndl_attach_req_t      attach_req;\ndl_phys_addr_ack_t * dlpadd;\nint main ( int argc, char * argv[] )\n{\nif ( argc != 3 )\n{\nprintf( \"Usage : &lt;program name&gt; &lt;device name&gt; &lt;instance number&gt;\\n\" );\nexit( 1 ) ;\n}\nif ( geteuid() != 0 )\n{\nprintf( \"Must be root.\\n\" );\nexit( 1 );\n}\nif ( ( fd = open( argv[1], O_RDWR, 0 ) ) &lt; 0 )\n{\nprintf( \"Open of Device %s failed\\n\", argv[1] );\nexit( 1 );\n}\nppa                     = atoi( argv[2] );\nattach_req.dl_primitive = DL_ATTACH_REQ;\nattach_req.dl_ppa       = ppa;\nctl.maxlen = 0;\nctl.len    = sizeof( attach_req );\nctl.buf    = ( char * )&amp;attach_req;\nflags      = 0;\nif ( putmsg( fd, &amp;ctl, ( struct strbuf * )NULL, flags ) &lt; 0 )\n{\nperror( \"dlattachreq error\\n\" );\nreturn( errno );\n}\nctl.maxlen = MAXDLBUF;\nctl.len    = 0;\nctl.buf    = ( char * )&amp;buffer;\nif ( getmsg( fd, &amp;ctl, ( struct strbuf * )0, &amp;flags ) &lt; 0 )\n{\nperror( \"dlattachack error\\n\" );\nreturn( errno );\n}\nif ( ctl.len &gt; sizeof( dl_ok_ack_t ) )\n{\nprintf( \"dlattachokack too long\\n\" );\nexit( -1 );\n}\nif ( flags != RS_HIPRI )\n{\nprintf( \"dlattachokack not RS_HIPRI\\n\" );\nexit( -1 );\n}\nif ( ctl.len &lt; sizeof( dl_ok_ack_t ) )\n{\nprintf( \"dlattachokack too short\\n\" );\nexit( -1 );\n}\nphys_addr_req.dl_primitive = DL_PHYS_ADDR_REQ;\nphys_addr_req.dl_addr_type = DL_CURR_PHYS_ADDR;\nctl.maxlen = 0;\nctl.len    = sizeof( phys_addr_req );\nctl.buf    = ( char * ) &amp;phys_addr_req;\nflags      = 0;\nif ( putmsg( fd, &amp;ctl, ( struct strbuf * )NULL, flags ) &lt; 0 )\n{\nperror( \"dlphysaddreq error\\n\" );\nreturn( errno );\n}\nctl.maxlen = MAXDLBUF;\nctl.len    = 0;\nctl.buf    = ( char * ) buffer;\nif ( getmsg( fd, &amp;ctl, ( struct strbuf * )0, &amp;flags ) &lt; 0 )\n{\nperror( \"dlinfoack error\\n\" );\nreturn( errno );\n}\nif ( flags != RS_HIPRI )\n{\nprintf( \"dlgetpyhsaddr not RS_HIPRI\\n\" );\nexit( -1 );\n}\nif ( ctl.len &lt; sizeof( dl_phys_addr_ack_t ) )\n{\nprintf( \"dlgetphysaddr too short\\n\" );\nexit( -1 );\n}\ndlpadd = ( dl_phys_addr_ack_t * )ctl.buf;\nprintf( \"Mac Address %s\\n\",\n( char * )ether_ntoa( ctl.buf + dlpadd-&gt;dl_addr_offset ) );\nreturn( 0 );\n}  /* end of main */\n--------------------------------------------------------------------------\nD: scz &lt;scz@nsfocus.com&gt; 2001-11-20 11:46\nSPARC/Solaris下只有root用户才可以ifconfig -a看到本机MAC地址，普通用户并不\n能这样做，但可以尝试在dmesg输出中查找，由于dmesg使用的数据有可能被破坏，这\n个办法并不可靠。\n\"arp &lt;本机IP地址&gt;\"可以看到本机MAC地址，使用的技术实际上就是前面编程演示的\nioctl( s, SIOCGARP, &amp;arpreq )\n此外还可以用如下命令获取本机MAC地址\nndd /dev/arp arp_cache_report | grep MYADDR\nD: scz 2002-07-05 19:02\n对于Solaris 7/8，netstat -np | grep SP 可以看到本机MAC地址、IP地址\n$ netstat -np | grep SP | awk ‘{print $2}‘\n192.168.5.150\n$ netstat -np | grep SP | awk ‘{print $5}‘\n00:00:00:03:03:03\n$\n10.2 如何在Sun工作站上安装3块网卡\nQ: 我想在Sun工作站上安装3块网卡，怎么办\nA: Santosh\n请遵循如下步骤\n1) 在Sun工作站上增加网卡\n2) 用boot -r启动系统\n3) 观察启动信息，确认每块网卡都被识别出来，比如这种信息\nPCI-device: network@1,1, hme #0\nSUNW,hme0 is /pci@1f,4000/network@1,1\n实际中如果每块网卡都被识别出来，有hme0、hme1 和 hme2，当然1和2可能不是\n这个名字。\n4) 到/etc目录下创建hostname.hme0、hostname.hme1 和 hostname.hme2。在每个文\n件中分别指定IP地址，编辑/etc/hosts文件增加相应入口。\n5) 重启机器\n10.3 如何在Solaris x86上安装网卡驱动\nA: James Adkins &lt;jadkins@peregrine.com&gt;\n不需要修改\"pcn.conf\"文件。开始我只是\"touch /reconfigure\"，Solaris x86检测\n到了网卡，但是\"ifconfig -a\"的时候只有loopback接口，于是我尝试如下步骤：\n# drvconfig\n# devlinks\n# touch /reconfigure\n重启动后一切ok\nD: scz &lt;scz@nsfocus.com&gt; 2003-04-23\n在VMware上安装x86/Solaris，有时系统崩溃后网卡工作不正常，我是这样恢复正常\n的:\ndrvconfig\ndevlinks\ntouch /reconfigure\nhalt\n去VMware中删除网卡，重启动，再次执行:\ndrvconfig\ndevlinks\ntouch /reconfigure\nhalt\n去VMware中增加网卡，重启动，发现网卡恢复正常。\n10.4 Solaris 单网卡多IP(以太网卡别名)\nQ: 对于Solaris 2.5.1来说，可以在一块物理网卡上配置多个IP地址\nA: Sun Microsystems 1998-03-31\n下面以lance ethernet (le0) 设备为例说明\n1) 编辑/etc/hosts文件\n128.195.10.31 myhost\n128.195.10.46 myhost2\n128.195.10.78 myhost3\n2) 创建/etc/hostname.le0:n文件，注意hostname.le0:0就是hostname.le0\n/etc/hostname.le0   (Contains name myhost)\n/etc/hostname.le0:1 (Contains name myhost2)\n/etc/hostname.le0:2 (Contains name myhost3)\n注意这种文件就一行内容，主机名。\n3) 如果想立即生效\n% ifconfig le0:1 up\n% ifconfig le0:1 129.153.76.72\n% ifconfig le0:1 down\nQ: Solaris 8下如何给一块以太网卡赋予多个IP地址？\nA: Vadim V. Kouevda &lt;VKouevda@pcinetgw.is.bear.com&gt;\nifconfig le0 plumb\nifconfig le0 ether 0:1:2:3:4:5\nifconfig le0:1 plumb\nifconfig le0:1 ... up\nifconfig le0:2 plumb\nifconfig le0:2 ... up\n到/etc/init.d目录下修改IP地址、子网掩码等设置。\nD: scz &lt;scz@nsfocus.com&gt;\n有三个文件需要注意，/etc/rcS.d/S30rootusr.sh(/etc/init.d/rootusr)、\n/etc/rc2.d/S69inet(/etc/init.d/inetinit)和/etc/rc2.d/S72inetsvc\n(/etc/init.d/inetsvc)。\nQ: 如何在一块物理网卡上绑定多个IP地址\nA: Sun Microsystems 1997-10-27\n所谓虚拟网络接口指一个物理接口多个不同IP地址，Solaris允许一个物理网络接口\n对应多个逻辑接口，换句话说，即使只有一块网卡，也可以配置多个IP地址。参看\nifconfig(1M)手册页。对于Solaris 2.x，可以在一块网卡上绑定256个不同IP地址。\nSun OS 4.x(Solaris 1.x)不支持。\n/usr/sbin/ndd -get /dev/ip ip_addrs_per_if\n对于Solaris 2.6，通过ndd可以配置超过256(0-255)个IP地址。\n/usr/sbin/ndd -set /dev/ip ip_addrs_per_if 1-8192\n将这条命令增加到/etc/rc2.d/S69inet启动脚本中去。\n1) 编辑/etc/hosts文件(或者nis host map)，为每个虚拟接口增加条目。别忘记修\n改NIS、NIS+、DNS数据库。\n2) 为每个接口创建/etc/hostname.&lt;interface:#&gt;文件，比如/etc/hostname.le0:1、\nhostname.le0:2、hostname.le0:3 ... le0:255。文件内容为单行IP地址或者主\n机名。比如创建如下文件\n/etc/hostname.le0:1  (不要使用le0:0，那就是le0)\n/etc/hostname.le0:2\nSolaris 2.5.1下最多1024个虚拟接口。每个文件内容是自己对应的虚拟接口IP地\n址或者主机名。\n3) 如果使用了子网，应该在/etc/netmasks中增加\nnetwork_address  netmask\n157.145.0.0  255.255.255.0\n4) 重启系统\n5) ifconfig -a验证之\n某些第三方应用程序此时可能会出问题。出于安全考虑，可以\nndd -set /dev/ip ip_forwarding 0\nndd -set /dev/ip ip_strict_dst_multihoming 1\n参看RFC1112 - &lt;&lt;Host Extensions for IP Multicasting&gt;&gt;。\n如果因为配置虚拟接口出现不期望的路由，考虑手动\"route delete\"。可以增加一个\n启动脚本/etc/rc2.d/S99vif，用于完成这些任务。\n对于Solaris 2.6，可能还需要\nndd -set /dev/ip ip_enable_group_ifs 0 (2.6下缺省是1，7下缺省是0)\n将这条命令增加到/etc/rc2.d/S69inet启动脚本中去。\nQ: 如何创建1024个虚拟网络接口\nA: Sun Microsystems 2001-03-22\n下面是一个启动脚本举例\n1) 在/etc/rc2.d/S69inet的最后增加如下内容\nif [ -f /test_up ]\nthen\n/test_up\nfi\n2) 创建文件\"/test_up\"，使之可执行，增加如下内容\n--------------------------------------------------------------------------\n#! /bin/ksh\nif [ $# -ne 1 ] ; then\necho \"Usage: $0 &lt;up | down&gt;\"\nexit 1\nfi\n# set this value to the number of logical interfaces you want per physical\n# interfaces\n# 5意味着五个逻辑接口(不包括那个物理接口)\ntypeset -i N=5\n#set these to the IP addrs you want to configure\ntypeset -i IP3=192\ntypeset -i IP2=168\ntypeset -i IP1=10\ntypeset -i IP0=102\ntypeset -i n=1\n# set this value to the number of logical interfaces you want per physical\n# interfaces\nndd -set /dev/ip ip_addrs_per_if `/usr/bin/expr $N + 1`\n# set this to the correct type of physical interface\nPIF=hme0\nwhile [ $n -le $N ]\ndo\naddr=\"$IP3.$IP2.$IP1.$IP0\"\nifconfig $PIF:$n plumb\nifconfig $PIF:$n inet $addr netmask 255.255.0.0 broadcast 192.168.255.255 $1\nIP0=IP0+1\nif [  IP0 -eq 254 ]\nthen\nIP0=1\nIP1=IP1+1\nif ((IP1==254))\nthen\nIP1=0\nIP2=IP2+1\nfi\nfi\nn=n+1\ndone\n--------------------------------------------------------------------------\n10.5 如何修改主机名(hostname)\nQ: Solaris 2.6下如何修改主机名(hostname)\nA: Herve Poussin &lt;poussin@partner-system.com&gt;\n需要修改如下文件\n/etc/hosts\n/etc/hostname.&lt;interface&gt;\n/etc/nodename\n/etc/net/*/hosts (3 files, man -s 7D ticotsord)\n如果你运行在VxVM下，则应该\n# vxdctl hostid &lt;new_name&gt;\n# vxdctl init &lt;new_name&gt;\n10.6 SPARC/Solaris 2.5/2.6/7/8下如何设置网卡100Mb全双工\nQ: 我从SPARC连接3Com交换机时，总是使用半双工，如何配置网卡强行使用100Mb全\n双工\nA: Martin Scerri &lt;martin_scerri@bigfoot.com&gt;\n下列回答来自\"Sun管理员FAQ 12.3\"，并且只适合于Solaris 2.5及其以后版本，\nSun OS 4.x及其更早版本不支持hme接口。\n一般网卡可以和交换机自动协商使用100Mb全双工，如果协商失败，可能看到诸如\n\"late collision\"一类的消息，出现丢包甚至完全不能工作的现象。为了强行指定使\n用某一确定的工作模式，比如100Mb FD，可以用ndd做如下操作：\n# 指定操作hme0接口\nndd -set /dev/hme instance 0\n# 关闭自动协商\nndd -set /dev/hme adv_autoneg_cap  0\n# 打开100Mb FD支持\nndd -set /dev/hme adv_100fdx_cap   1\n# 关闭100Mb HD支持\nndd -set /dev/hme adv_100hdx_cap   0\n# 关闭10Mb FD支持\nndd -set /dev/hme adv_10fdx_cap    0\n# 关闭10Mb HD支持\nndd -set /dev/hme adv_10hdx_cap    0\n同样需要在对端(比如交换机)强行指定使用100Mb FD模式。\n注意：Fast ethernet hubs 总是使用100Mb HD模式\nethernet hubs 总是使用10Mb HD模式\n如果你想强行指定系统中所有hme网卡在启动时进入同一确定模式，可以在\n/etc/system文件中设置，下例表示进入100Mbit FD模式：\nset hme:hme_adv_autoneg_cap=0\nset hme:hme_adv_100fdx_cap=1\nset hme:hme_adv_100hdx_cap=0\nset hme:hme_adv_10hdx_cap=0\nset hme:hme_adv_10fdx_cap=0\nA: Andreas.Gouder &lt;Andreas.Gouder@t-online.de&gt;\n你可以用如下命令获取当前设置\n# ndd -get /dev/hme link_mode\n0 半双工\n1 全双工\n# ndd -get /dev/hme link_status\n0 Link Down\n1 Link up\n# ndd -get /dev/hme link_speed\n0 10Mbps\n1 100Mbps\n10.7 Unix如何对抗ARP欺骗\nQ: Solaris的静态ARP表项(arp -s)还是会被动态刷新，我只确认Linux/FreeBSD的静\n态ARP表项不会被动态刷新，到底有没有稍微通用点的对抗ARP欺骗攻击的方法。\nA: scz &lt;scz@nsfocus.com&gt;\n下面以Solaris系统为例说明，其他系统大同小异。\n1) 建立静态ARP表\n/usr/bin/touch /etc/static_arp_entry\n/usr/bin/chown root:root /etc/static_arp_entry\n/usr/bin/chmod 600 /etc/static_arp_entry\n编辑/etc/static_arp_entry文件，输入类似内容\n192.168.8.90    00:00:00:11:11:11\n/usr/sbin/arp -s -f /etc/static_arp_entry\n可以在/etc/rc2.d/S69inet启动脚本中增加这条命令。参看arp(1M)、arp(7P)手册页\n了解更多细节。这种技术对系统影响不大，对网络影响较大，破坏了动态ARP解析过\n程。Solaris系统中，静态ARP表不会过期，必须用\"arp -d\"手动删除。但是，\nSolaris系统的静态ARP表项可以被动态刷新，仅仅依靠静态ARP表项并不能对抗ARP欺\n骗攻击，相反纵容了ARP欺骗攻击，因为虚假的静态ARP表项不会自动超时消失。当然，\n可以考虑利用cron机制补救之。(增加一个crontab)\n为了对抗ARP欺骗攻击，对于Solaris系统来说，应该结合\"禁止相应网络接口做ARP解\n析\"和\"使用静态ARP表\"的设置\n2) 禁止某个网络接口做ARP解析(对抗ARP欺骗攻击)\n\"/sbin/ifconfig hme0 -arp\"命令将禁止hme0接口做ARP解析，hme0接口不会发送/接\n收ARP报文。必须配合使用静态ARP表，否则无法完成正常网络通信。参看\nifconfig(1M)了解更多细节。假设/etc/rc2.d/S69inet启动脚本中存在如下内容\n/sbin/ifconfig hme0 -arp\n/usr/sbin/arp -s -f /etc/static_arp_entry\n假设/etc/static_arp_entry文件内容如下\n192.168.8.90    00:00:00:11:11:11\n这里192.168.8.90是一台PWin98，也做静态ARP设置(因为对方不会响应ARP请求报文)\narp -s 192.168.10.6 08-00-20-a8-2e-ac\n此时192.168.8.90与192.168.10.6可以正常通信，并且192.168.10.6不受ARP欺骗攻\n击的影响。事实上，绝大多数Unix操作系统，都可以结合\"禁止相应网络接口做ARP解\n析\"和\"使用静态ARP表\"的设置来对抗ARP欺骗攻击。对于Linux/FreeBSD系统，因为其\n静态ARP表项(arp -s)不会被动态刷新，所以不需要\"禁止相应网络接口做ARP解析\"即\n可对抗ARP欺骗攻击。\n10.8 SPARC/Solaris 2.6/7/8下如何检查网卡混杂模式\n10.9 FreeBSD下ifconfig的man手册\n10.10 FreeBSD下arp的man手册\n10.11 x86/Solaris如何强制设定网卡速率\nQ: x86/Solaris，我如何强行指定网卡的工作状态为100Mbps full-duplex，ndd(1M)\n不工作\nA: CERNET 水木清华 Unix版 inc 2001-10-11 20:29\nx86/Solaris下的网卡驱动不支持ndd(1M)设置网卡工作状态，要达到目的，唯一的办\n法是通过driver.conf(4)指定。x86/Solaris 8的iprb(7D)手册页建议使用\nForceSpeedDuplex选项。对于其它驱动，参看如下例子\nvi /kernel/drv/iprb.conf  &lt;-- 用ifconfig -a确认一下\n# To force full duplex operation, uncomment the following line:\n# full-duplex=1;\n#\n# To force half duplex operation, uncomment the following line:\n# full-duplex=0;\n#\n# To force 10Mbps operation, uncomment the following line:\n# speed=10;\n#\n# To force 100Mbps operation, uncomment the following line:\n# speed=100;\n奇怪的是iprb.conf原来没有上面的内容，elxl.conf却有。注意，不同网卡是有区别\n的，我试了RealTek RTL8139/8129、3Com 3C905B TX、Intel，只有Intel的可以这样\n修改，RealTek RTL8029的我不确定。\nD: CERNET 水木清华 Unix版 2001-10-12 10:36\n由于x86下网卡驱动不支持ndd(1M)获取网卡状态，被迫使用netstat -k\nifconfig -a 找出网络接口名\nnetstat -k &lt;interface&gt; | grep ifspeed\n某些x86网卡驱动支持，某些不支持，这个办法同样适合于SPARC网卡驱动，虽然后者\n可以直接使用ndd(1M)。\n10.12 Solaris/FreeBSD/Linux如何确定网卡Capability/Speed\nA: 小四 &lt;scz@nsfocus.com&gt; 2001-12-07 17:06\nSolaris\n# netstat -k hme0 | grep ifspeed\n# ndd -get /dev/hme link_mode\n0 半双工\n1 全双工\n# ndd -get /dev/hme link_status\n0 Link Down\n1 Link up\n# ndd -get /dev/hme link_speed\n0 10Mbps\n1 100Mbps\nFreeBSD用ifconfig就可以看到\nstatus: active      &lt;-- 网线接到一个HUB上了\nstatus: no carrier  &lt;-- 未接网线\nA: starw@smth.org\n在高版本的Linux系统中net-tools包中有一个mii-tool命令，可以用于检查这些数据，\n而不是溶合在ifconfig的输出中。\n10.13 x86/FreeBSD 4.3-RELEASE下LINK_ADDR(3)手册页\n10.14 traceroute是怎么实现的\nQ: traceroute是怎么实现的\nA: 小四 &lt;scz@nsfocus.com&gt;\ntraceroute(对于Windows系列是tracert)通过逐步增加TTL值的方法，发送常规IP分\n组来实现。第一次发送分组时TTL为1，第一个路由器接收到该分组之后将TTL值减1，\n结果为0，于是就丢弃该分组，并发回一个\"TTL超时\"的ICMP报文，该报文的源地址是\n这第一个路由器。紧接着发送一个TTL为2的分组。注意，traceroute发送常规的UDP\n报文到一个不用的UDP端口。当初考虑将路由跟踪的功能加入IP协议本身，定义一个\n\"路由跟踪\"选项，路由器处理带有该选项的IP包时立即发回一个跟踪报文到源站点。\n然而这种做法还停留在实验室阶段，因为这需要改变所有已经存在的路由器，而且在\n某种程度上与端到端原则相违背。\n1) 传统的Unix实现是UDP+ICMP\n2) 其实从原理上TCP+ICMP也是可以的，某些Unix系统采用了这种实现\n3) Windows另有一种实现，Icmp Echo Request+ICMP\nA: 小四 &lt;scz@nsfocus.com&gt;\n1) 传统的traceroute操作是发送UDP报文，等待ICMP端口不可达报文、ICMP超时报文。\n2) 把1)中的UDP报文换成TCP报文，没有什么不可以，只不过最后等待的不是ICMP端\n口不可达报文，而是RST报文。1)和2)多是Unix系统traceroute实现，用NetXray\n自己抓包观察。\n3) 发送Icmp Echo Request，等待ICMP超时报文和Icmp Echo Reply。这是Windows系\n统的tracert实现。\n4) 记录路由选项和Icmp Echo Request报文配合获取到达目标主机所经过的路由，也\n可以和TCP、UDP报文配合。记录路由选项具体格式可以参看介绍TCP/IP协议的书\n籍或RFC 791。IP选项最多40字节，这个限制使得记录路由选项只能包含9跳路由，\n请对照记录路由选项具体格式理解为什么只能包含9跳路由。这多是Unix系统的\ntraceroute实现。\nD: 小四 2002-05-17 14:09\n一般traceroute等待回应ICMP包5秒，发送三个探测分组。对于使用TCP的情况，应该\n等待RST报文，而不是ICMP报文。\n10.15 SPARC/Solaris 8 snoop(1M)手册页\n10.16 x86/FreeBSD TCPDUMP(1)手册页\n10.17 Solaris系统中ip_strict_dst_multihoming的确切含义是什么\nQ: 某些安全配置文档中看到如下建议\n/usr/sbin/ndd -get /dev/ip ip_strict_dst_multihoming (系统缺省设置为0)\n在/etc/rc2.d/S69inet启动脚本中增加如下行\n/usr/sbin/ndd -set /dev/ip ip_strict_dst_multihoming 1\nip_strict_dst_multihoming这个参数的确切含义是什么\nA: Casper Dik 1999-09-22\n先举个例子，UDP报文的源IP很容易伪造成127.0.0.1，这对RPCBIND的PMAPPROC_SET、\nPMAPPROC_UNSET过程非常不利，攻击者可以利用这两个远程过程实施拒绝服务攻击。\n假设作了如上设置，当报文的源为本地IP却又来自错误的网络接口时，内核将丢弃这\n样的报文。\n11. package相关问题\n11.0 在SPARC/Solaris 8上手工安装libpcap\n11.1 Solaris下如何将二进制软件包安装到指定目标路径下\nQ: pkgadd无法指定目标路径，而我不想使用缺省安装路径/usr/local\nA: lisuit@水木清华 2002-01-19 14:49\npkgadd -R &lt;basedir&gt; ...\n11.2 Solaris下如何自己定制二进制安装包\nA: deepin &lt;deepin@nsfocus.com&gt; &amp; scz &lt;scz@nsfocus.com&gt;\n[root@ /tmp/tools]&gt; mkdir srcroot\n[root@ /tmp/tools]&gt; cp -p /usr/ccs/bin/as srcroot  &lt;-- 复制那些数据源到该目录下\n[root@ /tmp/tools]&gt; cp -p /usr/ccs/bin/make srcroot\n[root@ /tmp/tools]&gt; cp -p /usr/ccs/lib/cpp srcroot\n[root@ /tmp/tools]&gt; ls -lR srcroot\n-rwxr-xr-x 1 bin bin as*\n-rwxr-xr-x 1 bin bin cpp*\n-rwxr-xr-x 1 bin bin make*\n[root@ /tmp/tools]&gt; cd srcroot\n[root@ /tmp/tools/srcroot]&gt; find . -print | pkgproto &gt; ../prototype\n[root@ /tmp/tools/srcroot]&gt; cd ..\n[root@ /tmp/tools]&gt; more prototype\nf none cpp 0755 bin bin\nf none as 0755 bin bin\nf none make 0755 bin bin\n[root@ /tmp/tools]&gt; vi prototype  &lt;-- 在头部增加如下行\ni pkginfo=./pkginfo\n[root@ /tmp/tools]&gt; vi pkginfo\nPKG=\"Scz\"\nNAME=\"Scz Package Cool Tools\"\nVERSION=\"2000-01-09 14:53\"\nCATEGORY=\"application\"\nPSTAMP=\"小四\"\nCLASSES=\"none\"\nARCH=\"Solaris 7 For SPARC\"\nVENDOR=\"NSFocus\"\nBASEDIR=\"/tmp/tools/opt/\"\nEMAIL=\"scz@nsfocus.com\"\n[root@ /tmp/tools]&gt; pkgmk -o -f ./prototype -b /tmp/tools/srcroot\n[root@ /tmp/tools]&gt; pkgtrans -s /var/spool/pkg /tmp/tools/SczPkg Scz\n[root@ /tmp/tools]&gt; rm -rf /var/spool/pkg/Scz\n[root@ /tmp/tools]&gt; pkgadd -d SczPkg\n[root@ /tmp/tools]&gt; ls -lR opt\n-rwxr-xr-x 1 bin bin as*\n-rwxr-xr-x 1 bin bin cpp*\n-rwxr-xr-x 1 bin bin make*\n[root@ /tmp/tools]&gt; pkginfo -l Scz\n[root@ /tmp/tools]&gt; pkgrm Scz\n[root@ /tmp/tools]&gt; rm SczPkg\nQ: 要在安装包里包含某些配置文件(比如xxx.conf)，安装时要让它安装到/etc目录，\n怎么做\nA: 小四 &lt;scz@nsfocus.com&gt; 2002-05-15 10:05\npkginfo(4)中的BASEDIR只影响相对路径，可以直接在prototype(4)中指定绝对路径\n(比如/etc/xxx.conf)。如果打包时/etc/xxx.conf就存在，直接写\nf none /etc/xxx.conf 0755 bin bin\n如果打包时xxx.conf位于/tmp/tools/srcroot下，又不想或不能放到/etc/下去，可\n以写成\nf none /etc/xxx.conf=xxx.conf 0755 bin bin\n这个格式是\n&lt;dstPath&gt;=&lt;srcPath&gt;\n11.3 如何恢复/usr/bin/su的缺省安装属性\nQ: 我怀疑/usr/bin/su被修改过了，如何证实呢\nA: John D Groenveld &lt;groenvel@cse.psu.edu&gt;\n$ pkgchk -l -p /usr/bin/su\nPathname: /usr/bin/su\nType: regular file\nExpected mode: 4511\nExpected owner: root\nExpected group: sys\nExpected file size (bytes): 18360\nExpected sum(1) of contents: 32865\nExpected last modification: 1月 15 09时  18分    46秒 1998\nReferenced by the following packages:\nSUNWcsu\nCurrent status: installed\nman -s 1M pkgchk 了解更多信息\nA: Roland Titze &lt;titze@lts.sel.alcatel.de&gt;\n检查文件 /var/sadm/install/contents ，安装包信息以文本形式存放在这个文件中\n$ grep \"/usr/bin/su \" /var/sadm/install/contents\n/sbin/su=../usr/bin/su s none SUNWcsr\n/usr/bin/su f none 4511 root sys 18360 32865 884884726 SUNWcsu\nA: scz &lt;scz@nsfocus.com&gt;\n# ls -l /var/sadm/install/contents\n-rw-r--r-- 1 root other /var/sadm/install/contents\n#\n注意，由于pkgadd会更新这个文件，而这个文件是root才可写的，所以非root用户无\n法正常使用pkgadd安装软件包。\n关于校验和计算，参看cksum(1) sum(1B) sum(1)等命令的手册页。pkgchk为木马检\n测提供了一种可能的技术，但是由于文本文件/var/sadm/install/contents本身易于\n修改，也不可靠。我的建议是提前备份/var/sadm/install/contents文件，至少需要\n针对该文件做一定保护，很多系统文件的校验和信息就不用写脚本备份到自己的文件\n中了。如果安装木马的人没有意识到这个文件的存在和意义，就给入侵检测提供了机\n会。反之，如果是入侵企图，看到这里的朋友应该修正/var/sadm/install/contents\n文件。无论是检测还是入侵，都可以写个脚本来完成，sed命令足够了。\nQ: 如何恢复文件权限属性\nA: dkoleary@mediaone.net 2001-06-02 22:41\n所有经pkgadd安装的文件，在/var/sadm/install/contents中记录有文件名、原始文\n件权限属性等信息。\nok boot cdrom -s\nmount / 到 /a，/usr 到 /a/usr，/var 到 /a/var，/opt 到/a/opt，执行\n# pkgchk -R /a -f\n将根据/var/sadm/install/contents文件进行文件权限属性恢复。这里有个例外，所\n有suid、sgid、sticky位并不设置，必须写个脚本根据/var/sadm/install/contents\n文件自行恢复。\n11.4 如何获知指定包与其他包之间的依赖关系\nA: Vitaly Filatov &lt;vitaly@royint.com&gt;\n详细信息查看 /var/sadm/pkg/&lt;package&gt;/install/depend 文件，这里指明了该包的\n三个特性\nP 安装前必须已经存在的包\nI 与自己不兼容的包\nR 依赖自己的其他包\n11.5 如何获得Linux命令的源代码\nQ: Linux中如何知道ifconfig属于哪个包\nA:\n# which ifconfig\n/sbin/ifconfig\n# rpm -qf /sbin/ifconfig\nnet-tools-1.51-3           &lt;-- rpm包名字\n# rpm -qi net-tools-1.51-3\n或者\n# rpm -qif /sbin/ifconfig  &lt;-- 直接查找src.rpm\nQ: 如何获取ps命令的源代码\nA: dfbb@smth 2003-04-23\n1) $ rpm -qif `which ps` | grep \"Source RPM\" | awk ‘{print $NF}‘\nprocps-2.0.7-12.src.rpm\n2) 去rpmfind.net或者sourceforge.net搜索关键字\"procps\"\n3) 下载procps-2.0.7-12.src.rpm\n4) $ rpm2cpio procps-2.0.7-12.src.rpm | cpio -idv\n$ tar xvfz procps-2.0.7.tar.gz\n11.6 Solaris下如何知道某包中有哪些文件\nA: 小四 &lt;scz@nsfocus.com&gt; 2001-12-10 21:39\n1) 已经安装了的包，对/var/sadm/install/contents文件做grep操作\n# grep SUNWcsd /var/sadm/install/contents\n~~~~~~~ 包名\n2) 尚未安装的包，先伪安装，然后检查pkgmap文件\n# pkgadd -s /var/spool/pkg -d less-340-sol7-sparc-local\n# cd /var/spool/pkg/GNUless\n# grep BASEDIR pkginfo  &lt;-- 确认BASEDIR目录，比如/usr/local\n# vi pkgmap             &lt;-- 注意第四列\n# rm -rf /var/spool/pkg/GNUless\n可以写个脚本完成这些工作。\n11.7 RedHat下如何检查文件是否被改动过\nQ: 我怀疑自己的/bin/login被入侵者替换过了，如何确认这点。\nA: jbtzhm &lt;jbtzhm@nsfocus.com&gt; &amp; lgx &lt;lgx@nsfocus.com&gt;\n1) rpm -V `rpm -qf &lt;filename&gt;`\n任何输出的文件名(非包名)均表示其被改动过，正常情况下应该无任何文件名输\n出。对于RedHat 8，可以简写成:\nrpm -qfV `which login`\n2) ls -lc `which login`\nctime相对不易被修改，简单touch操作无法修改ctime，可做参考。\n3) strings -a -n 3 `which login` | more\n4) nm -a `which login` | more\n5) file `which login`\n如果确认被改动过，可以用IDA Pro、GDB、objdump等工具进一步反汇编检查。\n12. 日志相关问题\n12.0 Solaris 8如何enable FTP session log\nQ: Solaris 8如何enable FTP session log，就是记录FTP用户执行了哪些命令\nA: root from gceclub.sun.com.cn 2002-10-11 11:56\n参看http://www.ebsinc.com/solaris/network/ftp.html\n编辑/etc/inetd.conf，修改如下(在行尾增加一个\"-d\")\nftp     stream  tcp6    nowait  root    /usr/sbin/in.ftpd       in.ftpd -d\n编辑/etc/syslog.conf，增加如下行\ndaemon.debug &lt;TAB&gt;&lt;TAB&gt; /var/adm/ftp-debug.log\n然后重启inetd和syslogd\n# kill -HUP &lt;inetd pid&gt;\n# kill -HUP &lt;syslog pid&gt; (有时候这里可能需要彻底杀掉syslogd再重启)\n从此/var/adm/ftp-debug.log中将记录FTP用户执行了哪些命令，比如\nOct  4 10:22:23 psi ftpd[8080]: FTPD: command: USER appel\nOct  4 10:22:23 psi ftpd[8080]: &lt;--- 530\nOct  4 10:22:23 psi ftpd[8080]: User appel access denied.\nOct  4 10:22:24 psi ftpd[8080]: FTPD: command: QUIT\nOct  4 10:22:24 psi ftpd[8080]: &lt;--- 221\nOct  4 10:22:24 psi ftpd[8080]: Goodbye.\n12.1 如何查看/var/adm/utmp、/var/adm/wtmp、/var/adm/lastlog\nQ: 如何查看utmp、utmpx、wtmp、wtmpx、lastlog文件\nA: senthilkumar\n/usr/lib/acct/fwtmp\n/usr/lib/acct/wtmpfix\n可以用fwtmp命令读取这些文件，具体细节参看fwtmp(1M)手册页。\n# cat /var/adm/utmp | /usr/lib/acct/fwtmp\nQ: 我用echo \"\" &gt; /var/adm/utmpx命令试图清空这些文件(lastlog、utmp、utmpx、\nwtmp、wtmpx)，结果导致无法telnet/ftp到这台主机。最后我被迫恢复原来的文\n件。当我telnet登录时，报告\"No utmpx entry. You must exec login from the\nlowest level shell\"，什么意思？\nA: senthilkumar\n\"No utmpx entry\"意味着文件系统满，没有空间记录utmpx入口点(登录信息)。此时\n应该进入单用户模式(Stop-A后boot -s)，清空(不是删除)两个文件：/var/adm/utmp\n和/var/adm/utmpx\n# cat /dev/null &gt; /var/adm/utmp\n# cat /dev/null &gt; /var/adm/utmpx\n这两条命令清空文件但是保持原有正确属性。某些时候清空这两个文件之后/var文件\n系统依旧满，此时可以\n# du -askd /var | sort -nr | more\n将从大到小报告/var文件系统中的文件列表，为了腾出空间，可以清空\n/var/cron/log、/var/spool/lp/logs、/var/adm/messages。还可以检查\n/.wastebasket文件，找出那些可以删除的大文件。\n12.2 logger/syslogd问题\nQ: 我在缺省/etc/syslog.conf文件中增加了如下行\nlocal0.* &lt;TAB&gt;&lt;TAB&gt; /var/adm/esnmessages\n然后kill -HUP `cat /etc/syslog.pid`，接着使用命令\n/usr/bin/logger -p local0.notice test\n测试。结果发现前面的修改无效，/var/adm/esnmessages并未更新。\nA: Steven Buehrle &lt;sbuehrle@nyx.net&gt;\n你仔细查看syslog.conf的手册页了吗？所增加的条目无效，星号*可以用于指定\nfacility，但是不能用于指定level。\n12.3 如何关闭cron的日志\nQ: 有些时候cron的日志文件增长得如此之大，占用了大量磁盘空间，有什么办法彻\n底关闭cron的日志吗\nA: Sun Microsystems 1998-03-30\n编辑/etc/default/cron，设置 CRONLOG 变量为 NO ，将关闭cron的日志\nCRONLOG=NO\n缺省是\nCRONLOG=YES\n12.4 /var/adm/lastlog文件看上去太大了\nA: Sun Microsystems\n# truss -vlstat -tlstat ls -l /var/adm/lastlog\nlstat64(\"/var/adm/lastlog\", 0xEFFFFC18)         = 0\nd=0x025C0000 i=29730 m=0100444 l=1  u=0     g=0     sz=1680028\nat = Jun 20 17:34:09 GMT 2001  [ 993087249 ]\nmt = Jun 20 17:34:09 GMT 2001  [ 993087249 ]\nct = Jun 20 17:34:09 GMT 2001  [ 993087249 ]\nbsz=8192  blks=64    fs=ufs\n-r--r--r--   1 root     root     1680028 6月 20 17:34 /var/adm/lastlog\n# truss -vlstat -tlstat ls -ls /var/adm/lastlog\nlstat64(\"/var/adm/lastlog\", 0xEFFFFC18)         = 0\nd=0x025C0000 i=29730 m=0100444 l=1  u=0     g=0     sz=1680028\nat = Jun 20 17:34:09 GMT 2001  [ 993087249 ]\nmt = Jun 20 17:34:09 GMT 2001  [ 993087249 ]\nct = Jun 20 17:34:09 GMT 2001  [ 993087249 ]\nbsz=8192  blks=64    fs=ufs\n64 -r--r--r--   1 root     root     1680028 6月 20 17:34 /var/adm/lastlog\n#\n参看stat(2)手册页、/usr/include/lastlog.h头文件。/var/adm/lastlog是一个稀\n疏文件，其中有很多\"空洞\"，ls -l显示的是st_size成员，st_blocks成员才代表文\n件实际占用磁盘空间大小(以512字节为单位)。\n13. 进程相关问题\n13.1 如何根据进程名获得PID\nQ: 我知道ps、top等命令和grep相结合可以达到这个效果，但是我想在C程序中实现\n这个功能，并且我不想用system()、popen()等方式。\nD: Linux提供了一个命令，pidof(8)\nA: Andrew Gierth &lt;andrew@erlenstar.demon.co.uk&gt;\n第一种办法是读取/proc接口提供的信息\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o getpid getpid.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/procfs.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stropts.h&gt;\n#include &lt;dirent.h&gt;\n#include &lt;fcntl.h&gt;\nstatic pid_t getpidbyname ( char * name, pid_t skipit )\n{\nDIR *           dirHandle;  /* 目录句柄   */\nstruct dirent * dirEntry;   /* 单个目录项 */\nprpsinfo_t      prp;\nint             fd;\npid_t           pid = -1;\nif ( ( dirHandle = opendir( \"/proc\" ) ) == NULL )\n{\nreturn( -1 );\n}\n/*\n* 下面使用相对路径打开文件，所以必须进入/proc\n*/\nchdir( \"/proc\" );\nwhile ( ( dirEntry = readdir( dirHandle ) ) != NULL )\n{\nif ( dirEntry-&gt;d_name[0] != ‘.‘ )\n{\n/*\n* fprintf( stderr, \"%s\\n\", dirEntry-&gt;d_name );\n*/\nif ( ( fd = open( dirEntry-&gt;d_name, O_RDONLY ) ) != -1 )\n{\nif ( ioctl( fd, PIOCPSINFO, &amp;prp ) != -1 )\n{\n/*\n* fprintf( stderr, \"%s\\n\", prp.pr_fname );\n*/\n/*\n* 这里是相对路径，而且不带参数\n*/\nif ( !strcmp( prp.pr_fname, name ) )\n{\npid = ( pid_t )atoi( dirEntry-&gt;d_name );\n/*\n* -1做为无效pid对待\n*/\nif ( skipit != -1 &amp;&amp; pid == skipit )\n{\npid = -1;\n}\nelse\n{\n/*\n* 找到匹配\n*/\nclose( fd );\n/*\n* 跳出while循环\n*/\nbreak;\n}\n}\n}\nclose( fd );\n}\n}\n}  /* end of while */\nclosedir( dirHandle );\nreturn( pid );\n}  /* end of getpidbyname */\nstatic void usage ( char * arg )\n{\nfprintf( stderr, \" Usage: %s &lt;proc_name&gt;\\n\", arg );\nexit( EXIT_FAILURE );\n}  /* end of usage */\nint main ( int argc, char * argv[] )\n{\npid_t pid;\nif ( argc != 2 )\n{\nusage( argv[0] );\n}\npid = getpidbyname( argv[1], -1 );\nif ( pid != -1 )\n{\nfprintf( stderr, \"[ %s ] is: &lt;%u&gt;\\n\", argv[1], ( unsigned int )pid );\nreturn( EXIT_SUCCESS );\n}\nreturn( EXIT_FAILURE );\n}  /* end of main */\n--------------------------------------------------------------------------\n这种技术要求运行者拥有root权限，否则无法有效获取非自己拥有的进程PID。注意\n下面的演示\n# ps -f -p 223\nUID   PID  PPID  C    STIME TTY      TIME CMD\nroot   223     1  0   3月 09 ?        0:00 /usr/sbin/vold\n# ./getpid /usr/sbin/vold  &lt;-- 这个用法无法找到匹配\n# ./getpid vold            &lt;-- 只能匹配相对路径\n[ vold ] is: &lt;223&gt;\n当然你可以自己修改、增强程序，使之匹配各种命令行指定，我就不替你做了。上述\n程序在32-bit kernel的Solaris 2.6和64-bit kernel的Solaris 7上均测试通过。\nD: microcat &lt;rotm@263.net&gt;\n在介绍第二种办法之前，先看一下microcat提供的这个程序\n--------------------------------------------------------------------------\n/*\n* gcc -DSOLARIS=6 -Wall -pipe -O3 -o listpid listpid.c -lkvm\n*\n* /opt/SUNWspro/SC5.0/bin/cc -DSOLARIS=7 -xarch=v9 -O -o listpid listpid.c -lkvm\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;kvm.h&gt;\n#include &lt;fcntl.h&gt;\nint main ( int argc, char * argv[] )\n{\nkvm_t *       kd;\nstruct proc * p;\nstruct pid    pid;\nif ( ( kd = kvm_open( NULL, NULL, NULL, O_RDONLY, NULL ) ) == NULL )\n{\nperror( \"kvm_open error\" );\nreturn( EXIT_FAILURE );\n}\n/*\n* 遍历P区\n*/\nwhile ( ( p = kvm_nextproc( kd ) ) )\n{\n#if SOLARIS == 7\nif ( kvm_kread( kd, ( uintptr_t )p-&gt;p_pidp, &amp;pid, sizeof( pid ) ) &lt; 0 )\n#elif SOLARIS == 6\nif ( kvm_kread( kd, ( unsigned long )p-&gt;p_pidp, ( char * )&amp;pid, sizeof( pid ) ) &lt; 0 )\n#endif\n{\nperror( \"kvm_kread error\" );\n}\nelse\n{\nprintf( \"PID: %d\\n\", ( int )pid.pid_id );\n}\n}  /* end of while */\nkvm_close( kd );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nA: Andrew Gierth &lt;andrew@erlenstar.demon.co.uk&gt;\n第二种办法是使用kvm_*()函数\n--------------------------------------------------------------------------\n/*\n* 必须定义这个宏\n*/\n#define _KMEMUSER\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;regexpr.h&gt;\n#include &lt;sys/proc.h&gt;\n#include &lt;kvm.h&gt;\n#include &lt;fcntl.h&gt;\n/*\nstatic void argv_free ( char ** argv )\n{\nsize_t i;\nfor ( i = 0; argv[i] != NULL; i++ )\n{\nfree( argv[i] );\nargv[i] = NULL;\n}\nfree( argv );\n}\n*/\nstatic pid_t getpidbyname ( char *name, pid_t skipit )\n{\nkvm_t        *kd;\nint           error;\nchar        **argv   = NULL;\nchar         *p_name = NULL;\npid_t         pid    = -1;\nchar          expbuf[256];\nchar          regexp_str[256];\nstruct user  *cur_user;\nstruct proc  *cur_proc;\nstruct pid    p;\nsprintf( regexp_str, \"^.*%s$\", name );\n/*\n* 正则表达式\n*/\nif ( compile( regexp_str, expbuf, expbuf + 256 ) == NULL )\n{\nperror( \"compile\" );\nreturn( -1 );\n}\nif ( ( kd = kvm_open( NULL, NULL, NULL, O_RDONLY, NULL ) ) == NULL )\n{\nperror( \"kvm_open\" );\nreturn( -1 );\n}\n/*\n* 遍历P区\n*/\nwhile ( ( cur_proc = kvm_nextproc( kd ) ) )\n{\n/*\n* 注意理解这里为什么要使用kvm_kread()函数，否则很容易出现段故障\n*/\n#if SOLARIS == 7\nif ( kvm_kread( kd, ( uintptr_t )cur_proc-&gt;p_pidp, &amp;p, sizeof( p ) ) &lt; 0 )\n#elif SOLARIS == 6\nif ( kvm_kread( kd, ( unsigned long )cur_proc-&gt;p_pidp, ( char * )&amp;p, sizeof( p ) ) &lt; 0 )\n#endif\n{\nperror( \"kvm_kread\" );\ncontinue;\n}\npid = p.pid_id;\nif ( ( cur_user = kvm_getu( kd, cur_proc ) ) != NULL )\n{\n/* fprintf( stderr, \"cur_proc = %p cur_user = %p\\n\", cur_proc, cur_user ); */\nerror = kvm_getcmd( kd, cur_proc, cur_user, &amp;argv, NULL );\n/*\n* fprintf( stderr, \"[ %s ] is: &lt;%u&gt;\\n\", cur_user-&gt;u_comm, ( unsigned int )pid );\n*\n* 比如in.telnetd、syslogd、bash、login\n*/\nif ( error == -1 )\n{\n/*\n* 失败，比如argv[]已经被进程自己修改过\n*/\nif ( cur_user-&gt;u_comm[0] != ‘\\0‘ )\n{\n/*\n* 从另外一个地方获取信息\n*/\np_name = cur_user-&gt;u_comm;\n}\n}\n/*\n* 成功\n*/\nelse\n{\n/*\n* fprintf( stderr, \"[ %s ] is: &lt;%u&gt;\\n\", argv[0], ( unsigned int )pid );\n*\n* 比如-bash、login、in.telnetd、/usr/sbin/syslogd\n*/\np_name = argv[0];\n}\n}\nif ( p_name )\n{\nif ( ( strcmp( p_name, name ) == 0 ) || step( p_name, expbuf ) )\n{\n/*\n* -1做为无效pid对待\n*/\nif ( skipit != -1 &amp;&amp; pid == skipit )\n{\npid = -1;\n}\n/*\n* 找到匹配，返回pid\n*/\nelse\n{\n/*\n* 跳出while循环\n*/\nbreak;\n}\n}\n}\nif ( argv != NULL )\n{\n/*\n* argv_free( argv );\n*/\nfree( argv );\nargv = NULL;\n}\n/*\n* 必须增加这条，否则流程有问题\n*/\np_name = NULL;\n}  /* end of while */\nif ( argv != NULL )\n{\n/*\n* 根据kvm_getu(3K)手册页的描述，我企图释放指针数组的各个元素以及\n* 指针数组本身。测试下来，只能释放指针数组本身，无法单独释放各个\n* 元素，否则出现总线错误。个人认为kvm_getu(3K)手册页的描述是正确\n* 的，有待进一步测试\n*/\n/*\n* argv_free( argv );\n*/\nfree( argv );\nargv = NULL;\n}\nkvm_close( kd );\nreturn( pid );\n}  /* end of getpidbyname */\nstatic void usage ( char * arg )\n{\nfprintf( stderr, \" Usage: %s &lt;proc_name&gt;\\n\", arg );\nexit( EXIT_FAILURE );\n}  /* end of usage */\nint main ( int argc, char * argv[] )\n{\npid_t pid;\nif ( argc != 2 )\n{\nusage( argv[0] );\n}\npid = getpidbyname( argv[1], -1 );\nif ( pid != -1 )\n{\nfprintf( stderr, \"[ %s ] is: &lt;%u&gt;\\n\", argv[1], ( unsigned int )pid );\nreturn( EXIT_SUCCESS );\n}\nreturn( EXIT_FAILURE );\n}  /* end of main */\n--------------------------------------------------------------------------\n这个程序同样必须以root身份运行，在SPARC/Solaris 2.6/7上测试通过，注意编译\n命令不同。\nD: scz &lt;scz@nsfocus.com&gt;\nAndrew Gierth在&lt;&lt;Unix Programming FAQ 1.37版&gt;&gt;中提供的例子有点问题，可能是\n不同平台上测试的。很多kvm编程初学者在Solaris 2.6上测试时碰上段故障错误，主\n要在于kvm_nextproc()获得P区结构后，其中的指针是内核空间的指针，不能直接在\n用户空间使用，必须用kvm_kread()函数将相应数据从内核空间读取到用户空间来，\n多次在CERNET BBS上碰到这种问题，这次一并解答。\n其次，原例子中关于正则表达式的处理和应用有点问题，程序流程中事实上并没有达\n到期待效果，现在我修正后的这个例子已经在做正则表达式匹配。\n最后，参看上述代码中的注释。根据kvm_getu(3K)手册页的描述，我企图释放指针数\n组的各个元素以及指针数组本身，提供了一个argv_free()函数。测试下来，只能释\n放指针数组本身，无法单独释放各个元素，否则出现总线错误。个人认为\nkvm_getu(3K)手册页的描述是正确的，有待进一步测试。\n参看kvm_read(3K)手册页，kvm_read()不推荐使用，代之以kvm_kread()，如果读取\n通过kvm_getu(3K)获取的进程U区，推荐使用kvm_uread()。\n13.2 如何在命令行上访问指定进程P、U两区，如何欺骗Solaris的ps\n13.3 getexecname(3C)是怎么实现的\n13.4 Solaris 7/8下ps输出中的问号\nQ: 比如ps -el的输出中有很多问号，可我觉得它们应该有一个确定的值\nA: Michael Shapiro &lt;mws@poptart.Sun.Com&gt;\n有些时候ps(1)输出的单行过于长了，为了输出美观，某些列的值用问号代替，尤\n其64-bit内核下ADDR列。可以用-o参数指定要显示的列，比如\n# ps -o pid,tty,addr,wchan,fname -p $$\nPID TT                  ADDR            WCHAN COMMAND\n2602 pts/4        30000a154b8      30000a15578 bash\n# ps -e -o pid,tty,addr,wchan,fname\n13.5 如何根据某种原则终止一批进程\n13.6 利用libproc库编程举例\n13.7 给定一个PID，如何知道它对应一个运行中的进程\nA: Andrew Gierth &lt;andrew@erlenstar.demon.co.uk&gt;\n这个回答来自著名的&lt;&lt;Unix Programming FAQ ver 1.37&gt;&gt;，由Andrew Gierth负责维\n护，其它细节请参看原文。\nkill( pid, 0 )，此时有四种可能的返回值\n1) kill()返回0\n意味着指定PID的确对应着一个运行中的进程，系统允许你向该进程发送信号。至\n于该进程能否是zombie process(僵尸进程)，是系统相关的。\n2) kill()返回-1，errno == ESRCH\n指定PID并不对应一个运行中的进程，或者权限不够无法完成判断。某些系统上，\n如果对应进程是僵尸进程时，也如此返回。\n3) kill()返回-1，errno == EPERM\n系统不允许你kill指定进程，进程存在(可能是zombie)，权限不够。\n4) kill()返回-1，errno是其它值\n你麻烦来了(嘿嘿)\n最有用的技术，假设成功表示进程存在，EPERM失败也表示进程存在，其它失败表示\n指定PID不对应一个运行中的进程。\n此外如果系统支持proc伪文件系统，检查/proc/&lt;pid&gt;是否存在，存在表明指定PID对\n应运行中的进程。\n13.8 Unix编程中所谓\"僵尸进程\"指什么\nQ: Unix编程中所谓\"僵尸进程\"指什么，什么情况下会产生僵尸进程，如何杀掉僵尸\n进程。\nA: 在fork()/execve()过程中，假设子进程结束时父进程仍存在，而父进程fork()之\n前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束，又没有显式忽\n略该信号，则子进程成为僵尸进程，无法正常结束，此时即使是root身份kill -9\n也不能杀死僵尸进程。补救办法是杀死僵尸进程的父进程(僵尸进程的父进程必然\n存在)，僵尸进程成为\"孤儿进程\"，过继给1号进程init，init始终会负责清理僵\n尸进程。\n所谓以root身份也不能杀死僵尸进程，其实只是用户态的感觉。真正原因是这个\n进程在内核看来已经结束了，你不能杀死一个死人，不是吗。内核维护了一些状\n态信息，等待其父进程获取这些状态信息，除非父进程明确表示它不想获取这些\n状态信息。\n显式忽略SIGCHLD信号是指类似这样的代码:\nsignal( SIGCHLD, SIG_IGN );\n安装SIGCHLD信号句柄是指类似这样的代码:\nstatic void on_sigchld ( int signo )\n{\npid_t pid;\nint   status;\nwhile ( ( pid = waitpid( -1, &amp;status, WNOHANG ) ) &gt; 0 )\n{\n/*\n* 演示用，不推荐在信号句柄中使用fprintf()\n*/\nfprintf( stderr, \"child &lt;%u&gt; terminated\", ( unsigned int )pid );\n}  /* end of while */\nreturn;\n}  /* end of on_sigchld */\n... ...\nsignal( SIGCHLD, on_sigchld );\n当然，我们不建议使用signal()，应该使用sigaction()。\n为了避免僵尸进程，有很多看似不同的办法，但其实质都是设法处理SIGCHLD信号。\nAPUE 8.6节最后一个例子演示了一种技巧，二次fork()，而不是安装SIGCHLD信号\n句柄。这样做没有什么特别的好处，仅仅是演示另外一种处理思路。此外，显式\n忽略SIGCHLD信号的作法并不具有最广泛可移植性，不建议采用。\nfor ( ; ; )\n{\npid = Fork();\nif ( 0 == pid )\n{\n/*\n* 子进程\n*/\npid = Fork();\nif ( 0 == pid )\n{\n... ...\n}\nexit( EXIT_SUCCESS );\n}\nelse\n{\n/*\n* 父进程\n*\n* 处理SIGCHLD信号，在此产生阻塞\n*/\nif ( pid != waitpid( pid, NULL, 0 ) )\n{\nperror( \"waitpid error\" );\n}\n}\n}  /* end of for */\n13.9 x86/FreeBSD 4.3-RELEASE的ptrace(2)手册页\nA: 小四 &lt;scz@nsfocus.com&gt;\n下面来看一个简单的ptrace(2)演示，x86/FreeBSD 4.3-RELEASE\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o target target.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/uio.h&gt;\n#include &lt;unistd.h&gt;\nint main ( int argc, char * argv[] )\n{\nwrite( STDERR_FILENO, \"Hello world\\n\", 12 );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o ptracetest ptracetest.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/ptrace.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;sys/resource.h&gt;\n#include &lt;errno.h&gt;\nint main ( int argc, char * argv[] )\n{\npid_t p;\np = fork();\nif ( p &lt; 0 )\n{\nperror( \"fork error\" );\nexit( EXIT_FAILURE );\n}\nelse if ( p == 0 )\n{\n/*\n* 子进程\n*/\nerrno = 0;\nptrace( PT_TRACE_ME, 0, 0, 0 );\nif ( errno != 0 )\n{\nperror( \"child process ptrace error\" );\nexit( EXIT_FAILURE );\n}\nelse\n{\nchar * name[2];\nname[0] = \"./target\";\nname[1] = NULL;\n/*\n* 切换进程映像时停止执行\n*/\nexecve( name[0], name, NULL );\nperror( \"child process execve error\" );\nexit( EXIT_FAILURE );\n}\n}\nelse\n{\n/*\n* 父进程\n*/\nfprintf( stderr, \"Having a child process &lt;%d&gt;\\n\", ( int )p );\n/*\n* 阻塞式waitpid()\n*/\nwaitpid( p, NULL, 0 );\nfprintf( stderr, \"Now in parent process, \"\n\"please enter [CR] to continue ... ...\\n\" );\ngetchar();\nerrno = 0;\nptrace( PT_CONTINUE, p, ( caddr_t )1, 0 );\nif ( errno != 0 )\n{\nperror( \"parent process ptrace error\" );\nexit( EXIT_FAILURE );\n}\n/*\n* 作为ptrace(2)演示，这里必须等待子进程先结束，否则由于父进程终止\n* 而杀死子进程\n*/\nfprintf( stderr, \"Waiting the child process terminate ... ...\\n\" );\ngetchar();\n}\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n13.10 如何知道哪个进程使用了哪个端口\nQ: Solaris下netstat -na -P tcp告诉我哪些端口是打开的，但它没有报告是哪个进\n程打开的。lsof可以满足我的需求，可我不想用lsof，它不是缺省安装的\nA: Vitaly Filatov &lt;vitaly@royint.com&gt; &amp; scz &lt;scz@nsfocus.com&gt;\n对于Solaris 8，可以使用这个演示脚本，如果不能满足你的需要，请自行修改\n--------------------------------------------------------------------------\n#! /bin/sh\n# find_socket_proc.sh for x86/SPARC Solaris 8\n#\n# File     : find_socket_proc.sh\n# Author   : Vitaly Filatov &lt;vitaly@royint.com&gt;\n# Fix      : scz &lt;scz.nsfocus.com&gt;\n# Platform : x86/SPARC Solaris 8\n# Version  : 1.00 aleph\n# Usage    :\n# Date     : 2001-10-28 00:32\n# Modify   :\n#\nPLATFORM=\"`uname -p`\"\nif [ \"${PLATFORM}\" = \"sparc\" ] ; then\nPREFIX=\"\"\nelif [ \"${PLATFORM}\" = \"i386\" ] ; then\nPREFIX=\"/usr\"\nfi\nEGREP=\"${PREFIX}/bin/egrep\"\nNAWK=\"${PREFIX}/bin/nawk\"\nPFILES=\"/usr/proc/bin/pfiles\"\nPS=\"${PREFIX}/bin/ps\"\nSED=\"${PREFIX}/bin/sed\"\nPROCLIST=\"`${PS} -ef | ${NAWK} ‘NR &gt; 1 {print $2}‘`\"\nfor PID in ${PROCLIST} ; do\nif [ -n \"`${PFILES} ${PID} 2&gt;/dev/null | ${EGREP} S_IFSOCK`\" ] ; then\nLINE_1=\"`${PS} -o pid,args -p ${PID} | ${NAWK} ‘NR &gt; 1 {print $0}‘`\"\nPORTLIST=\"`${PFILES} ${PID} 2&gt;/dev/null | ${EGREP} ‘sockname:‘ | ${SED} -e ‘s/.*port: \\(.*\\)/\\1/g‘`\"\nfor PORT in ${PORTLIST} ; do\necho \"${LINE_1} port--&gt;${PORT}\"\ndone\nfi\ndone\n--------------------------------------------------------------------------\n如果你以普通用户身份运行，只能检查自己的进程，如果以root身份运行，可以检查\n所有用户的进程。\nD: 2002-03-08 09:41 修订\n1) Solaris 7\nnetstat -na -P tcp -f inet\n2) FreeBSD 4.3-RELEASE\nnetstat -s -p tcp 查香tcp协议的统计量\nnetstat -na | grep \"^tcp4\" 才能达到类似Solaris下netstat -na -P tcp的效果\n3) FreeBSD 4.4-RELEASE\nnetstat -na -p tcp效果类似于Solaris下netstat -na -P tcp\n4) RedHat Linux 7.2\nnetstat -nap | grep \"^tcp\"直接可以看到端口所属的进程\nnetstat -na [&lt;type&gt;]\n&lt;type&gt;={-t|--tcp} {-u|--udp} {-w|--raw} {-x|--unix} --ax25 --ipx --netrom\n显然对于Linux有netstat -nap，对于FreeBSD有sockstat，至少这两种平台不再需要\nlsof，或者不那么迫切需要lsof了。\nA: 对于RedHat 7.2，有一个socklist(8)，通过读取如下文件\n/proc/*/fd/*\n/proc/net/tcp\n/proc/net/udp\n/proc/net/raw\n同样可以获取socket与进程之间的联系信息。\n13.11 x86/FreeBSD如何快速获取指定用户拥有的进程数\nQ: 谁能给我一段C代码，快速统计出一个指定用户所拥有的进程数。我想修改Apache\n以阻止它超过kern.maxprocperuid限制后继续fork()产生新进程。如果Apache以\nsudo方式启动，就可能出现这种情况。我该看ps(1)的源代码吗？\nA: Maxim Konovalov &lt;maxim@macomnet.ru&gt;\n参看src/usr.bin/killall/killall.c，这里用了sysctl()接口\nA: Andrew &lt;andrew@ugh.net.au&gt;\n可以试试kvm_getprocs( KERN_PROC_UID )\n13.12 如何获取当前进程对应之静态映像文件的绝对路径\nA: hushui110@水木清华\n这是一个x86/Linux Kernel 2.4.7-10系统中利用proc获取绝对路径的例子\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -g -static -o myprog_2 myprog_2.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#define MAXBUFSIZE 1024\nint main ( int argc, char * argv[] )\n{\nchar buf[ MAXBUFSIZE ];\nint  count;\ncount = readlink( \"/proc/self/exe\", buf, MAXBUFSIZE );\nif ( count &lt; 0 || count &gt;= MAXBUFSIZE )\n{\nprintf( \"Failed\\n\" );\nreturn( EXIT_FAILURE );\n}\nbuf[ count ] = ‘\\0‘;\nprintf( \"/proc/self/exe -&gt; [%s]\\n\", buf );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n[scz@ /home/scz/src]&gt; echo $PATH\n/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:.\n[scz@ /home/scz/src]&gt; ./myprog_2\n/proc/self/exe -&gt; [/home/scz/src/myprog_2]\n[scz@ /home/scz/src]&gt; ../src/myprog_2\n/proc/self/exe -&gt; [/home/scz/src/myprog_2]\n[scz@ /home/scz/src]&gt; myprog_2\n/proc/self/exe -&gt; [/home/scz/src/myprog_2]\n[scz@ /home/scz/src]&gt;\n显然这里直接给出了最期待的结果，没有冗余信息。参看proc(5)手册页。\nA: scz &lt;scz@nsfocus.com&gt; &amp; microcat &lt;lgx@nsfocus.com&gt; 2000-03-18\n下面在x86/Linux Kernel 2.4.7-10上演示、讨论\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -g -static -o myprog myprog.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main ( int argc, char * argv[] )\n{\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n[scz@ /home/scz/src]&gt; gcc -Wall -pipe -g -static -o myprog myprog.c\n[scz@ /home/scz/src]&gt; echo $PATH\n/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:.\n[scz@ /home/scz/src]&gt; gdb ./myprog\n(gdb) b main\n(gdb) r\n(gdb) x/17s 0xbfffff00\n0xbfffff00:      \"SHLVL=1\"\n0xbfffff08:      \"_=/bin/bash\"\n0xbfffff14:      \"SHELL=/bin/bash\"\n0xbfffff24:      \"HOSTTYPE=i386\"\n0xbfffff32:      \"OSTYPE=linux-gnu\"\n0xbfffff43:      \"HISTSIZE=1000\"\n0xbfffff51:      \"TERM=vt100\"\n0xbfffff5c:      \"HOME=/home/scz\"\n0xbfffff6b:      \"SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass\"\n0xbfffff9e:      \"PATH=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:.\"\n0xbfffffd2:      \"LESSCHARSET=latin1\"\n0xbfffffe5:      \"/home/scz/src/./myprog\"  &lt;-- 注意这个输出\n0xbffffffc:      \"\"\n0xbffffffd:      \"\"\n0xbffffffe:      \"\"\n0xbfffffff:      \"\"\n0xc0000000:      &lt;Address 0xc0000000 out of bounds&gt;\n[scz@ /home/scz/src]&gt; gdb myprog\n(gdb) b main\n(gdb) r\n(gdb) x/17s 0xbfffff00\n0xbfffff00:      \"z\"\n0xbfffff02:      \"SHLVL=1\"\n0xbfffff0a:      \"_=/bin/bash\"\n0xbfffff16:      \"SHELL=/bin/bash\"\n0xbfffff26:      \"HOSTTYPE=i386\"\n0xbfffff34:      \"OSTYPE=linux-gnu\"\n0xbfffff45:      \"HISTSIZE=1000\"\n0xbfffff53:      \"TERM=vt100\"\n0xbfffff5e:      \"HOME=/home/scz\"\n0xbfffff6d:      \"SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass\"\n0xbfffffa0:      \"PATH=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:.\"\n0xbfffffd4:      \"LESSCHARSET=latin1\"\n0xbfffffe7:      \"/home/scz/src/myprog\"  &lt;-- 注意这个输出\n0xbffffffc:      \"\"\n0xbffffffd:      \"\"\n0xbffffffe:      \"\"\n0xbfffffff:      \"\"\n[scz@ /home/scz/src]&gt; gdb ../src/myprog\n(gdb) b main\n(gdb) r\n(gdb)  x/17s 0xbfffff00\n0xbfffff00:      \"=1\"\n0xbfffff03:      \"_=/bin/bash\"\n0xbfffff0f:      \"SHELL=/bin/bash\"\n0xbfffff1f:      \"HOSTTYPE=i386\"\n0xbfffff2d:      \"OSTYPE=linux-gnu\"\n0xbfffff3e:      \"HISTSIZE=1000\"\n0xbfffff4c:      \"TERM=vt100\"\n0xbfffff57:      \"HOME=/home/scz\"\n0xbfffff66:      \"SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass\"\n0xbfffff99:      \"PATH=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:.\"\n0xbfffffcd:      \"LESSCHARSET=latin1\"\n0xbfffffe0:      \"/home/scz/src/../src/myprog\"  &lt;-- 注意这个输出\n0xbffffffc:      \"\"\n0xbffffffd:      \"\"\n0xbffffffe:      \"\"\n0xbfffffff:      \"\"\n0xc0000000:      &lt;Address 0xc0000000 out of bounds&gt;\n[scz@ /home/scz/src]&gt;\n这是ELF文件在Linux系统中加载进内存之后的布局简图\n--------------------------------------------------------------------------\n0x08048000    code            .text，代码，只读\ndata            .data，包含已经初始化的数据，只读\nbss             .bss，未初始化数据，初始化成0，读/写\n...             堆区，动态分配获取的内存从.bss往内存高端增长\n...             (heap)，读/写\n...\nstack           栈区，起始地址大于0xBFFF0000\narguments       main()的形参\nenvironment     环境变量区域\nprogram name    execve()第一形参，不是argv[0]\n0xBFFFFFFC    null(dword)     最后四个字节固定为零\n0xC0000000\n--------------------------------------------------------------------------\n通常动态链接库被映射到0x40000000往高端的地址。对于Linux，如果打了不可执行\n堆栈内核补丁，动态链接库被映射到0x40000000往低端的地址。tt说就是以前的映射\n地址减去0x40000000。打了补丁后使得通过字符串拷贝(strcpy)传递shellcode相对\n复杂化，需要更多技巧。\nprogram name处不一定是绝对路径，实际对应了execve()第一形参。一般从shell上\n启动进程，shell根据PATH环境变量自动搜索匹配出一个路径，未必是绝对路径。假\n设PATH环境变量中有当前目录(.)，所执行的程序也只在当前目录下有，直接指定程\n序名(myprog)执行时，shell会向execve()第一形参传递\"./myprog\"。注意，execve\n第一形参未必是绝对路径。用gdb加载后再执行，情况有所不同。如果gdb命令行上指\n定的程序名非绝对路径，gdb在调用execve()之前会调用getcwd()拼接在程序名之前，\n此时不依赖PATH环境变量。所以用gdb调试溢出程序时应该在命令行上指定绝对路径，\n避免不必要的偏移调整。\n现在来看这样一个演示程序\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -g -static -o myprog_1 myprog_1.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nextern char **environ;\nint main ( int argc, char * argv[] )\n{\nchar *path = ( char * )( 0xc0000000 - 5 );\nwhile ( *--path );\n++path;\nprintf( \"path       --&gt; %08x [%s]\\n\", ( unsigned int )path, path );\nprintf( \"argv       --&gt; %08x\\n\", ( unsigned int )argv );\nprintf( \"argv[0]    --&gt; %08x [%s]\\n\", ( unsigned int )argv[0], argv[0] );\nprintf( \"environ    --&gt; %08x\\n\", ( unsigned int )environ );\nprintf( \"environ[0] --&gt; %08x [%s]\\n\", ( unsigned int )environ[0], environ[0] );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n直接执行，然后用gdb加载后执行，对比输出上的不同。\n[scz@ /home/scz/src]&gt; myprog_1\npath       --&gt; bffffff1 [./myprog_1]  &lt;-- 注意这里前面多了一个\"./\"\nargv       --&gt; bffffb24\nargv[0]    --&gt; bffffc29 [myprog_1]\nenviron    --&gt; bffffb2c\nenviron[0] --&gt; bffffc32 [PWD=/home/scz/src]\n[scz@ /home/scz/src]&gt; ./myprog_1\npath       --&gt; bffffff1 [./myprog_1]\nargv       --&gt; bffffb24\nargv[0]    --&gt; bffffc27 [./myprog_1]\nenviron    --&gt; bffffb2c\nenviron[0] --&gt; bffffc32 [PWD=/home/scz/src]\n[scz@ /home/scz/src]&gt; ../src/myprog_1\npath       --&gt; bfffffec [../src/myprog_1]\nargv       --&gt; bffffb14\nargv[0]    --&gt; bffffc18 [../src/myprog_1]\nenviron    --&gt; bffffb1c\nenviron[0] --&gt; bffffc28 [PWD=/home/scz/src]\n[scz@ /home/scz/src]&gt;\nLinux系统中main()函数里自修改argv[0]欺骗ps有效，而FreeBSD、Solaris则无效。\nexecve()第二形参可以指定不同于第一形参的argv[0]。argv[0]不可信，但execve()\n第一形参相对就可信得多。如果是自己写程序，可以考虑在main()中第一时刻判断\nexecve()第一形参是否为相对路径，进而决定是否调用getcwd()，最后拼接出一个绝\n对路径。就像gdb所做的那样。\n需要考虑\"/home/scz/src/./myprog\"、\"/home/scz/src/../src/myprog\"这些情况，\n消掉\"./\"、\"../\"等冗余信息，参看realpath()手册页。\nA: scz &lt;scz@nsfocus.com&gt; &amp; microcat &lt;lgx@nsfocus.com&gt; 2002-09-13 18:00\n下面在SARPC/Solaris 8 64-bit kernel mode上演示、讨论\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -g -static -o myprog_3 myprog_3.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nextern char **environ;\nstatic void outputBinary ( const unsigned char *byteArray, const size_t byteArrayLen )\n{\nsize_t offset, k, j, i;\nfprintf( stderr, \"byteArray [ %u bytes ] ----&gt; \\n\", byteArrayLen );\nif ( byteArrayLen &lt;= 0 )\n{\nreturn;\n}\ni      = 0;\noffset = 0;\nfor ( k = byteArrayLen / 16; k &gt; 0; k--, offset += 16 )\n{\nfprintf( stderr, \"%08X \", offset );\nfor ( j = 0; j &lt; 16; j++, i++ )\n{\nif ( j == 8 )\n{\nfprintf( stderr, \"-%02X\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \" %02X\", byteArray[i] );\n}\n}\nfprintf( stderr, \"    \" );\ni -= 16;\nfor ( j = 0; j &lt; 16; j++, i++ )\n{\n/*\n* if ( isprint( (int)byteArray[i] ) )\n*/\nif ( ( byteArray[i] &gt;= ‘ ‘ ) &amp;&amp; ( byteArray[i] &lt;= 255 )\n&amp;&amp; ( byteArray[i] != 0x7f ) )\n{\nfprintf( stderr, \"%c\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \".\" );\n}\n}\nfprintf( stderr, \"\\n\" );\n}  /* end of for */\nk = byteArrayLen - i;\nif ( k &lt;= 0 )\n{\nreturn;\n}\nfprintf( stderr, \"%08X \", offset );\nfor ( j = 0 ; j &lt; k; j++, i++ )\n{\nif ( j == 8 )\n{\nfprintf( stderr, \"-%02X\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \" %02X\", byteArray[i] );\n}\n}\ni -= k;\nfor ( j = 16 - k; j &gt; 0; j-- )\n{\nfprintf( stderr, \"   \" );\n}\nfprintf( stderr, \"    \" );\nfor ( j = 0; j &lt; k; j++, i++ )\n{\nif ( ( byteArray[i] &gt;= ‘ ‘ ) &amp;&amp; ( byteArray[i] &lt;= 255 )\n&amp;&amp; ( byteArray[i] != 0x7f ) )\n{\nfprintf( stderr, \"%c\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \".\" );\n}\n}\nfprintf( stderr, \"\\n\" );\nreturn;\n}  /* end of outputBinary */\nint main ( int argc, char * argv[] )\n{\nchar *path = ( char * )( 0xffbf0000 - 5 );\nwhile ( *path == ‘\\0‘ )\n{\npath--;\n}\nwhile ( *path )\n{\npath--;\n}\n++path;\nprintf( \"path       --&gt; %08x [%s]\\n\", ( unsigned int )path, path );\nprintf( \"argv       --&gt; %08x\\n\", ( unsigned int )argv );\nprintf( \"argv[0]    --&gt; %08x [%s]\\n\", ( unsigned int )argv[0], argv[0] );\nprintf( \"environ    --&gt; %08x\\n\", ( unsigned int )environ );\nprintf( \"environ[0] --&gt; %08x [%s]\\n\", ( unsigned int )environ[0], environ[0] );\noutputBinary( ( const unsigned char * )( 0xffbf0000 - 256 ), 256 );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n直接执行，然后用gdb加载后执行，对比输出上的不同。SPARC/Solaris与x86/Linux\n在此问题上有不少区别。\n[scz@ /home/scz/src]&gt; echo $PATH\n/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:.\n[scz@ /export/home/scz/src]&gt; myprog_3\npath       --&gt; ffbeffee [myprog_3]\nargv       --&gt; ffbefcfc\nargv[0]    --&gt; ffbefd7c [myprog_3]\nenviron    --&gt; ffbefd04\nenviron[0] --&gt; ffbefd85 [PWD=/export/home/scz/src]\n[scz@ /export/home/scz/src]&gt; ./myprog_3\npath       --&gt; ffbefff0 [myprog_3]  &lt;-- 注意前面反而没有了\"./\"\nargv       --&gt; ffbefcfc\nargv[0]    --&gt; ffbefd7c [./myprog_3]\nenviron    --&gt; ffbefd04\nenviron[0] --&gt; ffbefd87 [PWD=/export/home/scz/src]\n[scz@ /export/home/scz/src]&gt; ../src/myprog_3\npath       --&gt; ffbeffea [../src/myprog_3]\nargv       --&gt; ffbefcec\nargv[0]    --&gt; ffbefd6c [../src/myprog_3]\nenviron    --&gt; ffbefcf4\nenviron[0] --&gt; ffbefd7c [PWD=/export/home/scz/src]\n[scz@ /export/home/scz/src]&gt;\n如果我们复制myprog_3到/usr/bin下去，再次执行myprog_3，可以看到如下输出\n[scz@ /export/home/scz/src]&gt; myprog_3\npath       --&gt; ffbeffe9 [/usr/bin/myprog_3]  &lt;-- 注意这里\nargv       --&gt; ffbefcf4\nargv[0]    --&gt; ffbefd74 [myprog_3]\nenviron    --&gt; ffbefcfc\nenviron[0] --&gt; ffbefd7d [PWD=/export/home/scz/src]\nbyteArray [ 256 bytes ] ----&gt;\n00000000  55 6C 74 72 61 2D 35 5F-31 30 00 53 48 4C 56 4C Ultra-5_10.SHLVL\n00000010  3D 31 00 5F 49 4E 49 54-5F 55 54 53 5F 4D 41 43 =1._INIT_UTS_MAC\n00000020  48 49 4E 45 3D 73 75 6E-34 75 00 53 48 45 4C 4C HINE=sun4u.SHELL\n00000030  3D 2F 62 69 6E 2F 62 61-73 68 00 48 4F 53 54 54 =/bin/bash.HOSTT\n00000040  59 50 45 3D 73 70 61 72-63 00 4F 53 54 59 50 45 YPE=sparc.OSTYPE\n00000050  3D 73 6F 6C 61 72 69 73-32 2E 38 00 48 4F 4D 45 =solaris2.8.HOME\n00000060  3D 2F 65 78 70 6F 72 74-2F 68 6F 6D 65 2F 73 63 =/export/home/sc\n00000070  7A 00 54 45 52 4D 3D 76-74 31 30 30 00 50 41 54 z.TERM=vt100.PAT\n00000080  48 3D 2F 62 69 6E 3A 2F-75 73 72 2F 62 69 6E 3A H=/bin:/usr/bin:\n00000090  2F 73 62 69 6E 3A 2F 75-73 72 2F 73 62 69 6E 3A /sbin:/usr/sbin:\n000000A0  2F 75 73 72 2F 6C 6F 63-61 6C 2F 62 69 6E 3A 2E /usr/local/bin:.\n000000B0  00 5F 49 4E 49 54 5F 4E-45 54 5F 53 54 52 41 54 ._INIT_NET_STRAT\n000000C0  45 47 59 3D 6E 6F 6E 65-00 5F 3D 2F 62 69 6E 2F EGY=none._=/bin/\n000000D0  6D 79 70 72 6F 67 5F 33-00 53 55 4E 57 2C 55 6C myprog_3.SUNW,Ul\n000000E0  74 72 61 2D 35 5F 31 30-00 2F 75 73 72 2F 62 69 tra-5_10./usr/bi\n000000F0  6E 2F 6D 79 70 72 6F 67-5F 33 00 00 00 00 00 00 n/myprog_3......\n[scz@ /export/home/scz/src]&gt;\n前面说的getcwd()拼接技术同样适用于SPARC/Solaris 8。\n与Linux相比，有几处重要变化，一是从0xC0000000变成0xFFBF0000，二是如果程序\n在当前目录下，没有了前面的\"./\"，三是SPARC芯片的一些对齐特性导致我们要找的\n位置可能比想像的要向内存低端移动一些字节。\n后两点容易理解，那我们是如何确定0xC0000000、0xFFBF0000的呢。这个问题实际上\n就是&lt;&lt;如何编程获取栈底地址&gt;&gt;所解决的，参看这篇QA。假设堆栈(stack)向低地址\n方向增长，则所谓栈底指堆栈(stack)最高地址，下面是tt用程序找出来的\nx86/Linux         栈底是0xc0000000( 栈底往低地址的4个字节总是零 )\nSPARC/Solaris 7/8 栈底是0xffbf0000( 栈底往低地址的4个字节总是零 )\nSPARC/Solaris 2.6 栈底是0xf0000000( 栈底往低地址的4个字节总是零 )\nx86/FreeBSD       栈底是0xbfc00000( 栈底往低地址的4个字节总是零 )\nx86/NetBSD 1.5    栈底是0xbfbfe000\nx86/OpenBSD 2.8   栈底是0xdfbfe000\n利用ELF文件加载进内存之后的布局获取绝对路径固然可行，但是带有很强的Hacking\n味，并不可取，非万不得已不要使用这种技术。\nLinux有\"/proc/self/exe\"，Solaris有\"/proc/self/auxv\"，这些都可以一用。当然\n在Solaris系统中直接使用getexecname(3C)获取execve()第一形参最好，否则涉及在\n用户空间读取U区的问题，也带有很强的Kernel Hacking味道。参看&lt;&lt;如何在命令行\n上访问指定进程P、U两区，如何欺骗Solaris的ps&gt;&gt;、&lt;&lt;getexecname(3C)是怎么实现\n的&gt;&gt;两篇QA。\nD: law@水木清华\n在main()一开始就取execve()第一形参，或者退而求其次取argv[0]，然后解析$PATH\n环境变量，自己确定哪个目录里含有进程静态文件映像。如果是取execve()第一形参，\n这个办法可行。如果取argv[0]，就面临着argv[0]不可信的问题。而前面的技术取的\n都是execve()第一形参。\n注意，如果取argv[0]，就不能依赖getcwd()拼接，这点与取execve()第一形参不同。\n很可能命令行上的\"myprog_3\"实际根据$PATH产生了\"/usr/bin/myprog_3\"(execve()\n第一形参)，argv[0](myprog_3)与getcwd()(/home/scz/src)无论如何也拼不出正确\n的绝对路径。\nA: scz &lt;scz@nsfocus.com&gt; 2002-09-13 20:45\n这是一个x86/FreeBSD 4.5-RELEASE系统中利用proc获取绝对路径的例子\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -g -static -o myprog_4 myprog_4.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n#define MAXBUFSIZE 1024\nint main ( int argc, char * argv[] )\n{\nchar proc[64];\nchar buf[ MAXBUFSIZE ];\nint  count;\nsprintf( proc, \"/proc/%d/file\", ( unsigned int )getpid() );\ncount = readlink( proc, buf, MAXBUFSIZE );\nif ( count &lt; 0 || count &gt;= MAXBUFSIZE )\n{\nprintf( \"Failed\\n\" );\nreturn( EXIT_FAILURE );\n}\nbuf[ count ] = ‘\\0‘;\nprintf( \"%s -&gt; [%s]\\n\", proc, buf );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n[scz@ /home/scz/src]&gt; echo $PATH\n/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:.\n[scz@ /home/scz/src]&gt; myprog_4\n/proc/121/file -&gt; [/usr/home/scz/src/myprog_4]\n[scz@ /home/scz/src]&gt; ./myprog_4\n/proc/122/file -&gt; [/usr/home/scz/src/myprog_4]\n[scz@ /home/scz/src]&gt; ../src/myprog_4\n/proc/123/file -&gt; [/usr/home/scz/src/myprog_4]\n[scz@ /home/scz/src]&gt;\n与Linux系统中\"/proc/&lt;pid&gt;/exe\"一样，FreeBSD系统中\"/proc/&lt;pid&gt;/file\"直接给\n出了最期待的结果，没有冗余信息。参看procfs(5)手册页。\n手头系统有限，无法一一验证其它Unix系统。个人觉得从栈底向低端移动取execve()\n第一形参的办法比较通用，可以写成可移植的函数，但还是不太推荐这种Hacking。\n13.13 x86/Linux Kernel 2.4.7-10的ptrace(2)手册页\n13.14 x86/Linux Kernel 2.4.7-10下如何欺骗ps\nQ: Redhat Linux 7.2，一运行中的程序，源代码不可控，ps ax可以看到其启动命令\n行，如何欺骗ps ax，使之显示其他指定内容。\nD: dennis2@www.linuxforum.net\n在*BSD系统中可以参看setproctitle(3)、kvm_getargv(3)。\nA: jbtzhm &lt;jbtzhm@nsfocus.com&gt;\nrpm -qif `which ps`查到procps-2.0.7-11.src.rpm，在如下链接上找到\nhttp://rpmfind.net/linux/RPM/redhat/7.2/i386/procps-2.0.7-11.i386.html\nftp://ftp.redhat.com/pub/redhat/linux/7.2/en/os/i386/SRPMS/procps-2.0.7-11.src.rpm\n从readproc.c的file2strvec()函数中可以看到\"ps ax\"在读取/proc/&lt;pid&gt;/cmdline，\n这个返回值是变长的、不固定的、动态分配内存的。\n# cat /proc/self/cmdline | od -Ax -tx1 -v -\n000000 63 61 74 00 2f 70 72 6f 63 2f 73 65 6c 66 2f 63\n000010 6d 64 6c 69 6e 65 00\n000017\n#\n可以看出/proc/&lt;pid&gt;/cmdline对应着argv[]数组。参看documentation/filesystems\n/proc.txt。\n当读取/proc/&lt;pid&gt;/cmdline时，调用了fs/proc/base.c中的proc_pid_cmdline()函\n数，task_struct -&gt; mm_struct -&gt; arg_start、arg_end。为了欺骗ps ax，我们需\n要修改arg_start与arg_end之间的数据。\n参看fs/binfmt_elf.c中的load_elf_binary()、creat_elf_tables()函数。实际上这\n里arg_start就是main()函数的argv[0]。\n如果源代码可控，可以在main()入口处修改argv[]数组。源代码不可控时，如果进程\n不依赖argv[0]，可以在execve()第二形参处伪造argv[0]，但无法伪造argv[1]及其\n后续形参。最麻烦的情况是，源代码不可控的一个已经运行中的进程，此时要利用其\n它技术修改该进程的argv[]数组。\njbtzhm采用的技术是利用ptrace()系统调用在指定进程的栈区搜索定位argv[]，然后\n替换之，清零或伪造。\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o linux_fakeps linux_fakeps.c\n* gcc -DDEBUG -Wall -pipe -g -o linux_fakeps linux_fakeps.c\n*\n* only for x86/Linux Kernel 2.4.7-10\n*\n* the author is jbtzhm, and modified by scz\n*/\n#define _GNU_SOURCE\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;strings.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/ptrace.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;errno.h&gt;\n/*\n* 这是操作系统相关、架构相关的栈底地址，参看&lt;&lt;如何编程获取栈底地址&gt;&gt;\n*/\n#define STACKBOTTOM ((unsigned int)0xC0000000)\n#define STACKSIZE   4096\n#if DEBUG\nstatic void outputBinary ( const unsigned char *byteArray, const size_t byteArrayLen )\n{\nsize_t offset, k, j, i;\nfprintf( stderr, \"byteArray [ %u bytes ] ----&gt; \\n\", byteArrayLen );\nif ( byteArrayLen &lt;= 0 )\n{\nreturn;\n}\ni      = 0;\noffset = 0;\nfor ( k = byteArrayLen / 16; k &gt; 0; k--, offset += 16 )\n{\nfprintf( stderr, \"%08X \", offset );\nfor ( j = 0; j &lt; 16; j++, i++ )\n{\nif ( j == 8 )\n{\nfprintf( stderr, \"-%02X\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \" %02X\", byteArray[i] );\n}\n}\nfprintf( stderr, \"    \" );\ni -= 16;\nfor ( j = 0; j &lt; 16; j++, i++ )\n{\n/*\n* if ( isprint( (int)byteArray[i] ) )\n*/\nif ( ( byteArray[i] &gt;= ‘ ‘ ) &amp;&amp; ( byteArray[i] &lt;= 255 )\n&amp;&amp; ( byteArray[i] != 0x7f ) )\n{\nfprintf( stderr, \"%c\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \".\" );\n}\n}\nfprintf( stderr, \"\\n\" );\n}  /* end of for */\nk = byteArrayLen - i;\nif ( k &lt;= 0 )\n{\nreturn;\n}\nfprintf( stderr, \"%08X \", offset );\nfor ( j = 0 ; j &lt; k; j++, i++ )\n{\nif ( j == 8 )\n{\nfprintf( stderr, \"-%02X\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \" %02X\", byteArray[i] );\n}\n}\ni -= k;\nfor ( j = 16 - k; j &gt; 0; j-- )\n{\nfprintf( stderr, \"   \" );\n}\nfprintf( stderr, \"    \" );\nfor ( j = 0; j &lt; k; j++, i++ )\n{\nif ( ( byteArray[i] &gt;= ‘ ‘ ) &amp;&amp; ( byteArray[i] &lt;= 255 )\n&amp;&amp; ( byteArray[i] != 0x7f ) )\n{\nfprintf( stderr, \"%c\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \".\" );\n}\n}\nfprintf( stderr, \"\\n\" );\nreturn;\n}  /* end of outputBinary */\n#endif\n/*\n* 形参count以32-bit为单位\n*/\nstatic int ptrace_rw ( enum __ptrace_request request, pid_t pid,\nvoid *addr, void *data, size_t count )\n{\nunsigned int  word;\nunsigned int *child  = ( unsigned int * )addr;\nunsigned int *parent = ( unsigned int * )data;\nsize_t        c;\nif ( request == PTRACE_PEEKTEXT || request == PTRACE_PEEKDATA )\n{\nfor ( c = 0; c &lt; count; c++ )\n{\n/*\n* 某些request导致ptrace()无错的时候也返回-1，为了消除歧义，考\n* 虑在ptrace()调用之前设置errno成0，调用完成后检查errno是否还\n* 是0\n*/\nerrno = 0;\nword  = ( unsigned int )ptrace( request, pid, child, NULL );\nif ( errno != 0 )\n{\nperror( \"ptrace error\" );\nreturn( EXIT_FAILURE );\n}\n*parent = word;\nchild++;\nparent++;\n}\n}\nelse if ( request == PTRACE_POKETEXT || request == PTRACE_POKEDATA )\n{\nfor ( c = 0; c &lt; count; c++ )\n{\nerrno = 0;\nptrace( request, pid, child, *parent );\nif ( errno != 0 )\n{\nperror( \"ptrace error\" );\nreturn( EXIT_FAILURE );\n}\nchild++;\nparent++;\n}\n}\nelse\n{\nfprintf( stderr, \"request error\\n\" );\nreturn( EXIT_FAILURE );\n}\nreturn( EXIT_SUCCESS );\n}  /* end of ptrace_rw */\nint main ( int argc, char * argv[] )\n{\npid_t         pid;\nchar         *fake_string = NULL;\nchar          buf[ STACKSIZE ];\nchar          stack[ STACKSIZE ];\nssize_t       len;\nint           fd;\nlong int      ret;\nchar         *target_argv;\nint           status;\nif ( argc != 2 &amp;&amp; argc != 3 )\n{\nfprintf( stderr, \"Usage: %s &lt;pid&gt; [&lt;fake string&gt;]\\n\", argv[0] );\nreturn( EXIT_FAILURE );\n}\npid = ( pid_t )strtoul( argv[1], NULL, 10 );\nif ( argc == 3 )\n{\nfake_string = argv[2];\n}\nmemset( buf, 0, sizeof( buf ) );\nsnprintf( buf, sizeof( buf ), \"/proc/%u/cmdline\", ( unsigned int )pid );\nif ( ( fd = open( buf, O_RDONLY ) ) &lt; 0 )\n{\nperror( \"open error\" );\nreturn( EXIT_FAILURE );\n}\nlen = read( fd, buf, sizeof( buf ) );\nclose( fd );\nif ( len &lt;= 0 )\n{\nfprintf( stderr, \"read error\\n\" );\nreturn( EXIT_FAILURE );\n}\nelse if ( len == sizeof( buf ) )\n{\n/*\n* 此时我们无法判断原argv[]到底占用了多少字节\n*/\nfprintf( stderr, \"We suggest to do nothing.\\n\" );\nreturn( EXIT_FAILURE );\n}\n#if DEBUG\noutputBinary( ( const unsigned char * )buf, ( const size_t )len );\n#endif\n/*\n* 关联指定进程，pid对应之进程即将中止运行\n*/\nif ( ( ret = ptrace( PTRACE_ATTACH, pid, NULL, NULL ) ) &lt; 0 )\n{\nperror( \"ptrace error\" );\nreturn( EXIT_FAILURE );\n}\n/*\n* 注意，上面这个ptrace()返回时，pid对应的进程并不一定中止运行了，应该\n* 调用waitpid()等待其中止运行\n*/\nif ( waitpid( pid, &amp;status, WUNTRACED ) != pid )\n{\nperror( \"waitpid error\" );\nreturn( EXIT_FAILURE );\n}\n/*\n* 下面这部分代码纯粹是为了演示正规、严谨的ptrace()编程，并非绝对必要\n*/\nif ( WIFSTOPPED( status ) )\n{\nif ( WSTOPSIG( status ) != SIGSTOP )\n{\nfprintf( stderr, \"The child had been stopped for another reason.\\n\" );\nreturn( EXIT_FAILURE );\n}\n}\nelse\n{\nfprintf( stderr, \"Some error occur.\\n\" );\nreturn( EXIT_FAILURE );\n}\nif ( ptrace_rw( PTRACE_PEEKTEXT, pid, ( void * )( STACKBOTTOM - STACKSIZE ),\nstack,\nSTACKSIZE / sizeof( unsigned int ) ) == EXIT_FAILURE )\n{\nreturn( EXIT_FAILURE );\n}\ntarget_argv = ( char * )memmem( stack, sizeof( stack ), buf, len );\nif ( target_argv != NULL )\n{\nmemset( target_argv, 0, len );\nif ( fake_string != NULL )\n{\nif ( strlen( fake_string ) &gt;= len )\n{\nfprintf( stderr, \"Checking your [&lt;fake_string&gt;].\\n\" );\nreturn( EXIT_FAILURE );\n}\nstrcpy( target_argv, fake_string );\n}\nif ( ptrace_rw( PTRACE_POKEDATA, pid, ( void * )( STACKBOTTOM - STACKSIZE ),\nstack,\nSTACKSIZE / sizeof( unsigned int ) ) == EXIT_FAILURE )\n{\nreturn( EXIT_FAILURE );\n}\n}\nelse\n{\nfprintf( stderr, \"We cann‘t find target_argv.\\n\" );\n}\nerrno = 0;\n/*\n* 去除对指定进程的关联，则pid对应之进程继续正常运行\n*/\nptrace( PTRACE_DETACH, pid, NULL, NULL );\nif ( errno != 0 )\n{\nperror( \"ptrace error\" );\nreturn( EXIT_FAILURE );\n}\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nlinux_fakeps.c做了一定的保护性检查，避免系统崩溃，于是程序逻辑上有一个小问\n题，如果对argv[]做了清零操作，则下次无法伪造成其它字符串。\nQ: 运行linux_fakeps之后，ps ax的显示已经如期而变，可直接ps看到的依旧未变\nA: jbtzhm &lt;jbtzhm@nsfocus.com&gt;\nps -p &lt;pid&gt; -o cmd\nps -p &lt;pid&gt; -o command\nps ax\n对于这三种命令，linux_fakeps均有效。但是对于下面这三种命令，linux_fakeps无\n效:\nps -p &lt;pid&gt; -o comm\nps axc\nps\n那是因为这三种情况下使用了进程P区的comm[16]，不再是argv[]。\nreadproc() -&gt; file2str()、stat2proc() -&gt; show_a_proc() -&gt; show_cmd_env()\nfile2str()读取/proc/&lt;pid&gt;/stat，最终就是读取了指定进程P区的comm[16]。\nstat2proc()负责解析来自/proc/&lt;pid&gt;/stat的数据。借助如下命令加强理解:\n# cat /proc/self/stat | od -Ax -tx1 -v -\n现在从内核源码中进一步分析这个问题。当读取/proc/&lt;pid&gt;/stat时，调用了\nfs/proc/array.c中的proc_pid_stat()函数，最终读取了task-&gt;comm。为了欺骗\nps axc，我们需要修改task-&gt;comm，这是一个16字节的字符数组。\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o linux_fakeps_1 linux_fakeps_1.c\n* gcc -DDEBUG -Wall -pipe -g -o linux_fakeps_1 linux_fakeps_1.c\n*\n* only for x86/Linux Kernel 2.4.7-10\n*\n* the author is jbtzhm\n*/\n#define __KERNEL__\n#include &lt;linux/sched.h&gt;\n#undef __KERNEL__\n#include &lt;stdio.h&gt;\n#define OFFSETOF(TYPE, MEMBER) ((size_t)&amp;((TYPE)0)-&gt;MEMBER)\n#define EXIT_FAILURE           1  /* Failing exit status    */\n#define EXIT_SUCCESS           0  /* Successful exit status */\n/*\n* 由于包含了&lt;linux/sched.h&gt;，无法正常包含这些函数原型所在头文件\n*/\nextern int               close   ( int fd );\nextern off_t             lseek   ( int fildes, off_t offset, int whence );\nextern int               open    ( const char *pathname, int flags );\nextern ssize_t           read    ( int fd, void *buf, size_t count );\nextern unsigned long int strtoul ( const char *nptr, char **endptr, int base );\nextern ssize_t           write   ( int fd, const void *buf, size_t count );\n#if DEBUG\nstatic void outputBinary ( const unsigned char *byteArray, const size_t byteArrayLen )\n{\nsize_t offset, k, j, i;\nfprintf( stderr, \"byteArray [ %u bytes ] ----&gt; \\n\", byteArrayLen );\nif ( byteArrayLen &lt;= 0 )\n{\nreturn;\n}\ni      = 0;\noffset = 0;\nfor ( k = byteArrayLen / 16; k &gt; 0; k--, offset += 16 )\n{\nfprintf( stderr, \"%08X \", offset );\nfor ( j = 0; j &lt; 16; j++, i++ )\n{\nif ( j == 8 )\n{\nfprintf( stderr, \"-%02X\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \" %02X\", byteArray[i] );\n}\n}\nfprintf( stderr, \"    \" );\ni -= 16;\nfor ( j = 0; j &lt; 16; j++, i++ )\n{\n/*\n* if ( isprint( (int)byteArray[i] ) )\n*/\nif ( ( byteArray[i] &gt;= ‘ ‘ ) &amp;&amp; ( byteArray[i] &lt;= 255 )\n&amp;&amp; ( byteArray[i] != 0x7f ) )\n{\nfprintf( stderr, \"%c\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \".\" );\n}\n}\nfprintf( stderr, \"\\n\" );\n}  /* end of for */\nk = byteArrayLen - i;\nif ( k &lt;= 0 )\n{\nreturn;\n}\nfprintf( stderr, \"%08X \", offset );\nfor ( j = 0 ; j &lt; k; j++, i++ )\n{\nif ( j == 8 )\n{\nfprintf( stderr, \"-%02X\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \" %02X\", byteArray[i] );\n}\n}\ni -= k;\nfor ( j = 16 - k; j &gt; 0; j-- )\n{\nfprintf( stderr, \"   \" );\n}\nfprintf( stderr, \"    \" );\nfor ( j = 0; j &lt; k; j++, i++ )\n{\nif ( ( byteArray[i] &gt;= ‘ ‘ ) &amp;&amp; ( byteArray[i] &lt;= 255 )\n&amp;&amp; ( byteArray[i] != 0x7f ) )\n{\nfprintf( stderr, \"%c\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \".\" );\n}\n}\nfprintf( stderr, \"\\n\" );\nreturn;\n}  /* end of outputBinary */\n#endif\n/*\n* ksyms -a | grep init_task_union\n* cat /proc/ksyms | od -Ax -tx1 -v -\n*/\nstatic unsigned int resolve_symbol ( const char *symbol )\n{\nFILE         *fd;\nchar          buf[1024];\nchar         *p;\nunsigned int  addr;\nif ( ( fd = fopen( \"/proc/ksyms\", \"r\" ) ) == NULL )\n{\nperror( \"fopen error\" );\nreturn( 0 );\n}\nmemset( buf, 0, sizeof( buf ) );\n/*\n* reads in at most one less than size characters from stream\n*/\nwhile ( fgets( buf, sizeof( buf ), fd ) != NULL )\n{\nif ( ( p = strchr( buf, ‘ ‘ ) ) == NULL )\n{\ncontinue;\n}\nif ( strstr( p + 1, symbol ) != NULL )\n{\n#ifdef DEBUG\noutputBinary( ( const unsigned char * )buf, ( const size_t )strlen( buf ) );\n#endif\n*p   = 0;\naddr = ( unsigned int )strtoul( buf, NULL, 16 );\nfclose( fd );\nreturn( addr );\n}\n}  /* end of while */\nif ( feof( fd ) == 0 )\n{\nfprintf( stderr, \"fgets error\\n\" );\n}\nfclose( fd );\nreturn( 0 );\n}  /* end of resolve_symbol */\nstatic void fake_task_comm ( pid_t pid, char *fake_string )\n{\nint                 kmem_fd;\nstruct task_struct  task;\nstruct task_struct *init_task_union = ( struct task_struct * )resolve_symbol( \"init_task_union\" );\nstruct task_struct *next_task;\nchar                comm[16];\nif ( init_task_union == NULL )\n{\nreturn;\n}\nif ( ( kmem_fd = open( \"/dev/kmem\", O_RDWR ) ) &lt; 0 )\n{\nperror( \"open error\" );\nreturn;\n}\nnext_task = init_task_union;\n/*\n* 遍历进程链表，由于在用户空间读取内核动态数据，这个过程并不可靠\n*/\nwhile ( next_task != NULL )\n{\nlseek( kmem_fd, ( off_t )next_task, SEEK_SET );\nif ( read( kmem_fd, &amp;task, sizeof( task ) ) != sizeof( task ) )\n{\nfprintf( stderr, \"read error.\\n\" );\ngoto fake_task_comm_0;\n}\nif ( task.pid == pid )\n{\nmemset( comm, 0, sizeof( comm ) );\nif ( fake_string != NULL )\n{\nif ( strlen( fake_string ) &gt;= sizeof( comm ) )\n{\nfprintf( stderr, \"Checking your [&lt;fake_string&gt;].\\n\" );\ngoto fake_task_comm_0;\n}\nstrcpy( comm, fake_string );\n}\nlseek( kmem_fd, ( off_t )next_task + OFFSETOF( struct task_struct *, comm ), SEEK_SET );\nif ( write( kmem_fd, comm, sizeof( comm ) ) != sizeof( comm ) )\n{\nfprintf( stderr, \"write error.\\n\" );\n}\ngoto fake_task_comm_0;\n}\nnext_task = task.next_task;\nif ( next_task == init_task_union )\n{\n/*\n* 双向循环链表\n*/\nbreak;\n}\n}  /* end of while */\nfake_task_comm_0:\nclose( kmem_fd );\nreturn;\n}  /* end of fake_task_comm */\nint main ( int argc, char * argv[] )\n{\npid_t  pid;\nchar  *fake_string = NULL;\nif ( argc != 2 &amp;&amp; argc != 3 )\n{\nfprintf( stderr, \"Usage: %s &lt;pid&gt; [&lt;fake string&gt;]\\n\", argv[0] );\nreturn( EXIT_FAILURE );\n}\npid = ( pid_t )strtoul( argv[1], NULL, 10 );\nif ( argc == 3 )\n{\nfake_string = argv[2];\n}\nfake_task_comm( pid, fake_string );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nlinux_fakeps_1.c首先利用/proc/ksyms获取struct task_struct结构链表头，这是\n一个双向循环链表。由于获取的链表头地址是内核空间的地址，无法直接在用户空间\n使用，于是利用/dev/kmem对其进行读写操作。\nstruct task_struct结构链表是内核空间的动态数据，linux_fakeps_1.c作为用户空\n间程序去操作这个链表，缺乏足够的保护措施，并不可靠。好在我们所期待的效果也\n不是常规需要，可以忽略这种不可靠。\nD: 小四 &lt;scz@nsfocus.com&gt; 2002-09-25 0:00\n我们可以利用linux_fakeps_1.c中演示的技术精确定位arg_start、arg_end，而不是\n在栈区搜索定位argv[]。\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o linux_fakeps_2 linux_fakeps_2.c\n* gcc -DDEBUG -Wall -pipe -g -o linux_fakeps_2 linux_fakeps_2.c\n*\n* only for x86/Linux Kernel 2.4.7-10\n*/\n/*\n* 与linux_fakeps.c、linux_fakeps_1.c相比，linux_fakeps_2.c并未做欺骗ps的\n* 操作，这里只是演示如何精确定位arg_start、arg_end\n*/\n#define __KERNEL__\n#include &lt;linux/sched.h&gt;\n#undef __KERNEL__\n#include &lt;stdio.h&gt;\n#define EXIT_FAILURE 1  /* Failing exit status    */\n#define EXIT_SUCCESS 0  /* Successful exit status */\n/*\n* 由于包含了&lt;linux/sched.h&gt;，无法正常包含这些函数原型所在头文件\n*/\nextern int               close   ( int fd );\nextern off_t             lseek   ( int fildes, off_t offset, int whence );\nextern int               open    ( const char *pathname, int flags );\nextern ssize_t           read    ( int fd, void *buf, size_t count );\nextern unsigned long int strtoul ( const char *nptr, char **endptr, int base );\nextern ssize_t           write   ( int fd, const void *buf, size_t count );\nstatic void outputBinary ( const unsigned char *byteArray, const size_t byteArrayLen )\n{\nsize_t offset, k, j, i;\nfprintf( stderr, \"byteArray [ %u bytes ] ----&gt; \\n\", byteArrayLen );\nif ( byteArrayLen &lt;= 0 )\n{\nreturn;\n}\ni      = 0;\noffset = 0;\nfor ( k = byteArrayLen / 16; k &gt; 0; k--, offset += 16 )\n{\nfprintf( stderr, \"%08X \", offset );\nfor ( j = 0; j &lt; 16; j++, i++ )\n{\nif ( j == 8 )\n{\nfprintf( stderr, \"-%02X\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \" %02X\", byteArray[i] );\n}\n}\nfprintf( stderr, \"    \" );\ni -= 16;\nfor ( j = 0; j &lt; 16; j++, i++ )\n{\n/*\n* if ( isprint( (int)byteArray[i] ) )\n*/\nif ( ( byteArray[i] &gt;= ‘ ‘ ) &amp;&amp; ( byteArray[i] &lt;= 255 )\n&amp;&amp; ( byteArray[i] != 0x7f ) )\n{\nfprintf( stderr, \"%c\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \".\" );\n}\n}\nfprintf( stderr, \"\\n\" );\n}  /* end of for */\nk = byteArrayLen - i;\nif ( k &lt;= 0 )\n{\nreturn;\n}\nfprintf( stderr, \"%08X \", offset );\nfor ( j = 0 ; j &lt; k; j++, i++ )\n{\nif ( j == 8 )\n{\nfprintf( stderr, \"-%02X\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \" %02X\", byteArray[i] );\n}\n}\ni -= k;\nfor ( j = 16 - k; j &gt; 0; j-- )\n{\nfprintf( stderr, \"   \" );\n}\nfprintf( stderr, \"    \" );\nfor ( j = 0; j &lt; k; j++, i++ )\n{\nif ( ( byteArray[i] &gt;= ‘ ‘ ) &amp;&amp; ( byteArray[i] &lt;= 255 )\n&amp;&amp; ( byteArray[i] != 0x7f ) )\n{\nfprintf( stderr, \"%c\", byteArray[i] );\n}\nelse\n{\nfprintf( stderr, \".\" );\n}\n}\nfprintf( stderr, \"\\n\" );\nreturn;\n}  /* end of outputBinary */\n/*\n* ksyms -a | grep init_task_union\n* cat /proc/ksyms | od -Ax -tx1 -v -\n*/\nstatic unsigned int resolve_symbol ( const char *symbol )\n{\nFILE         *fd;\nchar          buf[1024];\nchar         *p;\nunsigned int  addr;\nif ( ( fd = fopen( \"/proc/ksyms\", \"r\" ) ) == NULL )\n{\nperror( \"fopen error\" );\nreturn( 0 );\n}\nmemset( buf, 0, sizeof( buf ) );\n/*\n* reads in at most one less than size characters from stream\n*/\nwhile ( fgets( buf, sizeof( buf ), fd ) != NULL )\n{\nif ( ( p = strchr( buf, ‘ ‘ ) ) == NULL )\n{\ncontinue;\n}\nif ( strstr( p + 1, symbol ) != NULL )\n{\n#ifdef DEBUG\noutputBinary( ( const unsigned char * )buf, ( const size_t )strlen( buf ) );\n#endif\n*p   = 0;\naddr = ( unsigned int )strtoul( buf, NULL, 16 );\nfclose( fd );\nreturn( addr );\n}\n}  /* end of while */\nif ( feof( fd ) == 0 )\n{\nfprintf( stderr, \"fgets error\\n\" );\n}\nfclose( fd );\nreturn( 0 );\n}  /* end of resolve_symbol */\nstatic void get_task_mm_arg ( pid_t pid )\n{\nint                 kmem_fd;\nstruct task_struct  task;\nstruct task_struct *init_task_union = ( struct task_struct * )resolve_symbol( \"init_task_union\" );\nstruct task_struct *next_task;\nstruct mm_struct    mm;\nif ( init_task_union == NULL )\n{\nreturn;\n}\nif ( ( kmem_fd = open( \"/dev/kmem\", O_RDWR ) ) &lt; 0 )\n{\nperror( \"open error\" );\nreturn;\n}\nnext_task = init_task_union;\n/*\n* 遍历进程链表，由于在用户空间读取内核动态数据，这个过程并不可靠\n*/\nwhile ( next_task != NULL )\n{\nlseek( kmem_fd, ( off_t )next_task, SEEK_SET );\nif ( read( kmem_fd, &amp;task, sizeof( task ) ) != sizeof( task ) )\n{\nfprintf( stderr, \"read task error.\\n\" );\ngoto get_task_mm_arg_0;\n}\nif ( task.pid == pid )\n{\nlseek( kmem_fd, ( off_t )( task.mm ), SEEK_SET );\nif ( read( kmem_fd, &amp;mm, sizeof( mm ) ) != sizeof( mm ) )\n{\nfprintf( stderr, \"read mm error.\\n\" );\ngoto get_task_mm_arg_0;\n}\noutputBinary( ( const unsigned char * )( &amp;mm.arg_start ), 16 );\ngoto get_task_mm_arg_0;\n}\nnext_task = task.next_task;\nif ( next_task == init_task_union )\n{\n/*\n* 双向循环链表\n*/\nbreak;\n}\n}  /* end of while */\nget_task_mm_arg_0:\nclose( kmem_fd );\nreturn;\n}  /* end of get_task_mm_arg */\nint main ( int argc, char * argv[] )\n{\npid_t  pid;\nif ( argc != 2 )\n{\nfprintf( stderr, \"Usage: %s &lt;pid&gt;\\n\", argv[0] );\nreturn( EXIT_FAILURE );\n}\npid = ( pid_t )strtoul( argv[1], NULL, 10 );\nget_task_mm_arg( pid );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n14. 一些小工具的使用\n14.0\n14.1 如何在命令行上进行8进制、10进制、16进制之间的转换\n14.2 显示文件的三个时间戳(atime、mtime、ctime)\nA: Sun Microsystems 2001-04-05\n首先理解如下概念\nmtime - time the contents of file was last modified (written to).\natime - time the file was last used/accessed (read or executed)\nctime - time the inode of the file was last changed (like changing permissions).\nctime also gets updated every time mtime is modified, but not when the\natime is changed.\nctime, is NOT the files creation date. Creation date is not recorded\nanywhere in the Unix file system.\n没有一个现成的Unix命令直接达到这个目的，但很容易利用truss命令获取这三个时\n间戳\n$ ls -l /usr/bin/ls\n-r-xr-xr-x   1 root     bin        17440 1997  7月 15 /usr/bin/ls*\n$ ls -lc /usr/bin/ls\n-r-xr-xr-x   1 root     bin        17440 2月  5 21:27 /usr/bin/ls*\n$ ls -lu /usr/bin/ls\n-r-xr-xr-x   1 root     bin        17440 6月 19 22:18 /usr/bin/ls*\n$ truss -vlstat -tlstat ls /usr/bin/ls\nlstat64(\"/usr/bin/ls\", 0xEFFFFC18)              = 0\nd=0x025C0006 i=48376 m=0100555 l=1  u=0     g=2     sz=17440\nat = Jun 19 22:18:14 GMT 2001  [ 993017894 ]\nmt = Jul 15 20:22:33 GMT 1997  [ 869026953 ]\nct = Feb  5 21:27:42 GMT 2001  [ 981437262 ]\nbsz=8192  blks=36    fs=ufs\n/usr/bin/ls\n$\n参看stat(2)手册页了解更多信息。时间戳记录在inode中，单位是秒。这是ufs文件\n系统的特性，和32-bit/64-bit kernel mode无关。如果几个文件在一秒内创建，则\n它们的时间戳完全一致，此时\"ls -t\"根据文件名排序。\nD: scz &lt;scz@nsfocus.com&gt;\n在SPARC/Solaris 7下参看ls(1)手册页\n/usr/bin/ls -lu 对应atime\n/usr/bin/ls -lc 对应ctime\n-u time of last access\n-c time of last modification of the i-node (file created, mode changed)\n既不指定-u也不指定-c的时候，对应mtime。\n此外，SPARC/Solaris没有x86/Linux所提供的stat命令，为了获取stat信息，可以使\n用\"truss -vlstat -tlstat ls &lt;filename&gt;\"命令。\n14.3 只在本地文件系统上查找\n14.5 反汇编\n15. 32-bit/64-bit相关问题\n15.1 Solaris下如何识别当前内核版本\nQ: 我编写了一个内核模块，在Solaris 7/8下编译通过，模块中如何识别当前正在运\n行内核版本\nA: Andrew Gabriel\n参看adb使用的宏\"utsname\"，32-bit的位于usr/lib/adb/utsname，此外可以参看\n/usr/include/sys/utsname.h文件，但是这些不是DDI/DKI兼容的。\nsysdef | more 看看\nA: scz &lt;scz@nsfocus.com&gt;\n非DDI/DKI兼容意味着丧失良好的可移植性，未来版本的Solaris可能不再提供相应的\n支持，但是就Kernel Hacking而言是可以一试的。\nadb -P ‘sun&gt;‘ -k /dev/ksyms /dev/mem\nsun&gt;$&lt;/usr/lib/adb/sparcv9/utsname  &lt;-- 使用64-bit宏\nutsname:\nutsname:        sys     SunOS\nutsname+0x101:  node    sun27\nutsname+0x202:  release 5.7\nutsname+0x303:  version Generic_106541-08\nutsname+0x404:  machine sun4u\nsun&gt;$q\ncat /usr/lib/adb/sparcv9/utsname\nutsname+0=\"\"       &lt;-- 指定当前地址.为utsname\n+/\"sys\"8t257c      &lt;-- t表示tab，c表示以字符方式显示1个字节\n+/\"node\"8t257c\n+/\"release\"8t257c  &lt;-- +表示当前地址.递增\n+/\"version\"8t257c\n+/\"machine\"8t257c\nmore /usr/include/sys/utsname.h\n#define _SYS_NMLN 257  /*\n* 4.0 size of utsname elements\n* Must be at least 257 to\n* support Internet hostnames.\n*/\n#define SYS_NMLN  _SYS_NMLN\nstruct utsname\n{\nchar sysname[_SYS_NMLN];\nchar nodename[_SYS_NMLN];\nchar release[_SYS_NMLN];\nchar version[_SYS_NMLN];\nchar machine[_SYS_NMLN];\n};\n显然adb下的命令是针对struct utsname结构来的。简单地truss uname -a，可以看\n到如下输出\nioctl(1, TCGETA, 0xFFBEE5DC)                    = 0\nsysinfo(SI_ARCHITECTURE, \"sparc\", 257)          = 6\nsysinfo(SI_PLATFORM, \"SUNW,Ultra-5_10\", 257)    = 16\n暂时没有跟踪这几个系统调用在做什么，想必类似/usr/lib/adb/sparcv9/utsname宏。\n15.2 如何启动Solaris 32-bit/64-bit内核\nQ: Algos@Unix 水木清华 2001-12-04 18:12\n对于UltraSPARC-I/Solaris 8，可以修改/platform/sun4u/boot.conf文件，使操作\n系统运行在64位或者32位，但对于其他机型呢，比如E420、E450、E4500之类服务器\n怎么改？好像起来后就是64位的，怎么才能改成32位的呢？\nQ: 显然有一些32-bit驱动程序以及一些应用软件不能工作在64-bit内核下，比如gcc\n编译的32-bit IP Filter。我必须启动到32-bit内核模式下，怎么办？\nA: dkoleary@mediaone.net\n32-bit : ok boot disk kernel/unix\n64-bit : ok boot disk kernel/sparcv9/unix\n为了设置成缺省启动内核模式\n32-bit : ok setenv boot-file kernel/unix\n64-bit : ok setenv boot-file kernel/sparcv9/unix\n为了确定你所启动的内核模式\nisainfo -b\n根据你所启动的内核模式，该命令分别返回32、64\nA: Will Wang &lt;willcyw@kimo.com.tw&gt; 2001-06-09 02:17\n一个办法就是启动时按Stop-A进入OK模式，输入\nok&gt; setenv boot-file kernel/unix\nok&gt; boot\n另一个办法是已经在shell状态下了，执行命令\n# eeprom \"boot-file=kernel/unix\"\n系统重启之后将自动加载32-bit内核\n15.3 gcc支持64-bit编译吗\nQ: gcc -v显示版本2.95.2，isainfo -kv显示64-bit sparcv9 kernel modules，我\n企图通过指定\"-mcpu=v9 -m64\"获得64-bit代码，提示m64未被支持，仅仅指定\nmcpu=v9，在汇编阶段报告\"\"v8 can‘t generate v9 code\"，我使用的汇编器是\n/usr/ccs/bin/as，随Solaris 7/8提供的。\n这是什么问题，我需要一个64-bit汇编器吗，从哪里获取呢？\nA: Robert Banniza &lt;robert@rootprompt.net&gt;\n我并不认为gcc 2.95.2已经开始支持64-bit编译模式，或许你应该考虑采用\nSun WorkShop Compiler SPARC 5.0/6.0。\n15.4 Solaris启动时内核文件找不到了\nQ: 我的Solaris 7莫名其妙死机了，只好关电源，再开，发现错误\nboot with command:boot now\ncann‘t open now\nenter filename[now]:\n怎么办\nA: dkoleary@mediaone.net\n启动时按Stop-A进入ok状态，在这里输入\n32-bit : ok boot disk kernel/unix\n64-bit : ok boot disk kernel/sparcv9/unix\n为了设置成缺省启动内核模式\n32-bit : ok setenv boot-file kernel/unix\n64-bit : ok setenv boot-file kernel/sparcv9/unix\nA: liqun.bbs@bbs.gznet.edu.cn\n试试这个，启动时按Stop-A进入OK状态\nOK&gt; setenv boot-file kernel/unix\nOK&gt; reset\n15.5 64-bit驱动程序无法在8下关联，但在7下工作正常\nQ: 一个64-bit驱动程序在Solaris 7下加载、关联(load &amp; attach)成功，但在8下加\n载(load)成功、关联(attach)失败。\nA: Sun Microsystems 1998-06-13\n从Solaris 8开始，64-bit驱动程序必须位于\"sparcv9/\"目录中。而在Solaris 7中，\n尽管不提倡，但即使64-bit驱动程序不在\"sparcv9/\"目录中，也可以加载并关联成功。\n16. 库相关问题\n16.0 为什么用高版glibc编译生成的程序不能与低版glibc搭配运行\nA: jbtzhm &lt;jbtzhm@nsfocus.com&gt; 2003-01-16 16:49\ngcc生成程序时会添加sh_type为SHT_GNU_verdef的节，包含了glibc版本信息，以此\n防止该程序与低版glibc搭配运行。\n16.1 在Solaris 7下编写网络程序需要链接哪些库\nQ: inet_pton()是什么库里的，为什么man手册里无对应内容\nA: scz &lt;scz@nsfocus.com&gt;\n这个函数比较新，还有另外几个，比如inet_ntop()。关于它们的详细介绍参看\n&lt;&lt;Unix Network Programming&gt;&gt; 3.7 小节。文件/usr/include/arpa/inet.h中定义\n有：\nextern int inet_pton ( int, const char *, void * );\n用/usr/ccs/bin/nm工具观察三个动态链接库libresolv.so、libsocket.so、\nlibnsl.so提供的全局函数\n$ nm -g /usr/lib/libresolv.so | grep \"|FUNC |GLOB |\" | grep -v \"|UNDEF  |\"\n... ...\n[1043]  |     25104|     632|FUNC |GLOB |0    |12     |inet_aton\n[1088]  |     24220|      80|FUNC |GLOB |0    |12     |inet_ntop\n[1061]  |     25928|      72|FUNC |GLOB |0    |12     |inet_pton\n... ...\n$ nm -g /usr/lib/libsocket.so | grep \"|FUNC |GLOB |\" | grep -v \"|UNDEF  |\"\n... ...\n[314]   |     31056|      16|FUNC |GLOB |0    |11     |_accept\n[343]   |     31024|      16|FUNC |GLOB |0    |11     |_bind\n[310]   |     31072|      16|FUNC |GLOB |0    |11     |_connect\n[387]   |     31224|      16|FUNC |GLOB |0    |11     |_getpeername\n[377]   |     31240|      16|FUNC |GLOB |0    |11     |_getsockname\n[233]   |     31256|      16|FUNC |GLOB |0    |11     |_getsockopt\n[276]   |     31040|      16|FUNC |GLOB |0    |11     |_listen\n[290]   |     31104|      20|FUNC |GLOB |0    |11     |_recv\n[315]   |     31124|      20|FUNC |GLOB |0    |11     |_recvfrom\n[200]   |     31144|      20|FUNC |GLOB |0    |11     |_recvmsg\n[273]   |     27992|     360|FUNC |GLOB |0    |11     |_ruserpass\n[340]   |     31164|      20|FUNC |GLOB |0    |11     |_send\n[399]   |     31184|      20|FUNC |GLOB |0    |11     |_sendmsg\n[207]   |     31204|      20|FUNC |GLOB |0    |11     |_sendto\n[371]   |     31272|      16|FUNC |GLOB |0    |11     |_setsockopt\n[312]   |     31088|      16|FUNC |GLOB |0    |11     |_shutdown\n[272]   |     30320|      16|FUNC |GLOB |0    |11     |_socket\n[385]   |     16820|      96|FUNC |GLOB |0    |11     |getnetbyaddr\n[334]   |     16724|      96|FUNC |GLOB |0    |11     |getnetbyname\n[212]   |     18212|      96|FUNC |GLOB |0    |11     |getprotobyname\n[282]   |     19716|      96|FUNC |GLOB |0    |11     |getservbyname\n[388]   |     19812|      96|FUNC |GLOB |0    |11     |getservbyport\n[373]   |     15152|       8|FUNC |GLOB |0    |11     |htonl\n[375]   |     15160|      12|FUNC |GLOB |0    |11     |htons\n[289]   |     15172|       8|FUNC |GLOB |0    |11     |ntohl\n[293]   |     15180|      12|FUNC |GLOB |0    |11     |ntohs\n... ...\n$ nm -g /usr/lib/libnsl.so | grep \"|FUNC |GLOB |\" | grep -v \"|UNDEF  |\"\n... ...\n[3386]  |    119424|      16|FUNC |GLOB |0    |12     |clnt_create\n[3650]  |    217312|     120|FUNC |GLOB |0    |12     |gethostbyaddr\n[3391]  |    217216|      96|FUNC |GLOB |0    |12     |gethostbyname\n[4105]  |    217432|      96|FUNC |GLOB |0    |12     |gethostent\n[4071]  |    170896|      52|FUNC |GLOB |0    |12     |gethostname\n[3759]  |    123100|     648|FUNC |GLOB |0    |12     |inet_addr\n[3857]  |    272664|     244|FUNC |GLOB |0    |12     |inet_ntoa\n... ...\n$\n显然，如果涉及RPC编程，必然需要libnsl.so，而inet_pton()来自libresolv.so。\n总结一下，实在不能确定的时候，编译时指定链接开关如下：\n-lsocket -lnsl -lresolv\n16.2 SUID设置和LD_LIBRARY_PATH环境变量\nQ: RedHat Linux 6.1/6.2，C编程，还有一些脚本\nexecl()以及其他exec...()执行一个SUID程序的时候，出于安全考虑，会清除\nLD_LIBRARY_PATH环境变量，仅仅依靠系统全局设置搜索共享库。参看如下URL\nhttp://spdoc.pdc.kth.se/doc_link/C/a_doc_lib/libs/basetrf1/exec.htm\n现在有一个程序，需要一个正确的LD_LIBRARY_PATH环境变量设置才能运行，可是\n由于某些原因必须做SUID设置，结果最终运行失败。我尝试在程序中putenv()、\nsetenv()，失败，显然LD_LIBRARY_PATH环境变量需要在程序加载过程中由动态链\n接器使用，程序中的putenv()、setenv()为时已晚。\n于是我写了一个脚本，在脚本中设置LD_LIBRARY_PATH环境变量，调用C程序，对\n脚本做SUID设置。但是脚本的SUID设置并没有传递给子进程(这里就是那个C程序)\nA: Paul Sack &lt;paul-sackun@jefe.eyep.net&gt;\n到www.google.com用\"suid shell scripts race conditions\"进行搜索，查看\nBugTraq相关讨论。安全的解决办法是用C写一个SUID WRAPPER去exec...()你的C程序，\n在SUID WRAPPER中设置LD_LIBRARY_PATH环境变量。下面这个举例未经测试\n--------------------------------------------------------------------------\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\nconst char * env_init[] = { \"LD_LIBRARY_PATH=/your/path/\", NULL };\nint main ( void )\n{\nexecle( \"/full/path/to/program\", \"program\", \"arg1\",\n\"arg2\", ... , NULL, env_init );\nperror( \"Error in execle\" );  /* execle did not work */\nexit( 1 );\n}\n--------------------------------------------------------------------------\n参看Stevens的APUE(Unix环境高级编程)Page 211，我高度推荐你研究该书。记得给\n这个wrapper加suid设置。\nA: Hemant Shah &lt;shah@typhoon.xnet.com&gt;\n我碰到过同样的问题，当时的解决办法是编辑/etc/ld.so.conf文件，增加一条共享\n搜索路径，最后运行ldconfig命令。执行一个命令(无论是否SUID)时，动态链接器检\n查由ldconfig命令产生的cache文件(/etc/ld.so.cache)，根据其中的路径设置搜索\n共享库，比如\n$ cat /etc/ld.so.conf\n/usr/X11R6/lib\n/usr/lib\n/usr/i486-linux-libc5/lib\n/usr/lib/qt-2.0.1/lib\n/usr/lib/qt-1.44/lib\n/opt/MfCobol_V4.1_8d.H3.13.03/coblib\n$\n最后一条路径是我增加的，然后运行ldconfig命令。\nA: Unkown\n但是这种解决办法只能工作在Linux上，并不适用其他ELF系统，比如Solaris。对于\n这些系统，可以在链接器命令行上指定额外的共享库搜索路径，或者在编译时设置\nLD_RUN_PATH环境变量\nD: BugTraq MailList\n考虑下面的程序\n--------------------------------------------------------------------------\n/*\n* gcc -Wall -pipe -O3 -o suid suid.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/types.h&gt;\nint main ( void )\n{\nprintf( \"uid[%d] euid[%d] gid[%d] egid[%d]\\n\",\ngetuid(), geteuid(), getgid(), getegid() );\nreturn( 0 );\n}\n--------------------------------------------------------------------------\n# chown root suid\n# chmod u+s suid\n$ ./suid\nuid[505] euid[0] gid[100] egid[100]\n编辑一个如下脚本suid.sh\n--------------------------------------------------------------------------\n#! /home/scz/src/suid\n--------------------------------------------------------------------------\n$ ./suid.sh\nuid[505] euid[0] gid[100] egid[100]\n在RedHat 6 2.2.12-20上测试的。但是这样有什么意义呢？不懂\nA: Andrew Gierth &lt;andrew@erlenstar.demon.co.uk&gt;\n如果一个程序是SUID过的，将导致LD_LIBRARY_PATH环境变量被忽略，但是这不是问\n题本质所在，本质原因在于ruid不等于euid(或者rgid不等于egid)。所以wrapper中\n仅仅重置环境变量是不够的，必须想办法修改ruid等于euid。最好还是重新编译程序，\n使之不依赖于LD_LIBRARY_PATH环境变量。\n16.3 链接过程中库的顺序\nQ: 有几个库文件A.a、B.a、common.a，前两者用到了定义在后者中的例程，如果把\ncommon.a放在前面，链接器报告存在无法解析的符号名，放在最后则无问题。\nA: Floyd Davidson &lt;floyd@ptialaska.net&gt;\n链接器按照命令行上指定顺序搜索库文件和目标文件(.a .o)，二者之间的区别在\n于.o文件被全部链接进来，而只从库文件中析取所需模块，仅当某个模块可以解\n析当前尚未成功解析的符号时，该模块被析取后链接进来。如果库文件无法解析\n任何当前尚未成功解析的符号，不从中析取也不发生链接。\nUnix编程新手的常见问题是数学函数并不在标准C库中，而是在libm.a中\ncc -lm foo.c\n这里foo.c用到了数学库中的符号，但是链接器无法正确解析。当搜索到libm.a时，\n来自foo.c的数学函数符号尚未出现，因此不需要析取libm.a的任何模块。接下来\nfoo.o链接进来，增加了一批尚未成功解析的符号，但已经没有libm.a可供使用了，\n因此数学库必须在foo.o之后被搜索到。\ncc foo.c -lm\n在你的问题中，如果common.a首先被搜索到，因为不匹配尚未成功解析的符号，\n而被丢弃。结果A.a和B.a真正链接进来的时候，已经没有库可以解析符号了。\nD: 注意这里说的是静态库，对于动态库则有所不同。如果指定-static静态编译，就\n要特别注意这个库的顺序问题。\n16.4 Solaris 2.x下如何构造动态链接库\n16.5 如何生成linux下的共享库\n16.6 /usr/lib/ld.so.1损坏或丢失\nQ: 意外地覆盖了ld.so.1，幸运的是有一个原始备份，可我没有一个静态链接版本的\n命令去恢复它。\nQ: 我在Solaris 2.6中做了\"mv /usr/lib /usr/lib1\"，本意是想使用自己的库，但\n是现在所有程序都报告\"找不到/usr/lib/ld.so.1\"，怎么办\nA: scz &lt;scz@nsfocus.com&gt;\n不要重启动，立即用/usr/sbin/static/mv、/usr/sbin/static/cp命令恢复\n# ls /usr/sbin/static\ncp*   ln*   mv*   rcp*  tar*\n#\nQ: 那如果此时/usr被改名了，怎么办？\nA: faint，谁这么变态。假设/usr改名成了/faint，\n1) /faint/sbin/static/cp /faint/sbin/static/mv /tmp/mv\n2) /tmp/mv /faint /usr\n我不确定\n1) /faint/sbin/static/mv /faint /usr\n能否成功，你可以自己测试一下效果。或者\nok boot cdrom -s (放入启动安装光盘)\nmount -F ufs /dev/dsk/c0t0d0s0 /mnt (这里指定原根文件系统对应的设备名)\nmv /mnt/faint /mnt/usr\nD: cirrus@SMTH\n建议把/usr/sbin/static下的东西拷一份到/sbin下或者其它比较可信的跟/在同一个\nfs的目录下。装机器的时候，不管什么OS，/usr都是单独一个fs的。\n16.7 Solaris下如何使用LD_PRELOAD环境变量\nA: Sun Microsystems 1999-06-15\n下面即将演示如何利用LD_PRELOAD环境变量影响标准I/O库函数printf(3S)。环境变\n量LD_PRELOAD的值是whitespace-separated的共享库列表，运行时链接器负责解释它。\n由LD_PRELOAD指定的共享库优于其他共享库加载。\n--------------------------------------------------------------------------\n/* main.c */\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main ( int argc, char * argv[] )\n{\nchar s[] = \"Hello World\\n\";\nprintf( s );\nreturn( EXIT_SUCCESS );\n}\n--------------------------------------------------------------------------\n--------------------------------------------------------------------------\n/* mylib.c */\n#include &lt;ctype.h&gt;\n#include &lt;unistd.h&gt;\nint printf ( char * s )\n{\nchar *t = s;\nwhile ( *s )\n{\n*s = toupper( *s ), s++;\n}\nreturn( ( int )write( 0, t, strlen( t ) ) );\n}\n--------------------------------------------------------------------------\n--------------------------------------------------------------------------\n# Makefile\nCC=\"/opt/SUNWspro/SC5.0/bin/cc\"\nall: a.out\nmylib.so: mylib.c\n&lt;TAB&gt; ${CC} -g -G -o mylib.so mylib.c\na.out:  main.c mylib.so\n&lt;TAB&gt; ${CC} -g main.c\nclean:\n&lt;TAB&gt; rm -rf mylib.so mylib.o a.out *~\n--------------------------------------------------------------------------\n[scz@ /export/home/scz/src]&gt; sotruss ./a.out\na.out           -&gt;       libc.so.1:*atexit(0xff3b9c6c, 0x20800, 0x0)\na.out           -&gt;       libc.so.1:*atexit(0x109f0, 0xff3b9c6c, 0xff235e68)\na.out           -&gt;       libc.so.1:*printf(0xffbefa47, 0xff239c1c, 0xff235e60)\nHello World\na.out           -&gt;       libc.so.1:*exit(0x0, 0xffbefabc, 0xffbefac4)\n[scz@ /export/home/scz/src]&gt;\n注意到来自动态链接库\"libc.so.1\"的库函数printf()在\"a.out\"中被调用。现在，如\n果你想使用来自\"mylib.so\"的printf()函数，利用LD_PRELOAD环境变量通知运行时链\n接器优先使用\"mylib.so\"解析未知符号。\n[scz@ /export/home/scz/src]&gt; LD_PRELOAD=./mylib.so ./a.out\nHELLO WORLD\n[scz@ /export/home/scz/src]&gt;\n为了解释更清楚些，再次使用sotruss(1)命令\n[scz@ /export/home/scz/src]&gt; LD_PRELOAD=./mylib.so sotruss ./a.out\na.out           -&gt;       libc.so.1:*atexit(0xff3b9c6c, 0x20800, 0x0)\na.out           -&gt;       libc.so.1:*atexit(0x109f0, 0xff3b9c6c, 0xff235e68)\na.out           -&gt;        mylib.so:*printf(0xffbefa27, 0xff239c1c, 0xff235e60)\nHELLO WORLD\na.out           -&gt;       libc.so.1:*exit(0x0, 0xffbefa9c, 0xffbefaa4)\n[scz@ /export/home/scz/src]&gt;\n如你所见，运行时链接器现在使用了来自动态链接库\"mylib.so\"的printf()函数。\n16.8\n16.9 Solaris 8下如何配置运行时链接环境\nQ: 在Linux下我知道用ldconfig(8)配置运行时链接环境，但是在Solaris 8下呢\nA: &lt;cypher@punk.net&gt;\n你总是可以利用 LD_LIBRARY_PATH 环境变量，对于Solaris 8，还可以参看crle(1)\n手册页。\nA: Logan Shaw &lt;logan@cs.utexas.edu&gt;\n如果在链接时使用了\"-R\"和\"-L\"选项，则相关动态库的路径将保存在ELF文件中，于\n是以后的运行中不再需要设置环境变量去定位动态库。比如，有一个\n/usr/local/lib/libfoo.so，而你的bar程序需要这个libfoo.so，编译、链接时最好\n这样\ngcc -Wall -pipe -O3 -o bar -R/usr/local/lib -L/usr/local/lib bar.c -lfoo\nD: 对于FreeBSD/Linux，man ldconfig\n16.10 libcrypto.so.0.9.6是什么软件包里的\n16.11 共享库的动态加载/卸载\nA: Mark Mitchell，Jeffrey Oldham，Alex Samuel 2002-08-07 22:43\n这份文档来自&lt;&lt;Advanced Linux Programming&gt;&gt;，解释如何动态加载共享库，使用这\n种技术你可以在程序中精确控制加载某个共享库。本文同时讨论了共享库中符号解析\n问题。\ndlopen( \"libtest.so\", RTLD_LAZY );\n这个调用将打开共享库libtest.so，第二形参通常都是RTLD_LAZY。为了使用dlopen\n函数，需要包含&lt;dlfcn.h&gt;头文件，指定链接开关-ldl。\n假设libtest.so中定义了函数my_function\n--------------------------------------------------------------------------\nvoid   *handle;\nvoid ( *test ) ( void );\nhandle = dlopen( \"libtest.so\", RTLD_LAZY );\ntest   = dlsym( handle, \"my_function\" );\ntest();\ndlclose( handle );\n--------------------------------------------------------------------------\ndlsym()系统调用还可用于获取指向共享库中某个静态变量的指针。dlopen与dlsym调\n用失败时均返回NULL，此时可以调用dlerror(没有形参)获取相应的可读错误信息。\ndlclose函数用于卸载共享库。技术上，dlopen只在一个共享库尚未被加载的情况下\n真正加载它。如果一个共享库已经被加载了，dlopen简单地递增该共享库引用计数。\n类似的，dlclose递减共享库引用计数，当引用计数达到零时卸载共享库。\n如果你是用C++编写共享库，而又想用dlsym访问其中的函数、静态变量，可能需要这\n样定义:\n--------------------------------------------------------------------------\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\nstatic char my_char;\nstatic void my_funtion ( void );\n#ifdef __cplusplus\n}\n#endif\n--------------------------------------------------------------------------\n这使得C++编译器保持my_char、my_funtion的原始名字。对于C编译器不存在该问题。\n一个共享库可能会引用外部定义的函数和变量。假设你用dlopen打开这样一个共享库。\n如果指定了RTLD_LAZY，Linux不会在立即解析未定义的符号名，直到共享库中代码第\n一次试图引用未定义的符号名，Linux才开始解析它。如果解析成功，程序继续执行，\n反之显示错误信息并终止程序。如果指定了RTLD_NOW，Linux会在调用dlopen时立即\n解析未定义的符号名。解析失败时dlopen返回NULL。\n那么Linux根据什么解析未定义的符号名呢，有这么几种情况:\n如果主程序引出(exports)任意动态符号(共享库正是这样做的)，则这些符号自然可\n用。然而缺省情况下，常规可执行程序不会以动态符号形式引出它们的函数和变量名。\n为了达到这个效果，可以在编译时指定\"-Wl,-export-dynamic\"，这实际是链接选项。\n如果主程序编译时选择了动态链接，则dlopen打开的库可以引用编译时共享库中的符\n号。\n如果主程序使用dlopen打开共享库A、B，缺省情况下A与B彼此不能引用对方定义的动\n态符号。但是可以在dlopen第二形参上逻辑或一个RTLD_GLOBAL标志，使得相应共享\n库中动态符号全局可见。\n--------------------------------------------------------------------------\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;dlfcn.h&gt;\nint main ( int argc, char * argv[] )\n{\nvoid   *handle;\nvoid ( *foo ) ( void );\nhandle = dlopen( \"libfoo.so\", RTLD_LAZY );\nfoo    = dlsym( handle, \"foo\" );\nfoo();\ndlclose( handle );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n假设foo()调用了另一个函数bar()，而bar()不是libfoo.so中定义的，怎么办。\n一种办法是在你的主程序里包含bar()函数体，然后指定\"-Wl,-export-dynamic\"编译\n主程序:\n$ cc -Wl,-export-dynamic -o main main.c bar.c -ldl\n第二种办法是将bar()放到单独一个共享库里，编译时动态链接进主程序\n$ cc -fPIC -shared -o libbar.so bar.c\n$ cc -o main main.c libbar.so -ldl\n第三种办法是将bar()放到单独一个共享库里，运行时由main函数调用dlopen动态加\n载。注意，dlopen的第二形参中必须逻辑或RTLD_GLOBAL标志，否则libfoo.so看不到\nlibbar.so引出的动态符号。\n--------------------------------------------------------------------------\nvoid *bar_handle;\nbar_handle = dlopen( \"libbar.so\", RTLD_LAZY | RTLD_GLOBAL );\n--------------------------------------------------------------------------\nQ: 我试图用dlopen()打开一个共享库，该共享库使用了一个extern型变量，后者位\n于主调二进制文件中。但是这个dlopen()调用失败了，报告存在无法解析的外部\n符号。我用的是gcc(Cygnus version 2.9)，怎么解决这个问题。\n--------------------------------------------------------------------------\n/*\n* Library testlib.c\n* gcc -Wall -pipe -O3 -o testlib.o -c testlib.c\n* /usr/ccs/bin/ld -G testlib.o -o testlib.so\n*/\nextern int abc;\nvoid testing ( void )\n{\nabc = 0;\nreturn;\n}\n/*\n* Main testcall.c\n* gcc -Wall -pipe -O3 -o testcall testcall.c -ldl\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;dlfcn.h&gt;\nint abc = -1;\nint main ( void )\n{\nvoid *testlib;\nvoid ( *testing_call ) ();\nfprintf( stderr, \"abc = %d\\n\", abc );\nif ( ( testlib = dlopen( \"./testlib.so\", RTLD_NOW | RTLD_GLOBAL ) ) != NULL )\n{\ntesting_call = dlsym( testlib, \"testing\" );\n( *testing_call )();\nfprintf( stderr, \"abc = %d\\n\", abc );\n}\nreturn( EXIT_SUCCESS );\n}\n--------------------------------------------------------------------------\nA: Sun Microsystems 2001-04-11\nSun这份文档认为如果使用Sun Workshop编译、链接，将不存在前述问题。如果使用\ngnu ld生成主调程序，应该使用--export-dynamic选项。\n在SPARC/Solaris 7/8 64-bit kernel mode测试上述程序，并无问题，这可能是因为\n并未使用gnu ld的缘故，此时使用的是/usr/ccs/bin/ld。当前gcc版本:\n$ gcc -v\ngcc version 2.95.2 19991024 (release)\n$\nA: flyriver 2001-12-16 22:48\nLinux系统中编译主调程序时加上\"-rdynamic\"参数\nQ: 在libfoo.so中实现了func1()、func2()，其中func2()调用了func1()。主调程序\nprog.c中包含一个同名函数func1()，但与libfoo.so中func1()有不同形参类型。\nprog.c使用dlopen()打开libfoo.so，并调用其中的func2()。我期望此时func2()\n仍去调用libfoo.so中的func1()，但现在事实是调用了prog.c中的func1()，怎么\n办。\nA: Paul Pluzhnikov &lt;ppluzhnikov@earthlink.net&gt; 2003年5月31日 13:05\n对于Win32、AIX来说，你所期待的效果是缺省行为，但其它操作系统未必如此。对于\nSolaris、FreeBSD、Linux，使用gnu ld生成libfoo.so时应指定-Bsymbolic。缺省情\n况下没有指定-Bsymbolic，此时prog.c中的func1()被func2()调用。\nA: Mars Rullgard &lt;mru@users.sourceforge.net&gt; 2003年5月30日 17:09\n如果libfoo.so没有使用prog.c中符号(变量、函数)，使用gnu ld链接prog.c时不要\n指定-rdynamic或者-export-dynamic，这样prog.c中func1符号不被引出，func2()就\n不会调用func1()。如果还是不能解决问题，设法使func1这个符号成为weak symbol，\n假设你正在使用gcc，可以这样做:\nint __attribute__((weak)) func1 ( ... )\n{\n... ...\n}\n16.12 编译时命令行指定-ldl，ldd观察时却是libdl.so.2，为什么\nA: jbtzhm &lt;jbtzhm@nsfocus.com&gt; 2003-01-16 16:49\nld命令在链接过程中填写ELF文件的DT_NEEDED域，也就是ldd命令所观察到的内容，\n下面是ELF规范\n--------------------------------------------------------------------------\n* DT_NEEDED\n该表项给出一个string table index，对应的串是所需要的库名字。这个string\ntable由DT_STRTAB表项确定。_DYNAMIC数组可能包含多个这样的表项，这种表项间的\n相互顺序很重要。\n* DT_SONAME\n该表项给出一个string table index，对应的串是动态链接库名。这个string\ntable由DT_STRTAB表项确定。\n--------------------------------------------------------------------------\nld在填写DT_NEEDED域时，首先采用动态库自身的DT_SONAME域，如果没有此域，则采\n用动态库文件名。可以查看ELF文件的\".dynamic section\"获取DT_SONAME设置:\n. 在SPARC/Solaris 8上执行\"elfdump -d /lib/libdl.so | grep SONAME\"\n. 在x86/Linux上执行\"objdump -x /lib/libdl.so | grep SONAME\"\nQ: 编译动态链接库时如何指定DT_SONAME\nA: jbtzhm &lt;jbtzhm@nsfocus.com&gt; 2003-01-16 16:49\n一般如此编译生成动态链接库\ngcc -fpic -shared -O4 -pipe -s -o libfile.so file.c\n此时没有指定DT_SONAME，如欲指定DT_SONAME，可用如下命令编译\ngcc -c -fPIC file.c -O3 -o file.o\ngcc -shared -Wl,-soname,libfile.so.1 -O3 -o libfile.so file.o\n此时DT_SONAME被指定成libfile.so.1，ldd看到libfile.so.1，而不是libfile.so。\n16.13 如何进行部分静态链接\nQ: 在g++/gcc命令行上指定-static时，所有库都进行静态链接，但是现在我想部分\n静态链接，比如:\nstatically     lib_a.a\ndynamically    lib_b.so\nA: Valentin Nechayev &lt;netch@segfault.kiev.ua&gt; 2003-03-12 10:45\n如果使用GNU ld，可以这样试试:\ngcc -o $prog $objs -Wl,-Bstatic -l_a -Wl,-Bdynamic -l_b -Wl,-Bdynamic\n最后的-Wl,-Bdynamic表示将缺省库链接模式恢复成动态链接，比如libc的链接。如\n果使用的不是GNU ld，请参看相应的man手册。\n17. 文件查看问题\n17.0 如何改变vi临时目录\nQ: 缺省情况下vi临时目录是/var/tmp，可是现在由于某些原因该目录只读，我想使\n用vi。\nA: 一般修改$HOME/.exrc，在其中设置一行\"set directory=/tmp\"。如果$HOME也是\n只读的，还可以export EXINIT=\"set directory=/tmp\"。然后执行vi即可。\n17.1 如何直接查看man文件\nA: scz &lt;scz@nsfocus.com&gt;\n下面几种方法都可以\n/bin/nroff -man &lt;your man doc&gt; | more -s\ngroff -Tlatin1 -mandoc &lt;your man doc&gt; | less\ngroff -s -p -t -e -Tascii -mandoc &lt;your man doc&gt; | less\n有less的时候建议使用less，而不是more。\n在Linux下更简单，不用这样麻烦，比如\nls /usr/man/man5/nologin.5.gz\nman /usr/man/man5/nologin.5.gz\nman /usr/man/man1/finger6.1\n无论什么系统，总是可以利用MANPATH环境变量的\n$ mkdir man1\n$ cp /usr/man/man1/proc.1 man1\n$ man -s 1 -M . proc\n17.2 .tex文件怎么读\nA: shuoshu.bbs@bbs.whnet.edu.cn\n用 latex *.tex 编译生成dvi文件，然后用 xdvi 看\n17.3 Solaris下怎么看.ps文件\nA: lose@水木清华 Unix\n/usr/dt/bin/sdtimage *.ps\n18. 补丁相关问题\n18.1 如何根据补丁号从Sun主站下载补丁\n18.2 删除旧式补丁备份，释放被占用的磁盘空间\nA: Sun Microsystems 1997-11-18\n使用installpatch安装补丁时，缺省操作是保存原有文件，以便将来可以卸载补丁恢\n复原貌。系统管理员可以删除这些备份文件，释放被占用的磁盘空间。旧式补丁数据\n位于/var/sadm/pkg目录中，比如\n# find /var/sadm/pkg -type f -name \"*.Z\" -print\n/var/sadm/pkg/SUNWcsr/save/104560-01/undo.Z\n/var/sadm/pkg/SUNWmfrun/save/103461-10/undo.Z\n/var/sadm/pkg/SUNWsunpc/save/102924-06/obsolete.Z\n/var/sadm/pkg/SUNWsunpc/save/102924-25/undo.Z\n#\nundo.Z 是对最后一次补丁安装的备份。obsolete.Z 是对倒数第二次补丁安装的备份。\n在这个例子中，补丁102924安装过两次，一次是版本6， 一次是版本25。可以删除\nobsolete.Z备份\n# find /var/sadm/pkg -type f -name \"obsolete.Z\" -exec rm {} \\;\n也可以删除undo.Z备份\n# find /var/sadm/pkg -type f -name \"undo.Z\" -exec rm {} \\;\n注意，一旦删除undo.Z备份，执行backoutpatch命令时报错，无法卸载现有补丁。\n18.3 patchdiag如何使用\n18.4 给Solaris 2.6安装推荐补丁集(未完成)\n18.5 已知补丁号，如何最快判断系统中是否已经安装该补丁\nA: scz &lt;scz@nsfocus.com&gt;\n# showrev -p | grep \"^Patch: 105181\"\nPatch: 105181-05 Obsoletes: 105636-01, 105776-01 Requires: ...\n#\nQ: 怎样看Solaris已经装了哪些patch\nA: tobago@水木清华 Unix 2002-07-03 21:48\n1) showrev -p\n显示系统中已经安装的所有补丁，普通用户即可执行。比如得到这个输出\nPatch: 108869-15 Obsoletes:  Requires:  Incompatibles:  Packages: SUNWmibii, SUNWsasnm, SUNWsadmi, SUNWsacom, SUNWsadmx, ...\n2) /usr/sbin/patchadd -p\n同上，不过这是一个shell script，要求以root身份执行\n3) $ pkgparam SUNWmibii PATCHLIST\n108869-15\n$\n通用格式是\"pkgparam &lt;package&gt; PATCHLIST\"，显示应用到指定包的所有补丁。\n4) $ pkgparam SUNWsadmi PATCH_INFO_108869-15\nInstalled: Wed Mar 20 10:04:48 CST 2002 From: Sun8        Obsoletes:  Requires: Incompatibles:\n$\n通用格式是\"pkgparam &lt;package&gt; PATCH_INFO_&lt;patch-number&gt;\"，显示何时从何\n处安装了相应补丁到本机。\n18.6 如何安装补丁\n19. 终端相关问题\n19.0 如何将stdin、stdout、stderr重定向到/dev/null\nQ: 我使用了如下代码将stdin、stdout、stderr重定向到/dev/null\nfreopen( \"/dev/null\", \"w\", stdout );\nfreopen( \"/dev/null\", \"w\", stderr );\nfreopen( \"/dev/null\", \"r\", stdin );\n这样做正确吗，是否使用\"w+\"或者\"a\"更正确一些。在很多代码中是这样完成重定\n向的:\nclose( 0 );\nclose( 1 );\nclose( 2 );\nopen( \"/dev/null\", O_RDWR );\ndup( 0 );\ndup( 0 );\n这两种方式中哪一种更好、更具可移植性。\nA: Andrew Gierth &lt;andrew@erlenstar.demon.co.uk&gt;\n第一种方式不是总能达到目的。freopen()并不确保新的文件流描述符一定重用底层\n原有文件句柄号。假如未能重用，向stderr流输出的标准I/O函数最终输出到\n/dev/null，但那些向STDERR_FILENO句柄输出的标准I/O函数就没这么幸运了，可能\n输出到一些不可预期的文件中去。换句话说，2号句柄此时不再是标准错误输出了。\n比如:\nwrite( 2, ... )\n这样的调用存在安全问题。第二种方式可以避免上述问题，然而存在竞争环境问题。\n现在看下述代码:\n--------------------------------------------------------------------------\nint fd = open( \"/dev/null\", O_RDWR );\n/*\n* handle failure of open() somehow\n*/\ndup2( fd, 0 );\ndup2( fd, 1 );\ndup2( fd, 2 );\nif ( fd &gt; 2 )\n{\nclose( fd );\n}\n--------------------------------------------------------------------------\n与第二种方式相比，这种代码是线程安全的。\n有人认为对于后台守护进程做此类重定向操作浪费资源，建议直接关闭0、1、2号句\n柄拉倒，这是非常不正确的。假设它们确实被关闭了，则一些普通数据文件句柄将等\n于0、1、2。以2号句柄为例，某些库函数失败后会向2号句柄输出错误信息，这将破\n坏原有数据。\nD: 小四 &lt;scz@nsfocus.com&gt; 2002-04-25 16:47\n2号句柄的此类安全问题在2002年4月23日得到了实际印证，可参看&lt;&lt;x86/FreeBSD\n4.5-RELEASE IO Smash及S/Key机制分析&gt;&gt;。\n1987年，Henry Spencer在setuid(7)手册页中做了如下建议，一切标准I/O句柄都可\n能因关闭过而不再是真实的标准I/O句柄，在使用printf()一类的函数前，务必确认\n这些句柄是期待中的标准I/O句柄。1991年，在comp news上有人重贴了这份文档。\n内核补丁应该确保对于SUID、SGID进程而言，0、1、2号句柄不会被打开后指向一个\n普通文件。这有很多实现方式，比如使它们全部指向/dev/null。这种限制不应该在\n库函数一级实现，可能有些SUID、SGID程序直接使用系统调用。\nstdin、stdout、stderr中某一个被关闭，都可能潜在存在问题。\n1992年W. Richard Stevens在&lt;&lt;Advanced Programming in the UNIX Environment&gt;&gt;\n中建议Daemon进程应该关闭所有不必要的文件句柄，并将stdin、stdout、stderr指\n向/dev/null。\n自1998年以来，OpenBSD内核中execve()里有一个检查，如果句柄0、1、2是关闭的，\n就打开/dev/null，使之对应0、1、2号句柄。这样就可以安全地执行setuid程序了。\nFreeBSD/NetBSD直至最近才再次暴露出类似问题，而Linux在glibc中做了一些检查。\n但是，OpenBSD这个检查存在一个问题，当falloc()失败时，应该转向错误处理，而\n不是简单地跳出循环。art在注释中指出了这点，却无人去修正它。\n--------------------------------------------------------------------------\nsys/kern/kern_exec.c\n在一个循环中，内核试图打开/dev/null，使之对应0-2号句柄\n(...)\nif ( ( error = falloc( p, &amp;fp, &amp;indx ) ) != 0 )\n{\nbreak;\n}\n(...)\n--------------------------------------------------------------------------\n于是本地用户获得一个内核文件表项相关的竞争环境，可以获取root权限。\n19.1 如何使Backspace键做删除操作，而不是显示^H\nQ: Backspace键并未删除光标左面那个字符，仅仅显示^H，而DEL键完成了删除操作\nA: Sun Microsystems 2001-03-08\n执行\"stty -a\"将看到\"erase = ^?\"，表示此时DEL键对应删除操作。\n如果正在使用xterm，可以用\"tset\"命令设置控制字符对应的操作。其他窗口中，假\n设目前使用/sbin/sh，尝试\n$ stty erase ^H\n这里^H的输入是Ctrl-H，某些时候可能需要Ctrl-V、Ctrl-H输入，还可以尝试\n$ stty erase \"^h\"\n$ stty erase \"^H\"  (大小写不敏感)\n这里输入\"^H\"，就是两个字符，一个^，一个H。\n同样，如果想恢复到DEL删除\n$ stty erase ^?\n这里^?的输入是DEL，某些时候可能需要Ctrl-V、DEL输入，还可以尝试\n$ stty erase \"^?\"\n这里输入\"^?\"，就是两个字符，一个^，一个?。\n为了永久保留这个设置，在所使用的shell初始化文件中增加设置命令，比如c shell\n的\".cshrc\"，其他shell的\".login\"。\n19.2 telnet时如何关闭本地回显\n19.3 如何清空stdin的缓冲\nA: law@bbs.apue.net\nstdin-&gt;_IO_read_ptr = stdin-&gt;_IO_read_end;\n不过这个办法实在不怎么样。一是只对glibc有效，不可移植。二是违背流的思想，\n老老实实用fgets()好了。\nA: scz &lt;scz@nsfocus.com&gt; 2003-01-12 19:16\ntcflush( STDIN_FILENO, TCIFLUSH );\n19.4 Linux Console下一按错键就叫，怎么关\nA: windtear@bbs.tsinghua.edu.cn Linux版\n有个1050110 背一下就可以了\necho -e \"\\\\33[10;50]\\\\33[11;0]\"\n10 50      11 0\n放到那些登录自启动脚本里\nA: Sidos@smth.org\n如果想在X下也没有这个声音，在/etc/inputrc里加上\nset bell-style none\nQ: 输完命令后是没声了，可从KDE回来之后又有了，请问能彻底关掉吗\nA: TheCool@bbs.tsinghua.edu.cn Linux版\nsetterm -blength 0 -bfreq 0\nD: 对于FreeBSD，如果你不想在XWindow下听到beep，可以\"xset b off\"\n19.5 从stdin立即获取按键\nQ: Linux/C编程环境，从标准输入stdin读取内容时，有无办法立即获取按键，而不\n必等待换行。事实上我需要MS-DOS下的kbhit()、getch()函数。\n有些人总是建议进入(n)curses环境，可我不想使用这种多此一举的技术。\nA: Floyd Davidson &lt;floyd@ptialaska.net&gt;\n我们就作者所提供的原始代码进行了一些移植、修正，手头系统有限，未做更广泛的\n可移植性测试。\n--------------------------------------------------------------------------\n/*\n* For x86/Linux Kernel 2.4.7-10\n* gcc -DLinux -Wall -pipe -O3 -o input_demo input_demo.c\n*\n* For x86/FreeBSD 4.5-RELEASE\n* gcc -DFreeBSD -Wall -pipe -O3 -o input_demo input_demo.c\n*\n* For SPARC/Solaris 8\n* gcc -DSolaris -Wall -pipe -O3 -o input_demo input_demo.c\n*\n* kbhit() -- a keyboard lookahead monitor\n* getch() -- a blocking single character input from stdin\n*\n* Plus a demo main() to illustrate usage.\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;ctype.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;termios.h&gt;\n#include &lt;sys/ioctl.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;sys/types.h&gt;\n#ifdef Solaris\n#include &lt;sys/filio.h&gt;\n#endif\n#undef  TERMIOSECHO\n#define TERMIOSFLUSH\n/*\n* getch() -- a blocking single character input from stdin\n*\n* Returns a character, or -1 if an input error occurs\n*\n* Conditionals allow compiling with or without echoing of the input\n* characters, and with or without flushing pre-existing buffered input\n* before blocking.\n*/\nstatic int getch ( void )\n{\nstruct termios old_termios, new_termios;\nint            error;\nchar           c;\nfflush( stdout );\ntcgetattr( 0, &amp;old_termios );\nnew_termios              = old_termios;\n/*\n* raw mode, line settings\n*/\nnew_termios.c_lflag     &amp;= ~ICANON;\n#ifdef TERMIOSECHO\n/*\n* enable echoing the char as it is typed\n*/\nnew_termios.c_lflag     |=  ECHO;\n#else\n/*\n* disable echoing the char as it is typed\n*/\nnew_termios.c_lflag     &amp;= ~ECHO;\n#endif\n#ifdef TERMIOSFLUSH\n/*\n* use this to flush the input buffer before blocking for new input\n*/\n#define OPTIONAL_ACTIONS TCSAFLUSH\n#else\n/*\n* use this to return a char from the current input buffer, or block\n* if no input is waiting\n*/\n#define OPTIONAL_ACTIONS TCSANOW\n#endif\n/*\n* minimum chars to wait for\n*/\nnew_termios.c_cc[VMIN]   = 1;\n/*\n* minimum wait time, 1 * 0.10s\n*/\nnew_termios.c_cc[VTIME]  = 1;\nerror                    = tcsetattr( 0, OPTIONAL_ACTIONS, &amp;new_termios );\nif ( 0 == error )\n{\n/*\n* get char from stdin\n*/\nerror  = read( 0, &amp;c, 1 );\n}\n/*\n* restore old settings\n*/\nerror                   += tcsetattr( 0, OPTIONAL_ACTIONS, &amp;old_termios );\nreturn( error == 1 ? ( int )c : -1 );\n}  /* end of getch */\n/*\n* kbhit() -- a keyboard lookahead monitor\n*\n* returns the number of characters available to read\n*/\nstatic int kbhit ( void )\n{\nstruct timeval tv;\nstruct termios old_termios, new_termios;\nint            error;\nint            count = 0;\ntcgetattr( 0, &amp;old_termios );\nnew_termios              = old_termios;\n/*\n* raw mode\n*/\nnew_termios.c_lflag     &amp;= ~ICANON;\n/*\n* disable echoing the char as it is typed\n*/\nnew_termios.c_lflag     &amp;= ~ECHO;\n/*\n* minimum chars to wait for\n*/\nnew_termios.c_cc[VMIN]   = 1;\n/*\n* minimum wait time, 1 * 0.10s\n*/\nnew_termios.c_cc[VTIME]  = 1;\nerror                    = tcsetattr( 0, TCSANOW, &amp;new_termios );\ntv.tv_sec                = 0;\ntv.tv_usec               = 100;\n/*\n* insert a minimal delay\n*/\nselect( 1, NULL, NULL, NULL, &amp;tv );\nerror                   += ioctl( 0, FIONREAD, &amp;count );\nerror                   += tcsetattr( 0, TCSANOW, &amp;old_termios );\nreturn( error == 0 ? count : -1 );\n}  /* end of kbhit */\nint main ( int argc, char * argv[] )\n{\nstruct termios old_termios, new_termios;\nint            count;\nint            c;\ntcgetattr( 0, &amp;old_termios );\nprintf( \"You must enter 10 characters to get this program to continue:\" );\nfflush( stdout );\n/*\n* collect 10 characters\n*/\nfor ( count = kbhit(); count &lt; 10; count = kbhit() )\n{\nif ( -1 == count )\n{\nreturn( EXIT_FAILURE );\n}\n}\nnew_termios          = old_termios;\n/*\n* disable echoing of further input\n*/\nnew_termios.c_lflag &amp;= ~ECHO;\ntcsetattr( 0, TCSANOW, &amp;new_termios );\nprintf( \"\\nStop, now type &lt;Enter&gt; to continue\" );\nfflush( stdout );\nc = getchar();\n/*\n* enable echoing of further input\n*/\ntcsetattr( 0, TCSANOW, &amp;old_termios );\nprintf( \"\\nThe first five characters are: [\" );\n/*\n* print a few chars\n*/\nfor ( count = 0; count &lt; 4; count++ )\n{\nprintf( \"%c\", ( char )c );\nc = getchar();\n}\nprintf( \"%c]\\n\\n\", ( char )c );\nprintf( \"****** Demo Menu ******\\n\\n\" );\nprintf( \"Option       Action\\n\" );\nprintf( \"  A          Action_A\\n\" );\nprintf( \"  B          Action_B\\n\" );\nprintf( \"  C          Action_C\\n\" );\nprintf( \"  Q          Exit\\n\\n\" );\nprintf( \"Enter your choice: [ ]\\b\\b\" );\nfflush( stdout );\n/*\n* note that calling getch() will flush remaining buffered input\n*/\nswitch ( c = getch() )\n{\ncase ‘a‘:\ncase ‘A‘:\nprintf( \"%c\\nAction_A\\n\", ( char )toupper( ( int )c ) );\nbreak;\ncase ‘b‘:\ncase ‘B‘:\nprintf( \"%c\\nAction_B\\n\", ( char )toupper( ( int )c ) );\nbreak;\ncase ‘c‘:\ncase ‘C‘:\nprintf( \"%c\\nAction_C\\n\", ( char )toupper( ( int )c ) );\nbreak;\ncase ‘q‘:\ncase ‘Q‘:\nprintf( \"%c\\nExit\\n\", ( char )toupper( ( int )c ) );\nbreak;\ndefault:\nprintf( \"%c\\n\", ( char )toupper( ( int )c ) );\nbreak;\n}\ntcsetattr( 0, TCSANOW, &amp;old_termios );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nD: 小四 &lt;scz@nsfocus.com&gt;\nc_cc[VTIME]以0.10秒为单位指定一个字节间的读取超时，所对应的计时器在接收到\n第一个字节之后才启动，因此c_cc[VMIN]为1的时候，c_cc[VTIME]是多少都无所谓。\n关于这方面的详细讨论参看APUE 11.11小节。\ninput_demo.c:main()中第一个getchar()调用，其本意是在\"规范模式\"下阻塞，等待\n一个换行。SPARC/Solaris 8下语义与x86/Linux Kernel 2.4.7-10、x86/FreeBSD\n4.5-RELEASE不同，在此处未能阻塞住，我怀疑是该版本实现上的一个BUG。\n19.6 如何屏蔽Ctrl-D\nQ: Ctrl-C产生SIGINT信号，Ctrl-D产生什么信号。我想屏蔽Ctrl-D。\nA: W. Richard Stevens\n参看APUE 11.3小节的讨论。\nCtrl-C并不总是固定产生SIGINT信号，只能说通常如此。stty -a命令往往可以看到\nintr = ^C; eof = ^D;\n由当前终端属性决定，而这可以编程改变，或者就用stty命令设置。Ctrl-D通常导致\n阻塞读操作返回EOF，并不产生任何信号，除非刻意设置过。\n顺便说一句，为了指示文件结束，需要在\"新行行首\"输入EOF(通常是Ctrl-D)。\n--------------------------------------------------------------------------\n/*\n* For x86/Linux Kernel 2.4.7-10\n*     x86/FreeBSD 4.5-RELEASE\n*     SPARC/Solaris 8\n* gcc -Wall -pipe -O3 -o ctrl_cd ctrl_cd.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;termios.h&gt;\nint main ( int argc, char * argv[] )\n{\nstruct termios term;\nlong           vdisable = 0;\nchar           buf[80];\nif ( isatty( STDIN_FILENO ) == 0 )\n{\nfprintf( stderr, \"standard input is not a terminal device\\n\" );\nreturn( EXIT_FAILURE );\n}\nvdisable = fpathconf( STDIN_FILENO, _PC_VDISABLE );\nif ( vdisable &lt; 0 )\n{\nperror( \"fpathconf( STDIN_FILENO, _PC_VDISABLE ) error\" );\nreturn( EXIT_FAILURE );\n}\nif ( tcgetattr( STDIN_FILENO, &amp;term ) &lt; 0 )\n{\nperror( \"tcgetattr( STDIN_FILENO, &amp;term ) error\" );\nreturn( EXIT_FAILURE );\n}\n/*\n* disable INTR character\n*/\nterm.c_cc[VINTR] = vdisable;\n/*\n* EOF is Ctrl-B\n*/\nterm.c_cc[VEOF]  = 2;\nif ( tcsetattr( STDIN_FILENO, TCSAFLUSH, &amp;term ) &lt; 0 )\n{\nperror( \"tcsetattr( STDIN_FILENO, TCSAFLUSH, &amp;term ) error\" );\nreturn( EXIT_FAILURE );\n}\nwhile ( fgets( buf, sizeof( buf ), stdin ) != NULL );\nif ( feof( stdin ) != 0 )\n{\nprintf( \"fgets() found EOF\\n\" );\n}\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n由于我们修改了c_cc[VINTR]、c_cc[VEOF]的标准设置，在测试ctrl_cd.c时，Ctrl-C\n与Ctrl-D不再有效，需要用Ctrl-B输入EOF来结束运行。\nctrl_cd.c中没有恢复c_cc[VINTR]、c_cc[VEOF]的标准设置，可以简单利用stty命令\n恢复:\nstty intr ^C\nstty eof ^D\n这里^C用Ctrl-v、Ctrl-c输入，^D用Ctrl-v、Ctrl-d输入。\n20. shell script问题\n20.0 不用临时文件完成字符串替换\n20.1 如何获取一个字符串的长度\nA: Andrei Ivanov &lt;iva@racoon.riga.lv&gt;\nexpr `echo $string | wc -c` - 1\necho $string | awk ‘{ print length( $0 ); }‘\n/usr/ucb/expr length \"$string\"\nexpr \"$string\" : \".*\"\necho \"$string\" | sed ‘s/./1+/g;s/+/ /;s/$/p/‘ | dc\nA: http://www.linuxforum.net\n假设是bash\n$ string=‘1234567890‘\n$ echo ${#string}\n10\n$\n20.2 读超时自动使用缺省值\nQ: shell script编程，不介入expect、perl、tcl等类似工具。读等待60秒，超时则\n自动使用缺省值。可以使用系统缺省外部命令，要求能广泛移植在常用Unix平台\n上\nA: CERNET 华中地区网络中心 PUE(UNIX环境程序设计)版 lookout\n参看comp.unix.shell新闻组，下面以SPARC/Solaris 2.6为例\n--------------------------------------------------------------------------\n#! /sbin/sh\nstty -icanon min 0 time 255\nwhile true\ndo\n/usr/bin/echo \"Press a key or press ENTER to exit:\\c\"\nread key\nif [ \"$key\" = \"\" ] ; then\necho \"\\nYou press Enter or timeout\"\nbreak\nelse\necho \"You press the key $key\"\nfi\ndone\nstty sane\n--------------------------------------------------------------------------\nD: scz &lt;scz@nsfocus.com&gt;\n参看termio(7I)、stty(1)手册页了解更多关于\"非规范模式\"的信息，下面这个C程序\n揭示了上述shell script的本质\n--------------------------------------------------------------------------\n/*\n* For x86/Linux、x86/FreeBSD、SPARC/Solaris\n* gcc -Wall -pipe -O3 -o keypress keypress.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;termios.h&gt;\nstatic struct termios originalTermParam;\nstatic void set_keypress ( void )\n{\nstruct termios currentTermParam;\ntcgetattr( 0, &amp;originalTermParam );\nmemcpy( &amp;currentTermParam, &amp;originalTermParam, sizeof( struct termios ) );\n/*\n* Disable canonical mode, and set buffer size to 1 byte\n*/\ncurrentTermParam.c_lflag       &amp;= ~ICANON;  /* 不设置则允许最快速的读取字符 */\ncurrentTermParam.c_lflag       &amp;= ~ECHO;    /* 不回显                       */\n/*\n* 超时设置，255 * 0.10s，单位是0.10s\n* 这里是一个字节，所以最大值为255\n*/\ncurrentTermParam.c_cc[ VTIME ]  = 255;\n/*\n* 无阻塞输入，CPU占用率很高\n* 如果该值为1，表示至少等待输入一个字符，阻塞\n*/\ncurrentTermParam.c_cc[VMIN]     = 0;\ntcsetattr( 0, TCSANOW, &amp;currentTermParam );\nreturn;\n}  /* end of  set_keypress */\nvoid reset_keypress ( void )\n{\ntcsetattr( 0, TCSANOW, &amp;originalTermParam );\nreturn;\n}  /* end of reset_keypress */\nint main ( void )\n{\nputs( \"main start\" );\nset_keypress();\nwhile ( 1 )\n{\nif ( getchar() == ( int )‘q‘ )\n{\nbreak;\n}\n}\nreset_keypress();\nputs( \"main stop\" );\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nD: 小四 &lt;scz@nsfocus.com&gt; 2001-07-04 13:12\n下面以SPARC/Solaris 2.6为例，提供一个GetYesOrNo()函数，第一形参指定超时缺\n省返回值，第二形参指定超时时限(以0.10秒为单位)，后续形参指定提示信息。\n--------------------------------------------------------------------------\n#! /bin/sh\nGetYesOrNo ()\n{\n# 第一形参指定超时缺省返回值\ncase ${1} in\n0 )\nEXITCODE=${1};;\n* )\n# 非零皆为1\nEXITCODE=1;;\nesac\n# 第二形参指定超时时限(以0.10秒为单位)\nif [ ${2} -le 255 -a ${2} -ge 0 ] ; then\nTIMEOUT=${2}\nelse\n# 缺省超时时限5秒\nTIMEOUT=50\nfi\nshift 2\nSAVETERM=`stty -g`\n# 设置xxx秒后读超时，非规范模式\nstty -icanon min 0 time ${TIMEOUT}\n# Solaris下，sh的内部命令echo支持\\c这种用法\nwhile echo \"$* (Y/N) ?\\c\" &gt;&amp;2\ndo\nread YesOrNo\ncase \"$YesOrNo\" in\n[yY] )\nEXITCODE=0\nbreak;;\n[nN] )\nEXITCODE=1\nbreak;;\n\"\" )\n# 超时或者选择使用缺省值\nbreak;;\n* )\necho \"\\nPlease enter Y(y) or N(n) ... ...\" &gt;&amp;2;;\nesac\ndone\n# stty sane\nstty ${SAVETERM}\necho \"\"\nreturn ${EXITCODE}\n}\nGetYesOrNo 0 50 \"Please select\"\nexit ${?}\n--------------------------------------------------------------------------\n20.3 如何删除空行、空白符组成的行\n20.4 BASH中如何得到一个字符串的子串\n20.5 shell script中如何关闭stdout\n20.6 如何将一个文本文件开始的N行删除\n20.7 以字符串(非单个字符)为分隔的析取\n20.8 使用tr命令加密文件\nA: 水木清华 TheCool\n著名的 rot13 密码, 通过把字母移动13个位置实现对文本的加密\ntr \"[a-m][n-z][A-M][N-Z]\" \"[n-z][a-m][N-Z][A-M]\" &lt; message &gt; newmessage\n然后可以用同样的命令进行解密\ntr \"[a-m][n-z][A-M][N-Z]\" \"[n-z][a-m][N-Z][A-M]\" &lt; newmessage &gt; message\n20.9 有哪些命令用于查找定位\nA: 小四\ntype -a telnet\nwhereis telnet\nwhich telnet\nwhatis telnet &lt;=&gt; man -k telnet\n20.10 非递归删除目录树\nA: 小四 &lt;scz@nsfocus.com&gt;\n先来看一个显示目录树的经典shell script\n--------------------------------------------------------------------------\n#! /bin/sh\n# Author: Kenneth H. Rosen\n#         Richard R. Rosinski\n#         Douglas A. Host\n# Test for x86/FreeBSD\n#\n# ${parameter:-default_value} 如果参数未赋值，将缺省值赋给它\n#\ndir=${1:-.}\n(cd ${dir};pwd)\n#\n# \"s,^${dir},,\"                   删除最前面的一层目录\n# \"/^$/d\"                         删除空行\n# \"s,[^/]*/\\([^/]*\\)$,\\`----\\1,\"  将最后一个/替换成`----\n# \"s,[^/]*/,     ,g\"              从左向右，将此时所有的*/替换成五个空格\n#\nfind ${dir} -type d -print | sort -f | sed -e \"s,^${dir},,\" -e \"/^$/d\" -e \"s,[^/]*/\\([^/]*\\)$,\\`----\\1,\" -e \"s,[^/]*/,     ,g\"\n--------------------------------------------------------------------------\n下面是伪shell script，非递归删除目录树，foreach、goto都是csh才有的内部命令\n--------------------------------------------------------------------------\ncd target_directory\ntarget_directory = `pwd`\nwhile ( true )\n{\nloop:\nrm -f *\nforeach ( 本层目录所有项 )\n{\nif ( 子目录 )\n{\nrmdir 子目录\nif ( 删除失败 )\n{\ncd 子目录\ngoto loop;\n}\n}\nelse\n{\nrm -f 普通文件\n}\n}\nif ( `pwd` == target_directory )\n{\nbreak;\n}\nelse\n{\ncd ..\n}\n}\ncd ..\nrmdir target_directory\n--------------------------------------------------------------------------\n下面是一个csh script，非递归删除目录树\n--------------------------------------------------------------------------\n#! /bin/csh -f\n# Test for x86/FreeBSD\n# Author   : NSFocus Security Team\n#          : http://www.nsfocus.com\n# Maintain : scz &lt;scz@nsfocus.com&gt;\n# Usage    : ./csh_rm &lt;target_directory&gt;\n# Date     : 2002-01-10 15:57\n#\n# 必须指定第一形参\n#\nif ( $#argv != 1 ) then\necho \"Usage: ${0} &lt;target_directory&gt;\"\nexit 1\nendif\n#\n# 第一形参必须是目录\n#\nif ( ! -d ${1} ) then\necho \"Usage: ${0} &lt;target_directory&gt;\"\nexit 1\nendif\n#\n# 这里可以先rm -rf ${1}，如果失败，再用下面的方式删除\n#\ncd ${1}\n#\n# 注意csh的赋值与sh不同，需要set命令的介入\n#\nset target_directory = \"`pwd`\"\n# echo ${target_directory}\nalias ls ‘/bin/ls -1a‘\n#\n# csh支持0、1，不支持false、true\n#\nwhile ( 1 )\nloop:\n#\n# 对于csh，&gt;&amp; 表示将stdout、stderr同时转向/dev/null\n#\n# 其实这里可以用rm -rf * &gt;&amp; /dev/null，下面这句可以注释掉\n#\n# rm -f * &gt;&amp; /dev/null\n#\n# 不知道为什么，foreach entry ( * )存在缓冲现象，导致失败，被迫使用现\n# 在演示的技术\n#\nforeach entry ( `ls` )\nif ( \"${entry}\" == \".\" || \"${entry}\" == \"..\" ) then\ncontinue\nendif\nif ( -d ${entry} ) then\n#\n# 这里可以用rm -rf ${entry} &gt;&amp; /dev/null\n#\nrmdir ${entry} &gt;&amp; /dev/null\nif ( $? != 0 ) then\ncd ${entry}\ngoto loop;\nendif\nelse\nrm -f ${entry} &gt;&amp; /dev/null\nendif\nend\nset current_directory = \".\"\n#\n# 当路径超长时，pwd会报错，不必理会这个错误信息，csh无法单独处理stderr\n#\nset current_directory = \"`pwd`\"\n#\n# if ( \"`pwd`\" == \"${target_directory}\" ) then\n#\n# 如果这样写，我不确认当pwd失败时，是否会继续判断，至少目前的写法得到\n# 验证，可行\n#\nif ( \"${current_directory}\" == \"${target_directory}\" ) then\nbreak;\nelse\ncd .. &gt;&amp; /dev/null\nendif\nend\ncd .. &gt;&amp; /dev/null\nrmdir ${target_directory} &gt;&amp; /dev/null\n--------------------------------------------------------------------------\n$ cp -R /tmp .   &lt;-- 为了安全起见，不要以root身份测试这个脚本\n$ cp -R tmp tmp  &lt;-- 最终会出错\n$ ./csh_rm tmp   &lt;-- 验证这个csh script\n20.11 如何将大写文件名转换为小写文件名\nA: Potash@www.linuxforum.net 2002-02-05 18:58\n--------------------------------------------------------------------------\n#! /bin/sh\n# Usage: ./loworup.sh &lt;-l | -u&gt; &lt;target_directory&gt;\n#\n# 第二形参必须是目录，第一形参指定-l或-u\n#\nif [ $# -ne 2 ] ; then\necho \"Usage: ${0} &lt;-l | -u&gt; &lt;target_directory&gt;\"\nexit 1\nfi\nif [ ! -d ${2} -o \"${1}\" != \"-l\" -a \"${1}\" != \"-u\" ] ; then\necho \"Usage: ${0} &lt;-l | -u&gt; &lt;target_directory&gt;\"\nexit 1\nfi\nexec 1&gt;/dev/null 2&gt;&amp;1\ndir=`dirname \"${2}\"`\ncd ${dir}\nif [ \"${1}\" = \"-l\" ] ; then\nbase=`basename \"${2}\" | tr \"[A-Z]\" \"[a-z]\"`\nelse\nbase=`basename \"${2}\" | tr \"[a-z]\" \"[A-Z]\"`\nfi\nmv -f \"`basename ${2}`\" \"${base}\"\nfor entry in `find ${base}`\ndo\nbefore=\".\"\n#\n# 这个办法依赖for in语法，用空格做分隔符，所以不能处理那些本身名字带空\n# 格的目录项，属于小BUG\n#\nfor after in `echo \"${entry}\" | sed -e ‘s,/, ,g‘`\ndo\ntmp_entry=\"${before}/${after}\"\nif [ \"${1}\" = \"-l\" ] ; then\nbefore=`echo \"${tmp_entry}\" | tr \"[A-Z]\" \"[a-z]\"`\nelse\nbefore=`echo \"${tmp_entry}\" | tr \"[a-z]\" \"[A-Z]\"`\nfi\nmv -f \"${tmp_entry}\" \"${before}\"\ndone\ndone\n--------------------------------------------------------------------------\n20.12 shell script中有办法实现段落注释吗\nQ: C编程中\"#if 0\"可以快速实现段落注释，shell script中如何达到同样效果。\nA: windtear@bbs.tsinghua.edu.cn\ncat &lt;&lt; EOF &gt; /dev/null\n... ...\nEOF\n或者\necho &lt;&lt; EOF &gt; /dev/null\n...\nEOF\n推荐使用echo。\n20.13 批量文件字符串替换\nA: scz &lt;scz@nsfocus.com&gt;\n--------------------------------------------------------------------------\n#! /bin/sh\n# Usage: ./replace.sh &lt;filelist&gt; &lt;srcstr&gt; &lt;dststr&gt;\nif [ $# -ne 3 ] ; then\necho \"Usage: ${0} &lt;filelist&gt; &lt;srcstr&gt; &lt;dststr&gt;\"\nexit 1\nfi\n#\n# 第一形参必须是普通文件\n#\nif [ ! -f ${1} ] ; then\necho \"Checking your &lt;filelist&gt;\"\nexit 1\nfi\nwhile read LINE\ndo\nif [ \"${LINE}\" = \"\" ]\nthen\ncontinue\nfi\n# awk是为了配合grep操作，减少工作量\nLINE_FILE=`echo \"${LINE}\" | awk -F: ‘{print $1;}‘`\n# 第一个,相当于1,$\ned - \"${LINE_FILE}\" &lt;&lt; EOF\n,s,${2},${3},g\nw\nq\nEOF\ndone &lt; \"${1}\"\n--------------------------------------------------------------------------\n21. BSD相关问题\n21.0 在x86/FreeBSD 4.5-RELEASE上安装nessus\n21.1 如何将/var文件系统mount成mfs并支持cron daemon\n21.2 如何将一个512字节的文件写入主引导扇区\nA: All of DOS Programmers 2001-10-16 18:05\n这个问题如果在90年代初MS-DOS盛行的时候出现，是要被人砍死的，如今时过境迁，\n居然能进入这份Unix文档，权当是一种追忆吧。所谓主引导扇区就是硬盘0柱面、0磁\n头、1扇区。启动DEBUG，\n-f 0200 l 0200 0        &lt;-- 从0200h处开始清零，长512字节\n-n mbr                  &lt;-- 假设我们的要处理的文件名为mbr\n-l 0200                 &lt;-- 读到0200h处\n-d 03be 03ff            &lt;-- 检查分区表\nXXXX:03B0                                            00 00                 ..\nXXXX:03C0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................\nXXXX:03D0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................\nXXXX:03E0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................\nXXXX:03F0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 55 AA   ..............U.\n-\n-a 100                  &lt;-- 读主引导扇区的汇编代码\nXXXX:0100 mov ax, 0201  &lt;-- 读取一个扇区，ah=02(功能码)，al=01(扇区总数)\nXXXX:0103 mov bx, 0400  &lt;-- 读取后存放在0400h处，长512字节\nXXXX:0106 mov cx, 0001  &lt;-- ch=00(柱面号，10bit)，cl=01(扇区号，6bit)\nXXXX:0109 mov dx, 0080  &lt;-- dh=00(磁头号)，dl=80h(驱动器号)\nXXXX:010C int 13        &lt;-- int 13h 磁盘I/O BIOS\nXXXX:010E int 3         &lt;-- 单步中断，可以换成int 20h\nXXXX:010F\n-g=100                  &lt;-- 从0100h处开始执行\nAX=0050  BX=0400  CX=0001  DX=0080  SP=FFEE  BP=0000  SI=0000  DI=0000\nDS=XXXX  ES=XXXX  SS=XXXX  CS=XXXX  IP=010E   NV UP EI PL NZ NA PO NC\nXXXX:010E CC            INT     3\n-d 05be 05ff            &lt;-- 检查分区表\nXXXX:05B0                                            80 01                 ..\nXXXX:05C0  01 00 06 FE 3F 7F 3F 00-00 00 41 60 1F 00 00 00   ....?.?...A`....\nXXXX:05D0  01 80 0F FE FF FF 80 60-1F 00 22 3C A0 01 00 00   .......`..\"&lt;....\nXXXX:05E0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................\nXXXX:05F0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 55 AA   ..............U.\n-\n-m 05be l 40 03be       &lt;-- 复制分区表\n-d 03be l 40            &lt;-- 确认分区表复制成功\nXXXX:03B0                                            80 01                 ..\nXXXX:03C0  01 00 06 FE 3F 7F 3F 00-00 00 41 60 1F 00 00 00   ....?.?...A`....\nXXXX:03D0  01 80 0F FE FF FF 80 60-1F 00 22 3C A0 01 00 00   .......`..\"&lt;....\nXXXX:03E0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................\nXXXX:03F0  00 00 00 00 00 00 00 00-00 00 00 00 00 00         ..............\n-a 100                  &lt;-- 写主引导扇区的汇编代码\nXXXX:0100 mov ax, 0301  &lt;-- 写一个扇区，ah=03(功能码)，al=01(扇区总数)\nXXXX:0103 mov bx, 0200  &lt;-- 待写入数据存放在0200h处，长512字节\nXXXX:0106 mov cx, 0001  &lt;-- ch=00(柱面号，10bit)，cl=01(扇区号，6bit)\nXXXX:0109 mov dx, 0080  &lt;-- dh=00(磁头号)，dl=80h(驱动器号)\nXXXX:010C int 13        &lt;-- int 13h 磁盘I/O BIOS\nXXXX:010E int 3         &lt;-- 单步中断，可以换成int 20h\nXXXX:010F\n-g=100                  &lt;-- 从0100h处开始执行\n-q                      &lt;-- 退出DEBUG\n第2个硬盘驱动器号是81h，修改DX寄存器赋值语句即可。\nA: All of Solaris/FreeBSD/Linux Users\ndd if=&lt;path to file&gt; of=/dev/... bs=512 count=1\n^^^^^^^^ 对应要处理的物理硬盘设备\n参看如下例子\n# ls -li /dev/rad0  &lt;-- 注意inode号，这里r应该是raw的含义\n8051 crw-r-----  2 root  operator  116, 0x00010002 /dev/rad0\n# ls -li /dev/ad0\n8051 crw-r-----  2 root  operator  116, 0x00010002 /dev/ad0\n# dd if=/dev/ad0 of=/tmp/mbr bs=512 count=1\n1+0 records in\n1+0 records out\n512 bytes transferred in 0.000363 secs (1410498 bytes/sec)\n# hexdump -C /tmp/mbr\n00000000  fc 31 c0 8e c0 8e d8 8e  d0 bc 00 7c be 1a 7c bf  |.1.........|..|.|\n00000010  1a 06 b9 e6 01 f3 a4 e9  00 8a 31 f6 bb be 07 b1  |..........1.....|\n00000020  04 38 2f 74 08 7f 78 85  f6 75 74 89 de 80 c3 10  |.8/t..x..ut.....|\n00000030  e2 ef 85 f6 75 02 cd 18  80 fa 80 72 0b 8a 36 75  |....u......r..6u|\n00000040  04 80 c6 80 38 f2 72 02  8a 14 89 e7 8a 74 01 8b  |....8.r......t..|\n00000050  4c 02 bb 00 7c 80 fe ff  75 32 83 f9 ff 75 2d 51  |L...|...u2...u-Q|\n00000060  53 bb aa 55 b4 41 cd 13  72 20 81 fb 55 aa 75 1a  |S..U.A..r ..U.u.|\n00000070  f6 c1 01 74 15 5b 66 6a  00 66 ff 74 08 06 53 6a  |...t.[fj.f.t..Sj|\n00000080  01 6a 10 89 e6 b8 00 42  eb 05 5b 59 b8 01 02 cd  |.j.....B..[Y....|\n00000090  13 89 fc 72 0f 81 bf fe  01 55 aa 75 0c ff e3 be  |...r.....U.u....|\n000000a0  bc 06 eb 11 be d4 06 eb  0c be f3 06 eb 07 bb 07  |................|\n000000b0  00 b4 0e cd 10 ac 84 c0  75 f4 eb fe 49 6e 76 61  |........u...Inva|\n000000c0  6c 69 64 20 70 61 72 74  69 74 69 6f 6e 20 74 61  |lid partition ta|\n000000d0  62 6c 65 00 45 72 72 6f  72 20 6c 6f 61 64 69 6e  |ble.Error loadin|\n000000e0  67 20 6f 70 65 72 61 74  69 6e 67 20 73 79 73 74  |g operating syst|\n000000f0  65 6d 00 4d 69 73 73 69  6e 67 20 6f 70 65 72 61  |em.Missing opera|\n00000100  74 69 6e 67 20 73 79 73  74 65 6d 00 00 00 00 00  |ting system.....|\n00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n000001b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 80 01  |................|\n000001c0  01 00 a5 0f ff ff 3f 00  00 00 b1 ff 3f 00 00 00  |......?.....?...|\n000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|\n*\n000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|\n00000200\nD: 硬盘主引导扇区 2002-03-04 14:12\n软盘没有主引导代码、分区表这些概念，我们不做讨论。下面是主引导扇区的图解\n0000h +---------------------------------------------------------+\n|                                                         |\n|                 Master Boot Record                      |\n|                (主引导代码 446字节)                     |\n01BDh |                                                         |\n01BEh +---------------------------------------------------------+\n|                                                         |\n|                 分区表项1(16字节)                       |\n01CDh |                                                         |\n01CEh +---------------------------------------------------------+\n|                                                         |\n|                 分区表项2(16字节)                       |\n01DDh |                                                         |\n01DEh +---------------------------------------------------------+\n|                                                         |\n|                 分区表项3(16字节)                       |\n01EDh |                                                         |\n01EEh +---------------------------------------------------------+\n|                                                         |\n|                 分区表项4(16字节)                       |\n01FDh |                                                         |\n01FEh +---------------------------------------------------------+\n|       0x55  (01FEh)        |         0xAA  (01FFh)      |\n+---------------------------------------------------------+\n这就是硬盘硬盘0柱面、0磁头、1扇区(主引导扇区)的基本结构。下面介绍单个分区\n表项(16字节)\n每个硬盘分区表项长16字节，内容如下\n第1字节 是一个分区的激活标志，0表示非活动分区，80h表示活动分区。\n第2字节 该分区起始磁头号(从0开始)\n8bit的磁头号可以表示256个磁头\n第3字节 bit7-bit6 与第4字节一起使用\nbit5-bit0 该分区起始扇区号(从1开始)\n6bit的扇区号只能表示64个扇区，因为这里从1开始，所以最后只能表示63\n个扇区\n第4字节 bit7-bit0\n第3字节的bit7-bit6作为高两位与第4字节bit7-bit0一起构成10bit的起始\n柱面号，表示该分区起始柱面号(从0开始)\n10bit的柱面号只能表示1024个柱面\n第5字节 该分区系统类型标志，对于FreeBSD是A5h(165)\n第6字节 该分区结束磁头号，与第2字节相对应\n第7字节 bit7-bit6 与第8字节一起使用\nbit5-bit0 该分区结束扇区号\n与第3字节对应\n第8字节 bit7-bit0\n第7字节的bit7-bit6作为高两位与第8字节bit7-bit0一起构成10bit的结束\n柱面号，表示该分区结束柱面号\n与第4字节对应\n第9-12字节(4)\n该分区首扇区的逻辑扇区号(从0开始)\n第13-16字节(4)\n该分区占用的扇区总数\n关察下列分区表中第二项\n--------------------------------------------------------------------------\n00 00 00 00 00 00 00 00 00 00-00 00 00 00 00 00\n80 00 01 02 A5 FE 3F 33 82 7D-00 00 B2 41 0C 00\n00 00 00 00 00 00 00 00 00 00-00 00 00 00 00 00\n00 00 00 00 00 00 00 00 00 00-00 00 00 00 00 00\n55 AA\n--------------------------------------------------------------------------\n80h活动分区，00起始磁头，01起始扇区，02起始柱面，A5h分区类型。FEh结束磁头，\n3Fh结束扇区，33h结束柱面，00007D82h分区首扇区的逻辑扇区号，000C41B2h分区占\n用的扇区总数。\n00007D82h = 32130\n000C41B2h = 803250\nQ: 在MS-DOS下执行fdisk /mbr，究竟做了什么\nA: 只是修改了446字节(01BEh)的主引导代码，并未修改64字节(40h)的分区表。\nD: 袁哥 &lt;yuange@nsfocus.com&gt;\n每个硬盘分区表项长16字节，内容如下\n第1字节 是一个分区的激活标志，0表示非活动分区，80h表示活动分区。\n第2字节 该分区起始磁头号(从零开始)\n第3字节 该分区起始扇区号(从一开始)\n第4字节 该分区起始柱面号(从零开始)\n第5字节 该分区系统类型标志\n第6-8字节(3)\n该分区结束磁头号、分区结束扇区号、分区结束柱面号\n第9-12字节(4)\n该分区首扇区的逻辑扇区号(从零开始)\n第13-16字节(4)\n该分区占用的扇区总数\n关察下列分区表中第二项\n00 00\n00 00 00 00 00 00 00 00-00 00 00 00 00 00 80 00\n01 02 A5 FE 3F 33 82 7D-00 00 B2 41 0C 00 00 00\n00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00-00 00 00 00 00 00 55 AA\n80h活动分区，00起始磁头，01起始扇区，02起始柱面，A5h分区类型。FEh结束磁头，\n3Fh结束扇区，33h结束柱面，00007D82h分区首扇区的逻辑扇区号，000C41B2h分区占\n用的扇区总数\n00007D82h = 32130\n000C41B2h = 803250\nD: IamRichard@bbs.gznet.edu.cn\n对第3、4字节的解释，bit0-bit5为起始扇区号，bit6-bit7为起始柱面号的高两位，\n即第3字节的bit6-bit7作为高两位与第4字节一起构成10bit的起始柱面号。第7、8字\n节亦有相似解释。10bit的柱面号只能表示1024个柱面。\nD: WYHui@bbs.gznet.edu.cn\n0磁道、0柱面、2扇区～0磁道、0柱面、63扇区在缺省情况下均是保留扇区，但可以\n使用，只要保证没有别人使用就行。下面是MBR源代码\n--------------------------------------------------------------------------\nPartLoad  equ  600h\nBootLoc   equ  7c00h\n.MODEL tiny\n.CODE\norg 0\nHead:\nStart:\ncli\nxor ax,ax\nmov ss,ax\nmov sp,7c00h\nmov si,sp\npush ax\npop es\npush ax\npop ds\nsti\ncld\nmov di,PartLoad\nmov cx,100h\nrepne movsw\ndb 0eah\ndw offset Continue+600h,0000h\nContinue:\nmov si,PartLoad+1beh\nmov bl,4\nFindBoot:\ncmp byte ptr[si],80h\nje SaveRec\ncmp byte ptr[si],0\njne Invalid\nadd si,10h\ndec bl\njnz FindBoot\nint 18h\nSaveRec:\nmov dx,[si]\nmov cx,[si+2]\nmov bp,si\nFindNext:\nadd si,10h\ndec bl\njz SetRead\ncmp byte ptr[si],0\nje FindNext\nInvalid:\nmov si,offset ErrMsg1+600h\nPrintStr:\nlodsb\ncmp al,0\nje DeadLock\npush si\nmov bx,7\nmov ah,0eh\nint 10h\npop si\njmp short PrintStr\nDeadLock:\njmp short DeadLock\nSetRead:\nmov di,5\nReadBoot:\nmov bx,BootLoc\nmov ax,201h\npush di\nint 13h\npop di\njnc GoBoot\nxor ax,ax\nint 13h\ndec di\njnz ReadBoot\nmov si,offset ErrMsg2+600h\njmp short PrintStr\nGoBoot:\nmov si,offset ErrMsg3+600h\nmov di,7c00h+1feh\ncmp word ptr[di],0aa55h\njne PrintStr\nmov si,bp\ndb 0eah,00h,7ch,00h,00h\nErrMsg1 db ‘Invalid Partition table‘,0\nErrMsg2 db ‘Error loading operating system‘,0\nErrMsg3 db ‘Missing operating system‘,0\nTail:\nFillNum equ 1beh-(Tail-Head)\ndb Fillnum dup(0)\nPartTable:\ntable1 db ‘                ‘\ntable2 db ‘                ‘\ntable3 db ‘                ‘\ntable4 db ‘                ‘\nMagicID dw 0aa55h\nEnd Start\n--------------------------------------------------------------------------\n21.3 x86/FreeBSD 4.3-RELEASE下FDISK(8)手册页\n21.4 x86/FreeBSD 4.3-RELEASE下HEXDUMP(1)手册页\n21.5 x86/FreeBSD 4.3-RELEASE下DISKLABEL(8)手册页\n21.6 x86/FreeBSD 4.x下不能cp覆盖/kernel\nQ: 重新编译内核后用cp命令无法覆盖/kernel\nA: deepin &lt;deepin@nsfocus.com&gt;\n# ls -lo /kernel\n-rwxr-xr-x  1 root  wheel  schg /kernel*\n^^^^注意这里，类似Linux的chattr那些东西\n# chflags noschg /kernel\n参看CHFLAGS(1)、INSTALL(1)手册页。这样修改后可以cp覆盖/kernel了。最后恢复\nchflags设置\n# chflags schg /kernel\n21.7 x86/FreeBSD下如何设置路由\nA: backend &lt;backend@nsfocus.com&gt; 2001-10-25 11:33\n/etc/defaults/rc.conf或者/etc/rc.conf中会有这样的设置\n--------------------------------------------------------------------------\ndefaultrouter=\"NO\"              # Set to default gateway (or NO).\nstatic_routes=\"\"                # Set to static route list (or leave empty).\n--------------------------------------------------------------------------\n下面分析static_routes的用法，从/etc/rc.network脚本中可以看到这样的处理\n--------------------------------------------------------------------------\n# Configure routing\n#\ncase ${defaultrouter} in\n[Nn][Oo] | ‘‘)\n;;\n*)\nstatic_routes=\"default ${static_routes}\"\nroute_default=\"default ${defaultrouter}\"\n;;\nesac\n# Set up any static routes.  This should be done before router discovery.\n#\nif [ -n \"${static_routes}\" ]; then\nfor i in ${static_routes}; do\neval route_args=\\$route_${i}\nroute add ${route_args}\ndone\nfi\n--------------------------------------------------------------------------\n注意eval命令导致二次变量替换，对上述脚本分析后可知static_routes用法如下\n--------------------------------------------------------------------------\ndefaultrouter=\"&lt;IP&gt;\"\nstatic_routes=\"&lt;name1&gt; &lt;name2&gt; ...\"\nroute_&lt;name1&gt;=\"符合route add命令的语法格式\"\nroute_&lt;name2&gt;=\"符合route add命令的语法格式\"\n... ...\n--------------------------------------------------------------------------\n举例说明\n--------------------------------------------------------------------------\ndefaultrouter=\"192.168.0.1\"\nstatic_routes=\"entry1 entry2\"\nroute_entry1=\"-net 10.10.1.0 -netmask 255.255.255.0 -gateway 192.168.254.1\"\nroute_entry2=\"-net 10.10.2.0 -netmask 255.255.255.0 -gateway 192.168.254.2\"\n--------------------------------------------------------------------------\n当然，你可以不用两个rc.conf文件，而是在/etc/rc.local中直接用route命令增加\n路由。\n21.8 x86/FreeBSD 4.4-RELEASE下DIFF(1)手册页\n21.9 什么是locale\nA: Shen Chuan-Hsing &lt;statue@freebsd.sinica.edu.tw&gt;\n本文来自&lt;&lt;FreeBSD Chinese HOWTO&gt;&gt;，参看如下链接\nhttp://freebsd.sinica.edu.tw/~statue/zh-tut/\nlocale 指定一组C语言处理自然语言(文字)的方式，也可以简单地说，locale反映了\n一组\"地区性语言\"的配置信息\nLC_ALL      代表所有的locale(如下)\nLC_CTYPE    字符定义(包含字符分类与转换规则)\nLC_MESSAGES 信息显示\nLC_TIME     时间格式\nLC_NUMERIC  数字格式\nLC_MONETARY 货币格式\nLC_COLLATE  字母顺序与特殊字符比较顺序\n其中与一般使用者息息相关的是是LC_CTYPE与LC_MESSAGES。LC_CTYPE直接关系到某\n些字符或內码在目前locale下是否可显示？要如何转换编码？对应到哪一个字？等等。\nLC_MESSAGES则关系到软件的信息输出是否符合地域性，例如：我们需要的是中文。\n而一个真正完整支持locale系统，是当使用者在shell prompt下，直接设置好环境变\n量后就马上切换到那种语言了，例如：\n% export LC_CTYPE=zh_TW.Big5\n设置locale的字符定义为台湾地区的Big5繁体中文码定义。有了正确的locale定义后，\n使得任何地区的的文字，只要在加入适当的locale data之后，C Library就能正确地\n处理软件显示信息，而我们使用的[中文]当然也不例外。\n21.10 用cvsup安装vim\n21.11 FreeBSD下显示、输入中文\n21.12 如何在OpenSSH中限制只允许某些用户登录\nA: tt &lt;warning3@nsfocus.com&gt; 2001-11-20 10:56\n编辑/etc/ssh/sshd_config，在最后增加下列语句\nAllowUsers support\n这将只允许\"support\"帐号通过ssh登录系统，如果需要增加其他用户，可以使用空格\n隔开。支持*、?通配符。\n对于root帐号，单独有一个配置选项\nPermitRootLogin yes\n21.13 在FreeBSD 4.3-RELEASE上安装libpcap、libnet\n21.14 如何使自己的BMP图象成为启动logo\n21.15 UDMA ICRC error是什么意思\nQ: 在console上出现错误信息\"UDMA ICRC error writing... ...\"，什么意思\nA: tt &lt;warning3@nsfocus.com&gt;\n通常是使用了40线的IDE硬盘线，然而硬盘被设置成使用DMA模式，这种模式需要80线\n硬盘线。也有可能是您的硬盘不支持DMA方式。解决方法有几种\n1) 换用一根80线的IDE硬盘线(没干过)\n2) 在CMOS BIOS中关闭对UDMA的支持\n3) 在FreeBSD中关闭对UDMA的支持\nvi /etc/sysctl.conf\nhw.atamodes=pio,pio,pio,pio,\n这样做，可能会降低硬盘速率。\n21.16 Limiting closed port RST response什么意思\nQ: console上出现\"Limiting closed port RST response\"，什么意思\nA: tt &lt;warning3@nsfocus.com&gt;\n某些主机快速访问你的主机上一些没有开放的端口，你的主机正在回复RST报文，这\n是正常反应。但FreeBSD内核限制了每秒钟回复RST报文的数量，以防止发生可能的\nDoS攻击。例如，如果攻击者通过伪造源IP来向你的未开端口发送大量连接请求，就\n可能诱使你的主机向该主机发送RST报文。这可能导致受害主机所在网络的带宽占用。\n如果你不想看到上述信息，可以打开黑洞模式来停止响应RST报文。这也可以减缓远\n程攻击者对你的主机的扫描速度。\n# sysctl -w net.inet.tcp.blackhole=2\n# sysctl -w net.inet.udp.blackhole=1\n也可以在/etc/sysctl.conf中增加下列选项使黑洞模式每次启动后都生效\nnet.inet.tcp.blackhole=2\nnet.inet.udp.blackhole=1\n21.17 如何获取FreeBSD Kernel Source Code\nQ: 没有装FreeBSD Kernel Source Code，但现在想在Windows下用Source Insight分\n析内核源码，怎么办\nA: 放入FreeBSD安装光盘，手动mount光驱，做如下操作\n# dmesg | grep -i CDROM\nacd0: CDROM &lt;ATAPI-CD ROM-DRIVE-50MAX&gt; at ata1-slave using PIO4\n# ls -l /dev/acd0*\ncrw-r-----  2 root  operator  117,   0 Nov 15 21:46 /dev/acd0a\ncrw-r-----  2 root  operator  117,   2 Nov 15 21:46 /dev/acd0c\n# mount -t cd9660 -r /dev/acd0a /cdrom\n# cd /tmp\n# cat /cdrom/src/ssys.[ab]? &gt; FreeBSD_44R_ssys.tgz\n# cat /cdrom/src/slib.[ab]? &gt; FreeBSD_44R_slib.tgz\n# cat /cdrom/src/slibexec.[ab]? &gt; FreeBSD_44R_slibexec.tgz\n# cat /cdrom/src/sgnu.[ab]? &gt; FreeBSD_44R_sgnu.tgz\n# cat /cdrom/src/srelease.[ab]? &gt; FreeBSD_44R_srelease.tgz\n# cat /cdrom/src/sbin.[ab]? &gt; FreeBSD_44R_sbin.tgz\n# cat /cdrom/src/ssbin.[ab]? &gt; FreeBSD_44R_ssbin.tgz\n# cat /cdrom/src/subin.[ab]? &gt; FreeBSD_44R_subin.tgz\n# cat /cdrom/src/susbin.[ab]? &gt; FreeBSD_44R_susbin.tgz\n# cat /cdrom/src/sbase.[ab]? &gt; FreeBSD_44R_sbase.tgz\n# cat /cdrom/src/sshare.[ab]? &gt; FreeBSD_44R_sshare.tgz\n# cat /cdrom/src/stools.[ab]? &gt; FreeBSD_44R_stools.tgz\n# cat /cdrom/src/sinclude.[ab]? &gt; FreeBSD_44R_sinclude.tgz\n这些FreeBSD*.tgz可以下载回Windows系统中，winzip打开即可。\n21.18 /boot/defaults/loader.conf中的技巧\nD: 小四 &lt;scz@nsfocus.com&gt; 2002-01-09 13:46\n1) 启动时加载/kernel前的10s暂停如何调整\nautoboot_delay=\"10\"  # Delay in seconds before autobooting\n21.19 FreeBSD中sysctl可控内核参数\nD: 小四 &lt;scz@nsfocus.com&gt; 2002-01-10 10:31\n1) kern.ps_showallprocs\n参看sys/kern/kern_proc.c，该值缺省是1，如果\nsysctl -w kern.ps_showallprocs=0，则只有root用户才能看到所有进程(ps -aux)，\n其它用户不能看到非自己所有的进程。\n2) kern.maxfiles\nkern.maxfilesperproc\n前者是整个系统所能打开的最大文件句柄数，后者是每个进程所能打开的最大文件句\n柄数\n3) kern.maxproc\nkern.maxprocperuid\n前者是系统所允许的最大进程数，后者是每个UID所能拥有的最大进程数\n4) net.inet.icmp.bmcastecho\n0 忽略广播、组播包\n1 响应广播、组播包\n5) net.inet.ip.forwarding\n0 关闭IP转发\n1 打开IP转发\n6) net.inet.tcp.log_in_vain\nnet.inet.udp.log_in_vain\n如果设置为1就会在日志中记录针对本机的端口扫描。\n7) kern.ps_argsopen (FreeBSD 4.7-STABLE)\n0 在ps的输出中不显示argv[]数组\n1 在ps的输出中显示argv[]数组\n21.20 x86/FreeBSD 4.3-RELEASE下GETIFADDRS(3)手册页\n21.21 FreeBSD下如何访问显存\nQ:\n我在开发一个FreeBSD上的内核模块，需要读写VGA文本模式屏幕缓冲区，也就是物理\n地址0xB8000。如果在MS-DOS下，当然可以直接访问这个地址，但现在我在FreeBSD内\n核中，必须使用内核虚拟地址，我的问题是如何\"正确地\"转换物理地址到内核虚拟地\n址。目前我用了如下技巧，0xC0000000 + 0xB8000，但这是不规范的。\nA: \"M. Warner Losh\" &lt;imp@village.org&gt;\n1) bus_alloc_resource()\n2) bus_space_{read,write}_*\nD: 小四 &lt;scz@nsfocus.com&gt;\n应该也可以用mmap()通过/dev/mem映射0xB8000吧，参看\"直接访问内存[显存]地址\"\n21.22 FreeBSD下如何为指定用户设定chroot的FTP环境\nA: backend &lt;backend@nsfocus.com&gt; 2002-03-19 11:13\n将该用户帐号添加到/etc/ftpchroot文件中，则该帐号FTP登录后被限制在其登录目\n录下。如果希望限制用户组，则在组名前添加@字符并写入/etc/ftpchroot文件中。\n修改后立即生效，不需要重启inetd进程。\n# cat /etc/ftpchroot\nbadguy\n@badgroup\n#\n21.23 如何利用FKLD动态增加一个新协议\nQ: Marco Molteni &lt;molter@tin.it&gt;\n在netinet/in_proto.c中有一个结构struct ipprotosw inetsw[]，包含了各种IP协\n议的入口。如果想增加一个新协议，就必须在这个结构数组中增加入口。我想知道能\n否利用FKLD方式增加一个新协议\nA: Brooks Davis &lt;brooks@one-eyed-alien.net&gt;\n看看sys/net/if_gif.c，这里增加了一个新的IP协议，而且是可加载的。\n21.24 修改/etc/mail/sendmail.cf关闭ident功能\nQ: FreeBSD系统，本地/远程使用sendmail发信时缓慢，但TCP连接建立正常，为何\nA: backend &lt;backend@nsfocus.com&gt;\n用telnet连接25端口，发现在TCP连接建立后，第一条提示信息需要等待几秒才能出\n现。利用netstat命令查看后发现sendmail进程在此之前连接客户端的113端口(即\nident)，基本确定是这个查询客户端用户的操作产生延迟。修改\n/etc/mail/sendmail.cf配置文件，关闭ident(RFC 1413)功能。\n#O Timeout.ident=5s\nO Timeout.ident=0s\n21.25 FreeBSD下如何获取系统负载\nA: Anthony Schneider &lt;aschneid@mail.slc.edu&gt;\n可以用getloadavg(3)或者kvm_getloadavg(3)。进程信息可用kvm_getprocs(3)获取。\n21.26 *BSD下如何屏敝远程登录时Copyright显示\nA: 在自己主目录下生成一个文件.hushlogin\necho \"ALLOWHUSH=NO\" &gt; .hushlogin\n此外还有/etc/motd、/etc/issue\n21.27 cvsup安装BASH\n21.28 配置core dump\nQ: 我在日志中看到\npid 36861 (ftpd), uid 29987: exited on signal 11\n这是x86/FreeBSD 4.5-RELEASE-p3自带的ftpd。我使用-g参数重新编译了ftpd以\n便调试\nmkdir /var/coredump\nchmod 1777 /var/coredump\nsysctl kern.corefile=/var/coredump/%U.%N.%P.core (缺省为%N.core)\n在/etc/login.conf中指定了\ncoredumpsize=unlimited\n但是当ftpd崩溃时，依旧没有core dump，我不想等到4.6-RELEASE才解决这个问\n题。\nA: Mikko Tyolajarvi &lt;mikko@dynas.se&gt;\n试试 sysctl kern.sugid_coredump=1 (缺省为0)\n如果ftpd崩溃发生在用户登录完成之后，UID != EUID，必须做如上指定。遗憾的是，\n这个设置并未解决前面的问题，不知还有什么地方限制了core dump产生？\nD: Garrett Wollman &lt;wollman@lcs.mit.edu&gt;\n设计FTP协议之初没有考虑到\"特权端口\"的问题，而在(服务器)主动模式下数据流绑\n定源端口20/TCP，这需要root权限。如果ftpd不是以root身份启动，就无法完成这种\n绑定。但又非始终需要root权限，所以有可能调用seteuid()、setreuid()临时放弃\n特权。\n某些ftpd的实现考虑到特权端口的问题，允许指定(服务器)主动模式下数据流是否绑\n定20/TCP(违背RFC 959的要求)，此时ftpd不必保持root权限。\n至于控制流的21/TCP，多是来自inetd、xinetd，一旦TCP连接建立，就不需要root权\n限了。\n21.29 在OpenBSD 3.0上安装Gcc\n21.30 在NetBSD 1.5.2上安装BASH\n21.31 找不到何处启动了snmpd\n21.32 FreeBSD远程root访问\nA: 编辑/etc/ttys\n# Pseudo terminals\nttyp0   none                    network off secure\nttyp1   none                    network off secure\nttyp2   none                    network off secure\nttyp3   none                    network off secure\n22. Linux Kernel Programming\n22.1 直接访问内存[显存]地址\nQ: 现在在修改linux内核，希望能访问一段地址(其实是显存)。但发觉不能直接访问\nA: Kongming &lt;ymwei@263.net&gt; (Luther &lt;Luther@pku.edu&gt; 整理)\n通过/dev/mem设备文件和mmap系统调用，可以将线性地址描述的物理内存映射到进程\n的地址空间，然后就可以直接访问这段内存了。\n比如，标准VGA 16色模式的实模式地址是A000:0000，而线性地址则是A0000。设定显\n存大小为0x10000，则可以如下操作\nmem_fd  = open( \"/dev/mem\", O_RDWR );\nvga_mem = mmap( 0, 0x10000, PROT_READ | PROT_WRITE, MAP_SHARED,\nmem_fd, 0xA0000 );\nclose( mem_fd );\n然后直接对vga_mem进行访问，就可以了。当然，如果是操作VGA显卡，还要获得I/O\n端口的访问权限，以便进行直接的I/O操作，用来设置模式/调色板/选择位面等等\n在工控领域中还有一种常用的方法，用来在内核和应用程序之间高效传递数据:\n1) 假定系统有64M物理内存，则可以通过lilo通知内核只使用63M，而保留1M物理内\n存作为数据交换使用(使用 mem=63M 标记)。\n2) 然后打开/dev/mem设备，并将63M开始的1M地址空间映射到进程的地址空间。\n22.2 /proc可控内核参数\n1) /proc/sys/net/ipv4/ip_forward\n0 关闭IP转发\n1 启动IP转发\n# echo 1 &gt; /proc/sys/net/ipv4/ip_forward\n2) /proc/sys/net/ipv4/icmp_echo_ignore_all\n/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts\n0 响应\n1 忽略\n23. Linux相关问题\n23.0 以POST方式提交URL请求\nA: san &lt;san@nsfocus.com&gt;\n$ echo \"uid=username&amp;password=secret\" | lynx -post_data http://www.url.com\nA: tombkeeper &lt;tombkeeper@nsfocus.com&gt;\ncurl -v http://cygnus.tele.pw.edu.pl/cgi-bin/environ.pl -d xxx\n23.1 RedHat 7.2远程root访问\nQ: 缺省安装RedHat Linux 7.2后我想远程telnet、ftp访问之，以root身份\nA: 2002-03-03 17:37\n尽管从安全角度不建议如此做，但的确是可以实现的\n1) vi /etc/securetty，增加类似行\npts/0\npts/1\npts/2\n... ...\n此后root可以远程telnet登录\n2) vi /etc/ftpusers，注释或删除root帐号\n3) vi /etc/ftpaccess，修改得到\nallow-uid root\nallow-gid root\n此后root可以远程ftp登录\nD: hhuu@smth 2003-06-10\n如果从127.0.0.1以外的地址telnet访问，TCP连接被立刻切断的话，需要修改\n/etc/hosts.allow文件。\"cat /var/log/security\"可以看到这样做的原因。\nRedHat Linux 7.2缺省安装结束后，/etc/hosts.allow文件没有额外设置过。\n23.2 TELNET/FTP连接耗时过长\nQ: Redhat Linux 7.2 wu-ftpd，在LAN内时FTP连接正常，托管到电信(不在同一LAN)\n后，FTP连接耗时过长，大约30s。\nA: 木犀\n有两种可能\n1) 反向域名解析耗时，此时可在/etc/hosts增加相应client ip条目\n2) RFC 931认证查询(113/TCP)\nwu-ftpd支持RFC 931认证查询，大约10s才放弃。如果client位于NAT、Firewall\n之后，server无法主动向client的113/TCP建立TCP连接，就必然等待10s超时。解\n决办法有两种\na. 允许server主动向client的113/TCP建立TCP连接，此时不要求client上identd\n真实存在，server发现client回送RST包便不再等待。\nb. vi /etc/xinetd.d/wu-ftp\n删除如下两行并重启xinetd\nlog_on_success += DURATION USERID\nlog_on_failure += USERID\nD: flowbusily@bbs.apue.net 2002-10-10\n我使用proftpd来做FTP Server，文中提到的反向域名解析与113/TCP认证在proftpd\n里用如下两个选项来解决:\nUseReverseDNS  off\nIdentLookups   off\nD: hek@smth 2003-04-08\n配置服务器不要试图连接客户端的113/TCP\n/etc/xinetd.d/telnet\nlog_on_failure += USERID\n修改如下\nlog_on_failure += HOST\n/etc/xinetd.d/wu-ftpd\nlog_on_success += DURATION USERID\nlog_on_failure += USERID\n修改如下\nlog_on_success += DURATION HOST\nlog_on_failure += HOST\n23.3 Debian/Linux中如何修改本机IP\nA: 修改/etc/network/interfaces、/etc/hosts文件\n--------------------------------------------------------------------------\n# /etc/network/interfaces -- configuration file for ifup(8), ifdown(8)\n# The loopback interface\nauto lo\niface lo inet loopback\n# The first network card - this entry was created during the Debian\n# installation (network, broadcast and gateway are optional)\nauto eth0\niface eth0 inet static\naddress 192.168.7.148\nnetmask 255.255.255.0\nnetwork 192.168.7.0\nbroadcast 192.168.7.255\ngateway 192.168.7.254\n--------------------------------------------------------------------------\n23.4 如何确认是何种Unix Release\nQ: \"uname -a\"看不出来是RedHat，如何确认是RedHat\nA: $ cat /etc/redhat-release\nRed Hat Linux release 7.2 (Enigma)\nD: melonm@smth 2003-06-08\n类似的操作有:\ncat /etc/release (for solaris)\ncat /etc/issue (for some others)\ncat /etc/slackware-version (for slackware)\n如果\"uname -a\"可以看出是何种Unix，就不必这样操作，所以Solaris用不着这样。\n23.5 vi/insert状态下copy/paste时不回车、只换行\nQ: 远程telnet/ssh登录，在vi/insert状态下copy/paste时不回车、只换行，结果显\n示逞向屏幕右下角的阶梯状。多次在Linux中遇上该问题，如何解决。\nA: 编辑~/.vimrc文件，放入如下两行内容:\nset noautoindent\nset nocindent\n如果只是临时改动，可在vi的命令状态输入上述两条命令。还有一种可能，就是\n汉学处理带来的问题，此时可修改环境变量:\nls -la /usr/lib/locale\nexport LANG=zh_CN.gbk\n23.6 如何产生core dump\nQ: 环境: Linux/pthread/g++\n我的程序存在一个很难重现的BUG，它导致Segment fault，但未core dump。当我\n用GDB调试该程序时，这个BUG\"消失\"了。我该如何定位BUG。\nD: csmith@micromuse.com\n试试pthread_kill_other_threads_np()，使之成为信号句柄:\n--------------------------------------------------------------------------\nstruct sigaction sa = { 0 };\n/*\n* Set the handler for SEGV, BUS, ILL and ABRT to the Linux thread\n* function below, to kill the threads so we can produce a core dump.\n* It should be safe using pthread_kill_other_threads_np directly,\n* as it takes no arguments (will ignore the signo) and returns void\n* also.\n*/\nsa.sa_handler = pthread_kill_other_threads_np;\nsa.sa_flags   = SA_RESETHAND | SA_RESTART;\nsigaction( SIGSEGV, &amp;sa, NULL );\nsigaction( SIGBUS,  &amp;sa, NULL );\nsigaction( SIGILL,  &amp;sa, NULL );\nsigaction( SIGABRT, &amp;sa, NULL );\n--------------------------------------------------------------------------\n我们用这种办法在Linux上调试多线程程序。可能会丢失其它线程的信息，但聊胜于\n无。\n23.7 Socket( PF_PACKET, SOCK_RAW, htons( ETH_P_ARP ) )报错\nQ: Socket( PF_PACKET, SOCK_RAW, htons( ETH_P_ARP ) )报错\nsocket() failed: Address family not supported by protocol\nA: 重新配置、编译内核\nCONFIG_PACKET=y\n这是缺省设置。如果未使能该选项，就会得到上述错误信息。\n24. Unix编程相关问题\n24.0 如何知道fd是有效文件句柄\nQ: 如果一个函数需要一个有效文件句柄(可以是pipe、fd、socket等等)做为形参，\n有无办法判断其有效性。\nA: Joe Halpin &lt;jhalpin@nortelnetworks.com_.nospam&gt;\n我觉得最好是用fstat()函数进行判断，当fd不是一个有效文件句柄时，该函数返\n回-1，并设置errno为EBADF。\nA: Andrew Gierth &lt;andrew@erlenstar.demon.co.uk&gt;\nfcntl( fd, F_GETFD, 0 );\n可能这是最快的办法，也最具有可移植性。在那些支持procfs的系统中，也可以\n检查/proc/&lt;pid&gt;/fd/目录下的伪文件，比如SPARC/Solaris 8和x86/Linux\nKernel 2.4.7-10。而x86/FreeBSD 4.5-RELEASE中没有/proc/&lt;pid&gt;/fd/目录。显\n然这种技术可移植性差了很多。\n24.1 如何使代码段可写\nQ: 如下演示程序试图对代码段进行写操作，缺省情况下必然失败，有何建议。\n--------------------------------------------------------------------------\n/*\n* -----------------------------------------------------------------------\n* Compile : For x86/Linux RedHat/7.2 2.4.7-10(gcc 2.96/gas 2.11.90.0.8)\n*         : gcc -static -Wall -pipe -g -o src src.c\n* -----------------------------------------------------------------------\n*/\n#include &lt;stdio.h&gt;\nint main ( int argc, char * argv[] )\n{\nunsigned int *p;\np  = ( unsigned int * )&amp;main;\nprintf( \"[0x%08X] -&gt; 0x%08X\\n\", ( unsigned int )p, *p );\n*p = 0x4F46534E;\nprintf( \"[0x%08X] -&gt; 0x%08X\\n\", ( unsigned int )p, *p );\nreturn( 0 );\n}  /* end of main */\n--------------------------------------------------------------------------\n$ ./src\n[0x080481E0] -&gt; 0x83E58955\nSegmentation fault (core dumped)\n$\nA: scz &lt;scz@nsfocus.com&gt;\n无论是哪种Unix系统，总可以利用mprotect()设置PC附近的内存权限为rwx:\n--------------------------------------------------------------------------\n/*\n* -----------------------------------------------------------------------\n* Compile : For x86/Linux RedHat/7.2 2.4.7-10(gcc 2.96/gas 2.11.90.0.8)\n*         : gcc -static -Wall -pipe -g -o src_other src_other.c\n* -----------------------------------------------------------------------\n*/\n#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\nint main ( int argc, char * argv[] )\n{\nunsigned int *p = ( unsigned int * )( ( unsigned int )&amp;main &amp; 0xffffc000 );\nif ( mprotect( p, 0x4000, 7 ) &lt; 0 )\n{\nperror( \"mprotect error\" );\nreturn( -1 );\n}\np  = ( unsigned int * )&amp;main;\nprintf( \"[0x%08X] -&gt; 0x%08X\\n\", ( unsigned int )p, *p );\n*p = 0x4F46534E;\nprintf( \"[0x%08X] -&gt; 0x%08X\\n\", ( unsigned int )p, *p );\nreturn( 0 );\n}  /* end of main */\n--------------------------------------------------------------------------\n$ ./src_other\n[0x080481E0] -&gt; 0x83E58955\n[0x080481E0] -&gt; 0x4F46534E\n修改静态文件中代码段的p_flags，从(PF_R | PF_X)改为(PF_R | PF_W | PF_X)，这\n样的ELF文件加载后，代码段缺省可写。下面是一个简单的跨平台可移植演示程序:\n--------------------------------------------------------------------------\n/*\n* -----------------------------------------------------------------------\n* Compile : For x86/Linux RedHat_8 2.4.18-14\n*         : For x86/FreeBSD 4.5-RELEASE\n*         : For SPARC/Solaris 8\n*         : gcc -Wall -pipe -O3 -o codew codew.c\n* -----------------------------------------------------------------------\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#define PT_LOAD 1         /* Loadable program segment */\n#define PF_X    (1 &lt;&lt; 0)  /* Segment is executable    */\n#define PF_W    (1 &lt;&lt; 1)  /* Segment is writable      */\n#define PF_R    (1 &lt;&lt; 2)  /* Segment is readable      */\n/*\n* The ELF file header. This appears at the start of every ELF file.\n*/\nstruct ELF32EH\n{\nunsigned char      e_ident[16];  /* Magic number and other info       */\nunsigned short int e_type;       /* Object file type                  */\nunsigned short int e_machine;    /* Architecture                      */\nunsigned int       e_version;    /* Object file version               */\nunsigned int       e_entry;      /* Entry point virtual address       */\nunsigned int       e_phoff;      /* Program header table file offset  */\nunsigned int       e_shoff;      /* Section header table file offset  */\nunsigned int       e_flags;      /* Processor-specific flags          */\nunsigned short int e_ehsize;     /* ELF header size in bytes          */\nunsigned short int e_phentsize;  /* Program header table entry size   */\nunsigned short int e_phnum;      /* Program header table entry count  */\nunsigned short int e_shentsize;  /* Section header table entry size   */\nunsigned short int e_shnum;      /* Section header table entry count  */\nunsigned short int e_shstrndx;   /* Section header string table index */\n} __attribute__ ((packed));\nstruct ELF32PH\n{\nunsigned int p_type;    /* Segment type             */\nunsigned int p_offset;  /* Segment file offset      */\nunsigned int p_vaddr;   /* Segment virtual address  */\nunsigned int p_paddr;   /* Segment physical address */\nunsigned int p_filesz;  /* Segment size in file     */\nunsigned int p_memsz;   /* Segment size in memory   */\nunsigned int p_flags;   /* Segment flags            */\nunsigned int p_align;   /* Segment alignment        */\n} __attribute__ ((packed));\nint main ( int argc, char * argv[] )\n{\nstruct ELF32EH     eh;\nstruct ELF32PH     ph;\nunsigned short int e_phnum;\nint                fd = -1;\nif ( argc != 2 )\n{\nfprintf( stderr, \"Usage: %s &lt;32-bit ELF file&gt;\\n\", argv[0] );\nreturn( EXIT_FAILURE );\n}\nif ( ( fd = open( argv[1], O_RDWR ) ) &lt; 0 )\n{\nperror( \"open error\" );\nreturn( EXIT_FAILURE );\n}\nif ( read( fd, &amp;eh, sizeof( eh ) ) != sizeof( eh ) )\n{\nprintf( \"read eh error\\n\" );\ngoto main_0;\n}\nfor ( e_phnum = 0; e_phnum &lt; eh.e_phnum; e_phnum++ )\n{\nif ( lseek( fd, eh.e_phoff + e_phnum * sizeof( ph ), SEEK_SET ) &lt; 0 )\n{\nperror( \"lseek error\" );\ngoto main_0;\n}\nif ( read( fd, &amp;ph, sizeof( ph ) ) != sizeof( ph ) )\n{\nprintf( \"read ph error\\n\" );\ngoto main_0;\n}\nif ( ( ph.p_type == PT_LOAD ) &amp;&amp; ( ( ph.p_flags &amp; ( PF_R | PF_X ) ) == ( PF_R | PF_X ) ) )\n{\nprintf( \"old ph.p_flags = 0x%08x\\n\", ph.p_flags );\nph.p_flags |= PF_W;\nprintf( \"new ph.p_flags = 0x%08x\\n\", ph.p_flags );\nlseek( fd, eh.e_phoff + e_phnum * sizeof( ph ), SEEK_SET );\nif ( write( fd, &amp;ph, sizeof( ph ) ) != sizeof( ph ) )\n{\nprintf( \"write ph error\\n\" );\ngoto main_0;\n}\nbreak;\n}\n}  /* end of for */\nmain_0:\nclose( fd );\nfd = -1;\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\n下面在SPARC/Solaris 8上测试效果:\n$ ./src\n[0x0001080C] -&gt; 0x9DE3BF88\n段错误 (core dumped)\n$ elfdump -p src\n程序头[2]:\np_vaddr:      0x10000         p_flags:    [ PF_X  PF_R ]\np_paddr:      0               p_type:     [ PT_LOAD ]\np_filesz:     0x934           p_memsz:    0x934\np_offset:     0               p_align:    0x10000\n$ ./codew src\nold ph.p_flags = 0x00000005\nnew ph.p_flags = 0x00000007\n$ elfdump -p src\n程序头[2]:\np_vaddr:      0x10000         p_flags:    [ PF_X  PF_W  PF_R ]\np_paddr:      0               p_type:     [ PT_LOAD ]\np_filesz:     0x934           p_memsz:    0x934\np_offset:     0               p_align:    0x10000\n$  ./src\n[0x0001080C] -&gt; 0x9DE3BF88\n[0x0001080C] -&gt; 0x4F46534E\n对于Linux、FreeBSD有readelf工具可用:\n$ readelf -l src\nProgram Headers:\nType           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\nLOAD           0x000000 0x08048000 0x08048000 0x00533 0x00533 R E 0x1000\n$ ./codew src\nold ph.p_flags = 0x00000005\nnew ph.p_flags = 0x00000007\n$ readelf -l src\nProgram Headers:\nType           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\nLOAD           0x000000 0x08048000 0x08048000 0x00533 0x00533 RWE 0x1000\n$\n用\"objdump -x src | more\"也能看到这些信息。\n\"law@bbs.apue.net\"曾经建议过这样的命令:\n$ ./src\n[0x08048494] -&gt; 0x83E58955\nBus error (core dumped)\n$ objdump -h src\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n8 .text         00000190  08048388  08048388  00000388  2**2\nCONTENTS, ALLOC, LOAD, READONLY, CODE\n$ objcopy --set-section-flags .text=CONTENTS,ALLOC,LOAD,CODE src dst\n$ objdump -h dst\nIdx Name          Size      VMA       LMA       File off  Algn\n8 .text         00000190  08048388  08048388  00000388  2**2\nCONTENTS, ALLOC, LOAD, CODE\n$ ./dst\n[0x08048494] -&gt; 0x83E58955\nBus error (core dumped)\n$\n这条objcopy命令修改了.text的sh_flags，而不是全局的p_flags，去掉READONLY也\n未能使得代码段缺省可写。\n\"watercloud@nsfocus.com\"建议过另一种邪门办法，下面在SPARC/Solaris 8上演示:\n$ gcc -Wall -S -o src.s src.c\n编辑src.s文件，将main()所在的节名由.text改成.data，继续编译:\n$ gcc -static -Wall -pipe -g -o src src.s\n$ ./src\n[0x0004E770] -&gt; 0x9DE3BF88\n[0x0004E770] -&gt; 0x4F46534E\n$ elfdump -p src\n程序头[0]:\np_vaddr:      0x10078         p_flags:    [ PF_X  PF_R ]\np_paddr:      0               p_type:     [ PT_LOAD ]\np_filesz:     0x2e67e         p_memsz:    0x2e67e\np_offset:     0x78            p_align:    0x10000\n程序头[1]:\np_vaddr:      0x4e6f8         p_flags:    [ PF_X  PF_W  PF_R ]\np_paddr:      0               p_type:     [ PT_LOAD ]\np_filesz:     0x1a31          p_memsz:    0x2640\np_offset:     0x2e6f8         p_align:    0x10000\n$\n24.2 建议性文件锁与强制性文件锁\nD: 某些Unix系统(SVR4)支持强制性文件锁。假设一个文件被设置过强制性文件锁，\n此时操作系统内核将阻止其它进程对该文件进行creat、open、read、write操作，\nerrno设置成EAGAIN。因此强制性文件锁比较危险，如果对某个比较重要的系统文\n件设置过强制性文件锁又忘记释放，有可能导致系统崩溃。设置强制性文件锁的\n方式比较特别:\nchmod g+s &lt;filename&gt;\nchmod g-x &lt;filename&gt;\n这是形象的表示，实际编程中应该通过chmod()函数一步完成。不能对目录、可执\n行文件设置强制性锁。\n24.3 如何编写daemon程序\nQ: 在FreeBSD下用\"ps auxw\"查看进程列表时，注意到某些进程没有控制终端，也就\n是说TT列显示??。知道这是所谓的daemon进程，如果我想自己编写这样的程序，\n该如何做。\nA: Andrew Gierth &lt;andrew@erlenstar.demon.co.uk&gt;\n这个回答来自著名的&lt;&lt;Unix Programming FAQ ver 1.37&gt;&gt;，由Andrew Gierth负责维\n护，其它细节请参看原文1.7小节。\n通常将一个不与任何终端相关联的后台进程定义为daemon进程。下面是通常所需的七\n个步骤:\na. fork()之后父进程退出。子进程确保不是process group leader，这是成功调用\nsetsid()所要求的。\nb. setsid()，创建新的session和process group，成为其leader，并脱离控制终端。\nc. 再次fork()之后父进程退出，子进程确保不是session leader，将永远不会重获\n控制终端。这是SVR4的特性所致。\nd. chdir( \"/\" )，减少管理员卸载(unmount)文件系统时可能遇上的麻烦。这一步可\n选，也可chdir()到其它目录。\ne. umask( 0 )，使当前进程对自己所写文件拥有完全控制权，避免继承的umask()设\n置带来困挠。这一步可选。\nf. 关闭0、1、2三个句柄。许多daemon程序用sysconf()获取_SC_OPEN_MAX，并在一\n个偱环中关闭所有可能打开的文件句柄。目的在于释放不必要的系统资源，它们\n是有限资源。\ng. 出于安全以及健壮性考虑，即使当前进程不使用stdin、stdout、stderr，也应重\n新打开0、1、2三个句柄，使之对应/dev/null。当然，你也可以根据需要使之对\n应不同的(伪)文件。总之，保持0、1、2三个句柄呈打开状态，并使之指向无害文\n件。\nD: scz &lt;scz@nsfocus.com&gt;\n以FreeBSD 4.5-RELEASE为例进行讨论。\n注意，存在与终端相关联的后台进程，比如在支持作业控制的bash上以&amp;符结尾启动\n的进程。当用\"ps auxw\"查看时，这种后台进程的TT列不为??。用\"ps -p pid -jfl\"\n查看这种后台进程，可以看到其PGID与父进程的PGID不同，属于另外一个进程组。支\n持作业控制的现代shell对&amp;符的解释一般都是fork/setpgid。前台进程组、后台进程\n组是终端的属性，不是进程本身的属性，没有控制终端的进程无所谓前台、后台，一\n定要算就都算是后台进程。\n非作业控制型的shell对&amp;符的解释一般只是fork，而没有setpgid，这样启动的进程\n与shell属于同一进程组。后面的讨论都假设使用支持作业控制的现代shell。\n当在控制终端上按下Ctrl-C，终端驱动程序产生SIGINT信号(可用stty设置)并分发至\n前台进程组的所有进程。\nAPUE 10.2中提到，当session leader终止时，系统会向该session前台进程组中所有\n进程分发SIGHUP信号。我的疑问是，如果某session没有控制终端，也就没有所谓前\n台进程组，当session leader终止时，系统会向该session中所有进程分发SIGHUP信\n号吗。UNP 12.4的例子正是这种情形，可是Stevens没有在其它地方进一步阐述，也\n永远不可能得到他本人的解释了。\nAPUE 13.3所给的daemon_init()与UNP 12.4所给不同，没有做二次fork()。因为二次\nfork()只是SVR4的要求。从最广泛兼容角度出发，如果daemon进程企图打开一个(伪)\n终端设备，无论是否二次fork()过，open()时都应该指定O_NOCTTY。由于daemon程序\n是自己完全可控的，将来是否会打开终端是已知的，如果确认将来不会打开终端，就\n完全不必考虑重获控制终端的问题，换句话说，二次fork()很大程度上是不必要的。\n关于Andrew Gierth所提第七步骤，1987年Henry Spencer在setuid(7)手册页中做了\n相关建议，1991年，在comp news上有人重贴了这份文档。1992年Richard Stevens建\n议daemon进程应该关闭所有不必要的文件句柄，并将stdin、stdout、stderr指向\n/dev/null。参看&lt;&lt;x86/FreeBSD 4.5-RELEASE IO Smash及S/Key机制分析&gt;&gt;。第七步\n骤严格意义上来说，不是可选的，而是必须的。\n参看&lt;&lt;19.0 如何将stdin、stdout、stderr重定向到/dev/null&gt;&gt;。\nA: W. Richard Stevens\n一般我会使用类似daemon_init()这样的函数，使当前进程成为daemon进程。\n--------------------------------------------------------------------------\nstatic void daemon_init ( const char *workdir, mode_t mask )\n{\nint i, j;\n/*\n* change working directory, this step is optional\n*/\nchdir( \"/tmp\" );\nif ( 0 != Fork() )\n{\n/*\n* parent terminates\n*/\nexit( EXIT_SUCCESS );\n}\n/*\n* first child continues\n*\n* become session leader\n*/\nsetsid();\nSignal( SIGHUP, SIG_IGN );\nif ( 0 != Fork() )\n{\n/*\n* first child terminates\n*/\nexit( EXIT_SUCCESS );\n}\n/*\n* second child continues\n*\n* change working directory, chdir( \"/\" )\n*/\nchdir( workdir );\n/*\n* clear our file mode creation mask, umask( 0 )\n*/\numask( mask );\nj = Open( \"/dev/null\", O_RDWR );\nDup2( j, 0 );\nDup2( j, 1 );\nDup2( j, 2 );\nj = getdtablesize();\nfor ( i = 3; i &lt; j; i++ )\n{\nclose( i );\n}\nreturn;\n}  /* end of daemon_init */\n--------------------------------------------------------------------------\n调用setsid()，如果成功，导致三个结果:\na. 创建一个新的session，当前进程成为session leader，也是新session中的惟一\n进程。\nb. 当前进程成为一个新进程组的组长(process group leader)。\nc. 如果当前进程以前有一个控制终端，现在将脱离这个控制终端。\n对于SVR4，一个session leader调用open()打开一个(伪)终端设备，如果这个终端不\n是其它会话的控制终端，而open()时又未指定O_NOCTTY，则这个终端成为当前会话的\n控制终端。第二次fork()后，孙子进程将确保不是session leader。于是以后不会再\n有任何控制终端，彻底脱离。\n必须在第二次fork()之前显式忽略SIGHUP信号。孙子进程将继承子进程所设置的信号\n句柄。Stevens是这样解释的，当session leader终止时，系统会向该session中所有\n进程分发SIGHUP信号。即这里的子进程终止时，系统会向孙子进程分发SIGHHUP信号。\n前面有关于这个问题的讨论。\ngetdtablesize()返回的也就是sysconf( _SC_OPEN_MAX )返回的值。\nD: scz &lt;scz@nsfocus.com&gt;\n以FreeBSD 4.5-RELEASE为例进行讨论。\n做为Guru of the Unix gurus，Andrew Gierth与Richard Stevens在各类文档或书籍\n中对\"进程\"进行了相当广泛、深入的解释，其中可能引发困惑的一个问题是，父子进\n程关系与信号分发的关系。\n有相当多的人认为父进程终止时，子进程应该收到一个SIGHUP信号。即使熟练的Unix\n程序员参与某些讨论时，也可能忘记几分钟前TA还在fork()，并立即让父进程退出的\n事实。一般来说，有两种典型的与SIGHUP信号相关的情形。\n假设某session有控制终端，当session leader终止时，系统会向该session前台进程\n组中所有进程分发SIGHUP信号。\n如果某进程组中有一个进程，其父进程属于同一会话(session)的另一个进程组，则\n该进程组不是\"孤儿进程组\"，反之该进程组称为\"孤儿进程组\"。\nAPUE 9.10指出，当某进程的终止导致一个新的\"孤儿进程组\"产生，系统会向这个新\n的\"孤儿进程组\"中处于\"停止\"状态的每个进程分发SIGHUP信号，然后分发SIGCONT信\n号。那些未处于\"停止\"状态的进程不会收到这两个信号。\n启动\"tcpdump -i lnc0 udp &amp;\"，此时tcpdump成为后台进程组成员。退出当前shell，\n此时tcpdump成为孤儿进程组成员，但它处于\"运行\"状态。重新登录后会发现该进程\n仍然存在，它不是daemon进程，TT列不为??。它没有收到SIGHUP信号，手动kill -1\n是可以杀掉它的。\n启动\"nohup tcpdump -i lnc0 udp\"，此时tcpdump仍为前台进程组成员。从另一shell\n执行\"kill -1\"杀掉前一shell，此时tcpdump成为孤儿进程组成员。有SIGHUP信号分\n发到tcpdump，因为session leader终止了。nohup确保tcpdump继续运行。对比没有\n使用nohup时的情形。\n有一个bindshell，它只是简单fork()了一次，父进程立即退出。并未处理SIGHUP信\n号，也未调用setsid()。它已经达到目的了。fork()之后产生一个后台孤儿进程组，\n并未脱离控制终端，但再也不会有SIGHUP信号分发到bindshell。前述两种情形都不\n会出现。在控制终端上按Ctrl-C产生的SIGINT信号不会分发到后台进程组。一般入侵\n中要的就是这个效果，并不需要复杂的daemon_init()。\n还有一种情形，简单fork()一次，父进程调用setpgid()使子进程自己成为进程组长，\n然后父进程退出。这只是确保产生后台孤儿进程组，setpgid()不是必须的。子进程\n仍然过继给init进程。\n两位先生给出的daemon化步骤考虑得相当周全。但更多的入侵者、临时跳板工具并不\n需要daemon化，最省事的办法就是fork()一次。最后再强调一次，脱离控制终端、彻\n底脱离控制终端与不受SIGHUP信号影响是两回事，绝大多数时候要的只是后者的效果。\n此外，Linux可能在某些细节上与上述讨论有出入，但最后的结论一样，最省事的办\n法就是fork()一次。\n个人推荐严肃的Unix/C程序员在需要这类效果时，统一使用daemon_init()，并捕捉\n相关信号。\nD: lskuangren@bbs.apue.net 2003-07-11\nFreeBSD和Linux直接提供了一个函数，DAEMON(3)\n--------------------------------------------------------------------------\nDAEMON(3)          FreeBSD库函数手册                             DAEMON(3)\n名字\ndaemon - 在后台运行程序\n库\n标准C库(libc, -lc)\n语法\n#include &lt;stdlib.h&gt;\nint daemon ( int nochdir, int noclose );\n描述\ndaemon()用于脱离控制终端、转入后台运行程序(守护进程)。\n如果第一形参nochdir为零，daemon()最终执行chdir( \"/\" )。\n如果第二形参noclose为零，daemon()最终将stdin、stdout、stderr重定向到\n/dev/null。\n错误\n失败时返回-1，并设置errno，errno的值与fork(2)、setsid(2)的情形一致。\n参看\nfork(2), setsid(2)\n历史\n4.4BSD首次引入了daemon()。\n--------------------------------------------------------------------------\n从man手册可以看出daemon()都做了些什么。在清楚自己到底需要何种效果的前提下，\n可以不使用复杂的daemon_init()而直接使用daemon()。\nAIX、Solaris未直接提供daemon()，如编写最广泛兼容程序，应避免使用daemon()。\n24.4 将编译、链接过程分开\nQ: 如下程序直接用gcc编译、链接无问题。但是将编译、链接过程分开时，失败。\n$ gcc -Wall -pipe -O3 -c -o helloworld.o helloworld.c\n$ ld -o helloworld helloworld.o\nld: warning: cannot find entry symbol _start; defaulting to 08048074\n--------------------------------------------------------------------------\n/*\n* For x86/Linux 2.4.7-10/RedHat 7.2(gcc 2.96/gas 2.11.90.0.8)\n* gcc -Wall -pipe -O3 -o helloworld helloworld.c\n*/\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main ( int argc, char * argv[] )\n{\nreturn( EXIT_SUCCESS );\n}  /* end of main */\n--------------------------------------------------------------------------\nA: scz &lt;scz@nsfocus.com&gt;\n$ gcc -v -Wall -pipe -O3 -o helloworld helloworld.c &amp;&gt; gcc.txt\n$ more gcc.txt\ngcc.txt的内容真实反映了整个编译、链接过程，可简化成如下三个步骤:\n$ gcc -Wall -pipe -O3 -S -o helloworld.s helloworld.c\n$ as -Qy -o helloworld.o helloworld.s\n$ ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 -o helloworld helloworld.o /usr/lib/crt1.o /usr/lib/crti.o /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtbegin.o -lc /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtend.o /usr/lib/crtn.o\n25. AIX相关问题\n25.0 如何查看AIX版本号\nQ: \"uname -a\"显示如下:\nAIX aix4 3 4 001381144C00\n可我想直接了当地看到AIX版本号\nA: oslevel\n4.3.3.0\n25.1 如何在AIX命令行上修改IP地址\nQ: 在/etc下用find搜索原来所配置的IP地址，结果只在/etc/hosts文件中找到一个\n相关匹配，其它匹配是日志文件一类的。\nfind /etc -name \"*\" -type f | xargs grep &lt;original ip&gt;\n于是我假设AIX跟Solaris一样只依赖/etc/hosts文件设置IP地址，修改该文件后\n重启，发现新IP未生效，旧IP也不能正常工作。\nA: 1) 正规命令行修改步骤如下:\nsmit tcpip\nFurther Configuration\nNetwork Interfaces\nNetwork Interface Selection\nChange / Show Characteristics of a Network Interface\nen0     Standard Ethernet Network Interface\n2) 也可以用ifconfig直接修改IP地址，并放入启动脚本/etc/rc.net中。\nifconfig en0 192.168.7.250 netmask 255.255.255.0 broadcast 192.168.7.255 up\n25.2 如何查看RS/6000物理内存大小\nA: # lsattr -El sys0 -a realmem\nrealmem 262144 Amount of usable physical memory in Kbytes False\n或者\n# lsdev -Cc memory\nmem0     Available 00-00 Memory\nL2cache0 Available 00-00 L2 Cache\n# lsattr -El mem0\nsize     256 Total amount of physical memory in Mbytes  False\ngoodsize 256 Amount of usable physical memory in Mbytes False\n25.3 AIX 4.3.3中\"ls a*\"不正常\nQ: 某目录下简单执行ls，正常。执行\"ls a*\"，报错:\nksh: /usr/bin/ls: 0403-027 The parameter list is too long.\n原因是/usr/include/sys/limits.h里面ARG_MAX定义成24576。AIX 5可以修改这\n个限制，AIX 4.3.3没有办法修改。\n怎样达到原始目的，只显示当前目录(不包含其子目录)中以a开头的文件。\nA: 至少有两种办法\n#! /bin/sh\nfor file in `ls` ; do\nif test -f $file ; then\nif `/usr/bin/echo ${file} | /usr/bin/grep \"^a.*\" &gt;/dev/null 2&gt;&amp;1` ; then\necho \"${file}\"\nfi\nfi\ndone\n或者\nls -F | grep \"^a.*[^/]$\"\n25.4 AIX多线程编程与errno全局变量\nQ: AIX多线程编程中使用了全局变量errno，有什么需要注意的地方。\nA: wayman@smth\n使用gcc -D_THREAD_SAFE，此时errno是每个线程相关的，不再是全局变量。当正确地\n包含&lt;errno.h&gt;之后，errno被重新定义过:\n#if defined(_THREAD_SAFE) || defined(_THREAD_SAFE_ERRNO)\n/*\n* Per thread errno is provided by the threads provider. Both the extern\n* int and the per thread value must be maintained by the threads library.\n*/\n#define errno (*_Errno())\n#endif\nextern int errno;\n函数_Errno()返回一个指针，指向一个线程相关整数。注意，你仍然可以使用&amp;errno。\n在/usr/include/*.h中grep查看一下，会发现如果指定了-D_THREAD_SAFE，就不必再\n指定-D_REENTRANT以及-D_THREAD_SAFE_ERRNO。</pre>"
    }
  ]
}
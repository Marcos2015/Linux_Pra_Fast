{
  "title": "Position Independent Code and x86-64 libraries",
  "cells": [
    {
      "type": "text",
      "data": "<header style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><h1 itemprop=\"name\">Position Independent Code and x86-64 libraries</h1><p><a href=\"https://www.technovelty.org/c/position-independent-code-and-x86-64-libraries.html\" itemprop=\"url\"><span class=\"glyphicon glyphicon-bookmark\"></span></a><i>Sat 05 January 2013</i></p></header><div itemprop=\"articleBody\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px;\"><p><em>A comment pointed out that the original article from 2008 made a few simplifications that were a bit misleading, so I have taken some time to update this. Thanks for the feedback.</em></p><p>If you've ever tried to link non-position independent code into a shared library on x86-64, you should have seen a fairly cryptic error about invalid relocations and missing symbols. Hopefully this will clear it up a little.</p><p>Let's start with a small program to illustrate.</p><div class=\"highlight\"><pre><span class=\"kt\">int</span> <span class=\"n\">global</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"p\">;</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">function</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">global</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div><p>Firstly, inspect the disassembley of this function:</p><pre class=\"literal-block\">$gcc -c function.c\n\n$objdump --disassemble function.o\n\n0000000000000000 &lt;function&gt;:\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   89 7d fc                mov    %edi,-0x4(%rbp)\n   7:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # d &lt;function+0xd&gt;\n   d:   03 45 fc                add    -0x4(%rbp),%eax\n  10:   c9                      leaveq\n  11:   c3                      retq\n</pre><p>Lets just go through that for clarity:</p><ul class=\"simple\"><li><strong>0</strong>,<strong>1</strong>: save&nbsp;<tt class=\"docutils literal\">rbp</tt>&nbsp;to the stack and save the stack pointer (<tt class=\"docutils literal\">rsp</tt>) to&nbsp;<tt class=\"docutils literal\">rbp</tt>. This common stanza is setting up the&nbsp;<em>frame pointer</em>, which is essentially a rule used by debuggers (mostly) to keep track of the base of the stack. It's not important for now.</li><li><strong>4</strong>:Move the value from&nbsp;<tt class=\"docutils literal\">edi</tt>&nbsp;to 4 bytes below the stack pointer. This is moving the first argument (<tt class=\"docutils literal\">int i</tt>) into the \"red-zone\", a 128-byte scratch area each function has reserved below the stack pointer.</li><li><strong>7</strong>,<strong>d</strong>: Move the value at offset 0 from the current instruction pointer (<tt class=\"docutils literal\">rip</tt>) into&nbsp;<tt class=\"docutils literal\">eax</tt>&nbsp;(by convention the return value is left in register&nbsp;<tt class=\"docutils literal\">eax</tt>). Then add the incoming argument to it (retrieved from the scratch area); i.e.&nbsp;<tt class=\"docutils literal\">return global + i</tt></li></ul><p>The IP relative move is really the trick here. We know from the code that it has to move the value of the&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;variable here. The zero value is simply a place holder - the compiler currently does not determine the required address (i.e. how far away from the instruction pointer the memory holding the&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;variable is). It leaves behind a&nbsp;<em>relocation</em>&nbsp;-- a note that says to the linker \"you should determine the correct address of&nbsp;<em>foo</em>&nbsp;(<tt class=\"docutils literal\">global</tt>&nbsp;in our case), and then patch this bit of the code to point to that addresss\".</p><img alt=\"Relocations with addend\" class=\"align-center\" src=\"quiver-image-url/A9B76F2A936D4F0557C3A9EF0922A2A7.png\" width=\"512\" height=\"448\"><p>The top portion of the image above gives some idea of how it works. We can examine relocations in binaries with the&nbsp;<tt class=\"docutils literal\">readelf</tt>&nbsp;tool.</p><pre class=\"literal-block\">$ readelf --relocs ./function.o\n\nRelocation section '.rela.text' at offset 0x518 contains 1 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000009  000800000002 R_X86_64_PC32     0000000000000000 global + fffffffffffffffc\n</pre><p>There are many different types of relocations for different situations; the exact rules for different relocation types are described in the ABI documentation for the architecture. The&nbsp;<tt class=\"docutils literal\">R_X86_64_PC32</tt>&nbsp;relocation is defined as \"the base of the section the symbol is within, plus the symbol value, plus the addend\". The addend makes it look more tricky than it is; remember that when an instruction is executing the instruction pointer points to the&nbsp;<em>next</em>&nbsp;instruction to be executed. Therefore, to correctly find the data relative to the instruction pointer, we need to subtract the extra. This can be seen more clearly when layed out in a linear fashion (as in the bottom of the above diagram).</p><p>If you try and build a shared object (dynamic library) with an object file with this type of relocation, you should get something like:</p><pre class=\"literal-block\">$ gcc -shared function.c\n/usr/bin/ld: /tmp/ccQ2ttcT.o: relocation R_X86_64_32 against `a local symbol' can not be used when making a shared object; recompile with -fPIC\n/tmp/ccQ2ttcT.o: could not read symbols: Bad value\ncollect2: ld returned 1 exit status\n</pre><p>If you look back at the disassembly, we notice that the&nbsp;<tt class=\"docutils literal\">R_X86_64_32</tt>&nbsp;relocation has left only 4-bytes (32-bits) of space left for the relocation entry (the zeros in&nbsp;<tt class=\"docutils literal\">7: 8b 15 00 00 00 00</tt>).</p><p>So why does this matter when you're creating a shared library? The first thing to remember is that in a shared library situation, we can not depend on the local value of&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;actually being the one we want. Consider the following example, where we override the value of global with a&nbsp;<tt class=\"docutils literal\">LD_PRELOAD</tt>&nbsp;library.</p><pre class=\"literal-block\">$ cat function.c\nint global = 100;\n\nint function(int i) {\n    return i + global;\n}\n\n$ gcc -fPIC -shared -o libfunction.so function.c\n\n$ cat preload.c\nint global = 200;\n\n$ gcc -shared preload.c -o libpreload.so\n\n$ cat program.c\n#include &lt;stdio.h&gt;\n\nint function(int i);\n\nint main(void) {\n   printf(\"%d\\n\", function(10));\n}\n\n$ gcc -L. -lfunction program.c -o program\n\n$ LD_LIBRARY_PATH=. ./program\n110\n\n$ LD_PRELOAD=libpreload.so LD_LIBRARY_PATH=. ./program\n210\n</pre><p>If the code in&nbsp;<tt class=\"docutils literal\">libfunction.so</tt>&nbsp;were to have a fixed offset into its own data section, it will not be able to be overridden at run-time by the value provided by&nbsp;<tt class=\"docutils literal\">libpreload.so</tt>. Additionally, there are only 4-bytes available to patch in for the address of&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;-- since a shared library could conceivably be loaded anywhere in the 64-bit (8-byte) address space we therefore need 8-bytes of space to cover ourselves for all possible addresses&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;might turn up at.</p><p>The two basic possibilities for an object file are to be either linked into an executable or linked into a shared-library. In the executable case, the value of&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;will be in the exectuable's data section, which should definitely be reachable with a 32-bit offset of the current instruction-pointer. The instruction-pointer relative address can simply be patched in and the executable is finalised.</p><p>But what about the shared-library case, where we know the value of&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;could essentially be anywhere within the 64-bit address space? It is possible to leave 8-bytes of space for the address of&nbsp;<tt class=\"docutils literal\">global</tt>, by telling gcc to use the&nbsp;<em>large-code</em>&nbsp;model. e.g.</p><pre class=\"literal-block\">$ gcc -c -mcmodel=large function.c\n\n$ objdump --disassemble ./function.o\n\n./function.o:     file format elf64-x86-64\n\n\nDisassembly of section .text:\n\n0000000000000000 &lt;function&gt;:\n   0:  55                      push   %rbp\n   1:  48 89 e5                mov    %rsp,%rbp\n   4:  89 7d fc                mov    %edi,-0x4(%rbp)\n   7:  48 b8 00 00 00 00 00    movabs $0x0,%rax\n   e:  00 00 00\n  11:  8b 10                   mov    (%rax),%edx\n  13:  8b 45 fc                mov    -0x4(%rbp),%eax\n  16:  01 d0                   add    %edx,%eax\n  18:  5d                      pop    %rbp\n  19:  c3                      retq\n</pre><p>However, this creates a problem if you really want to&nbsp;<em>share</em>&nbsp;this code. By having to patch in an address of&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;directly, this means the run-time code above does&nbsp;<strong>not</strong>&nbsp;remain unchanged. Two separate processes therefore can't share this code -- they each need separate copies that are identical but for their own addresses of&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;patched into it.</p><p>By enabling&nbsp;<em>Position Independent Code</em>&nbsp;(PIC, with the flag&nbsp;<tt class=\"docutils literal\">-fPIC</tt>) you can ensure the code remains share-able. PIC means that the output binary does not expect to be loaded at a particular base address, but is happy being put anywhere in memory (compare the output of&nbsp;<tt class=\"docutils literal\">readelf&nbsp;<span class=\"pre\">--segments</span></tt>&nbsp;on a binary such as&nbsp;<tt class=\"docutils literal\">/bin/ls</tt>&nbsp;to that of any shared library). This is obviously critical for implementing lazy-loading (i.e. only loaded when required) shared-libraries, where you may have many libraries loaded in essentially any order at any location.</p><p>Of course, any problem in computer science can be solved with a layer of abstraction and that is essentially what is done when compiling with&nbsp;<tt class=\"docutils literal\">-fPIC</tt>. To examine this case, let's see what happens with PIC turned on.</p><pre class=\"literal-block\">$ gcc -fPIC -shared -c  function.c\n\n$ objdump --disassemble ./function.o\n\n./function.o:     file format elf64-x86-64\n\nDisassembly of section .text:\n\n0000000000000000 &lt;function&gt;:\n   0:   55                      push   %rbp\n   1:   48 89 e5                mov    %rsp,%rbp\n   4:   89 7d fc                mov    %edi,-0x4(%rbp)\n   7:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # e &lt;function+0xe&gt;\n   e:   8b 00                   mov    (%rax),%eax\n  10:   03 45 fc                add    -0x4(%rbp),%eax\n  13:   c9                      leaveq\n  14:   c3                      retq\n</pre><p>It's&nbsp;<em>almost</em>&nbsp;the same! We setup the frame pointer with the first two instructions as before. We push the first argument into memory in the pre-allocated \"red-zone\" as before. Then, however, we do an IP relative load of an address into&nbsp;<tt class=\"docutils literal\">rax</tt>. Next we de-reference this into&nbsp;<tt class=\"docutils literal\">eax</tt>&nbsp;(e.g.&nbsp;<tt class=\"docutils literal\">eax = *rax</tt>&nbsp;in C) before adding the incoming argument to it and returning.</p><pre class=\"literal-block\">$ readelf --relocs ./function.o\n\nRelocation section '.rela.text' at offset 0x550 contains 1 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n00000000000a  000800000009 R_X86_64_GOTPCREL 0000000000000000 global + fffffffffffffffc\n</pre><p>The magic here is again in the relocations. Notice this time we have a&nbsp;<tt class=\"docutils literal\">P_X86_64_GOTPCREL</tt>&nbsp;relocation. This says \"replace the data at offset&nbsp;<tt class=\"docutils literal\">0xa</tt>&nbsp;with the&nbsp;<em>global offset table</em>&nbsp;(GOT) entry of&nbsp;<tt class=\"docutils literal\">global</tt>.</p><img alt=\"Global Offset Table operation with data variables\" class=\"align-center\" src=\"quiver-image-url/E5E8B962500F18520192B87D7B2A0501.png\" width=\"327\" height=\"362\"><p>As shown above, the GOT ensures the abstraction required so symbols can be diverted as expected. Each entry is essentially a pointer to the real data (hence the extra dereference in the code above). Since we can assume the GOT is at a fixed offset from the program code within plus or minus 2Gib, the code can use a 32-bit IP relative address to gain access to the table entries.</p><p>So, taking a look a the final shared-library binary we see a final offset hard-coded</p><pre class=\"literal-block\">$ gcc -shared -fPIC -o libfunction.so function.c\n\n$ objdump --disassemble ./libfunction.so\n\n00000000000006b0 &lt;function&gt;:\n 6b0:  55                      push   %rbp\n 6b1:  48 89 e5                mov    %rsp,%rbp\n 6b4:  89 7d fc                mov    %edi,-0x4(%rbp)\n 6b7:  48 8b 05 8a 02 20 00    mov    0x20028a(%rip),%rax        # 200948 &lt;_DYNAMIC+0x1d8&gt;\n 6be:  8b 10                   mov    (%rax),%edx\n 6c0:  8b 45 fc                mov    -0x4(%rbp),%eax\n 6c3:  01 d0                   add    %edx,%eax\n 6c5:  5d                      pop    %rbp\n 6c6:  c3                      retq\n 6c7:  90                      nop\n</pre><p>Every process who wants to share this code just needs to make sure they have their unique address of&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;at&nbsp;<tt class=\"docutils literal\">0x20028a(%rip)</tt>. Since each process has a separate address-space, this means they can all have different values for&nbsp;<tt class=\"docutils literal\">global</tt>&nbsp;but share the same code!</p><p>Thus the default of the&nbsp;<em>small-code</em>&nbsp;model is sensible. It is exceedingly rare for an executable to need more than 4-byte offsets for a relative access to a variable in it's data region, so using a full 8-byte value would just be a waste of space. Although leaving 8-bytes would allow access to the variable anywhere in the 64-bit address space; when building a shared library, you really want to use&nbsp;<tt class=\"docutils literal\">-fPIC</tt>&nbsp;to ensure the library can actually be&nbsp;<em>shared</em>, which introduces a different relocation and access to data via the GOT.</p><p>This should explain why&nbsp;<tt class=\"docutils literal\">gcc&nbsp;<span class=\"pre\">-shared</span>&nbsp;function.c</tt>&nbsp;works on x86-32, but does not work on x86-64. Inspecting the code reveals why:</p><pre class=\"literal-block\">$ objdump --disassemble ./function.o\n00000000 &lt;function&gt;:\n   0:   55                      push   %ebp\n   1:   89 e5                   mov    %esp,%ebp\n   3:   a1 00 00 00 00          mov    0x0,%eax\n   8:   03 45 08                add    0x8(%ebp),%eax\n   b:   5d                      pop    %ebp\n   c:   c3                      ret\n$ readelf --relocs ./function.o\nRelocation section '.rel.text' at offset 0x2ec contains 1 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n00000004  00000701 R_386_32          00000000   global\n</pre><p>We start out the same, with the first two instructions setting up the frame pointer. However, next we load a memory value into&nbsp;<tt class=\"docutils literal\">eax</tt>&nbsp;-- as we can see from the relocation information, the address of&nbsp;<tt class=\"docutils literal\">global</tt>. Next we add the incoming argument from the stack (<tt class=\"docutils literal\">0x8(%ebp)</tt>) to the value in this memory location; implicitly dereferencing it. But since we only have a 32-bit address-space, the 4-bytes allocated is enough to access any possible address. So while this can work, you're not creating position-independent code and hence not enabling code-sharing.</p><p>The disadvantage of PIC code is that you require \"bouncing\" through the GOT, which requires more loads and reads to find an address than directly referencing it. However, if your program is at the point that this is becoming a performance issue you're probably not reading this blog!</p><p>Hopefully, this helps clear up that possibly cryptic error message. Further searches around position-independent code, global-offset tables and code-sharing should also yield you more information if it remains unclear.</p></div>"
    }
  ]
}
{
  "title": "GNU gcc 和 g++ 的区别详解",
  "cells": [
    {
      "type": "text",
      "data": "<div id=\"article_content\" class=\"article_content\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 20px 0px 0px; line-height: 26px;\"><p style=\"margin: 0px; padding: 0px;\">gcc 和 g++ 都是 GNU 组织的编译器。</p><p style=\"margin: 0px; padding: 0px;\"><span style=\"font-weight: bold;\">误区一： gcc 只能编译 C 代码，g++ 只能编译 C++ 代码</span><br>两者都可以，但是请注意：<br>1. 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 C++ 程序；<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;后缀为.cpp的，两者都会认为是 C++程序；<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;注意： 虽然 C++ 是 C 的超集，但是两者对语法的要求是有区别的！ C++ 的语法规则更加严谨一些。<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;例如：<br><code>#include &lt;stdio.h&gt;<br></code><code>int&nbsp;main( int&nbsp;argc,char *argv[] )<br>{<br>　　 if (</code>&nbsp;<code>0</code>&nbsp;<code>==</code>&nbsp;<code>argv )<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;{<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<span style=\"font-weight: bold;\">return;</span><br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;}<br>　　 printString( argv );<br>　　&nbsp;<span style=\"font-weight: bold;\">return;</span><br>}</code><br><code><br>int&nbsp;<span style=\"font-weight: bold;\">printString</span>(&nbsp;<span style=\"font-weight: bold;\">char* string</span>&nbsp;)<br>{<br>　 sprintf( string,\"This is a test.n\" );<br>}<br></code><br>如果按照 C 的语法规则，OK，没问题，但是，一旦把后缀改为 .cpp，立刻报三个错：<br>“printString未定义”；<br>“cannot convert `char**' to `char*”；<br>“return-statement with no value”；<br>可见C++的语法规则更加严谨一些。<br><br><br>2. 编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;但是因为 gcc 命令不能自动和 C++ 库链接，所以通常用 g++ 来完成链接，<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;为了统一，干脆编译与链接统统用 g++ 了，就给人一种错觉，好像 cpp 程序只能用 g++ 似的。<br><br><span style=\"font-weight: bold;\">误区二： gcc 不会定义 __cplusplus 宏，而 g++ 会</span><br>实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释，<br>如上所述，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则，就是已定义。<br><br><span style=\"font-weight: bold;\">误区三： 编译只能用 gcc，链接只能用 g++</span><br>严格来说，这句话不算错误，但是它混淆了概念，应该这样说：<br>编译可以用 gcc 或 g++，而链接可以用 g++ 或者 gcc -lstdc++。<br>因为 gcc 命令不能自动和 C++ 库链接，所以通常使用 g++ 来完成链接。<br>但在编译阶段，g++ 会自动调用 gcc，二者等价。<br><br><span style=\"font-weight: bold;\">误区四： extern \"C\" 与 gcc 或 g++ 有关系</span><br>实际上并无关系，<br>无论是 gcc 还是 g++，用 extern \"c\" 时，都是以 C 的命名方式来为 函数 命名，<br>否则，都以 C++ 方式为 函数 命名。<br>试验如下：<br><span style=\"font-weight: bold;\">test.h：</span><br>extern \"C\" void CppPrintf(void);<br><br><span style=\"font-weight: bold;\">test.cpp:</span><br>#include &lt;iostream&gt;<br>#include \"test.h\"<br>using namespace std;<br>void&nbsp;CppPrintf( void )<br>{<br>　　cout &lt;&lt; \"Hellon\";<br>}<br><br><span style=\"font-weight: bold;\">main.cpp:</span><br>#include &lt;stdlib.h&gt;<br>#include &lt;stdio.h&gt;<br>#include \"test.h\"<br>int&nbsp;main( void )<br>{<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;CppPrintf();<br>&nbsp;<wbr>&nbsp;<wbr>&nbsp;<wbr>&nbsp;return 0;<br>}<br><br>1. 先给 test.h 里的 void CppPrintf(void); 加上 extern \"C\"，看用 gcc 和 g++ 命名有什么不同。<br>$ g++ -S test.cpp<br>$ less test.s<br>.globl&nbsp;<wbr>&nbsp;<span style=\"font-weight: bold;\">CppPrintf</span>&nbsp;<wbr>&nbsp;&lt;-- 注意此函数的命名<br>.type<span style=\"font-weight: bold;\">&nbsp;<wbr>&nbsp;CppPrintf</span>, @function<br><br>$ gcc -S test.cpp<br>$ less test.s<br>.globl&nbsp;<wbr>&nbsp;<span style=\"font-weight: bold;\">CppPrintf</span>&nbsp;<wbr>&nbsp;&lt;-- 注意此函数的命名<br>.type&nbsp;<wbr>&nbsp;<span style=\"font-weight: bold;\">CppPrintf</span>, @function<span style=\"font-weight: bold;\"><br>完全相同！</span><br><br>2. 去掉 test.h 里 void CppPrintf(void); 前面的 extern \"C\"，看用 gcc 和 g++ 命名有什么不同。<br><code>$</code>&nbsp;<code>g++ -S test.cpp<br></code><code>$</code>&nbsp;<code>less test.s<br><span style=\"font-family: 宋体, Verdana, Arial, Helvetica, sans-serif;\">.globl&nbsp;<wbr>&nbsp;<span style=\"font-weight: bold;\">_Z9CppPrintfv</span>&nbsp;<wbr></span></code>&nbsp;&lt;-- 注意此函数的命名<br><code><span style=\"font-family: 宋体, Verdana, Arial, Helvetica, sans-serif;\">.type&nbsp;<wbr>&nbsp;<span style=\"font-weight: bold;\">_Z9CppPrintfv</span>, @function<br></span></code><br><code>$ gcc -S test.cpp<br>$ less test.s<br><span style=\"font-family: 宋体, Verdana, Arial, Helvetica, sans-serif;\">.globl&nbsp;<wbr>&nbsp;<span style=\"font-weight: bold;\">_Z9CppPrintfv</span></span></code><code><span style=\"font-family: 宋体, Verdana, Arial, Helvetica, sans-serif;\">&nbsp;<wbr></span></code>&nbsp;&lt;-- 注意此函数的命名<code><span style=\"font-family: 宋体, Verdana, Arial, Helvetica, sans-serif;\"><br>.type&nbsp;<wbr>&nbsp;<span style=\"font-weight: bold;\">_Z9CppPrintfv</span>, @function<span style=\"font-weight: bold;\"><br></span></span></code><code><span style=\"font-weight: bold;\">完全相同！</span></code><br><br>结论：<br>完全相同，可见 extern \"C\" 与采用 gcc 或 g++ 并无关系，<br>以上的试验还间接的印证了前面的说法：在编译阶段，g++ 是调用 gcc 的。</p></div>"
    }
  ]
}
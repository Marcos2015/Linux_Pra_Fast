{
  "title": "多线程模型下的无锁编程",
  "cells": [
    {
      "type": "text",
      "data": "<span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">多线程模式是比较流行的一种并发编程模型,多线程编程的一个特点就是线程间共享内存空间;这可以降低线程间通信的开销,但却引来了另外的一个难缠的问题:竟态条件!，因此,甚至有人对多线程模型提出了质疑,看</span><a href=\"http://coolshell.cn/articles/4626.html\" target=\"_blank\" style=\"font-size: 14px; word-wrap: break-word; text-decoration: none; color: rgb(51, 102, 153); font-family: song, Verdana; line-height: 22.383333206176758px;\">这里</a><span style=\"word-wrap: break-word; color: rgb(102, 102, 102); font-size: 16px; line-height: 26px; font-family: 'song, Verdana';\"><span style=\"word-wrap: break-word; font-size: 14px; line-height: 22.366666793823242px;\">。</span></span><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">在多线程编程模型下,解决竟态条件的传统方法就是加锁保护临界区,但这存在影响系统性能、优先级反转等问题.</span><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">因此又有人提出了,多线程模型下无锁编程的一些方式:</span><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><strong style=\"word-wrap: break-word;\">1.线程内通信框架</strong>: Disruptor, 这是一款开源的并发框架,用于线程间无锁的共享数据,看</span><a href=\"http://ifeve.com/sharing-data-among-threads-without-contention/\" target=\"_blank\" style=\"font-size: 14px; word-wrap: break-word; text-decoration: none; color: rgb(51, 102, 153); font-family: song, Verdana; line-height: 22.383333206176758px;\">这里</a><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">。</span><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><strong style=\"word-wrap: break-word;\">2.无锁数据结构</strong></span><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">无锁数据结构一般基于一个很重要的操作：<strong style=\"word-wrap: break-word;\">CAS</strong>--Compare And Swap(看</span><a href=\"http://en.wikipedia.org/wiki/Compare-and-swap\" target=\"_blank\" style=\"font-size: 14px; word-wrap: break-word; text-decoration: none; color: rgb(51, 102, 153); font-family: song, Verdana; line-height: 22.383333206176758px;\">这里</a><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">)。</span><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">用C语言表达的一个CAS实现的操作是这样的：<br style=\"word-wrap: break-word;\"><br style=\"word-wrap: break-word;\"><div id=\"codeText\" class=\"codeText\" style=\"word-wrap: break-word; border: 1px solid rgb(221, 221, 221); width: 1109.1875px; overflow: auto; margin: 0px 0px 1.1em; padding: 0px; word-break: break-all; letter-spacing: 0.1px; font-size: 12px; line-height: normal; font-family: Consolas, monospace;\"><ol start=\"1\" class=\"dp-css\" style=\"word-wrap: break-word; margin: 0px 1px 0px 0px; padding: 0px 0px 0px 40px; list-style: none; color: rgb(92, 92, 92); line-height: 1.3;\"><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 0);\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>定义CAS操作<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><br style=\"word-wrap: break-word;\"></span></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">#define CAS __sync_bool_compare_and_swap<br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>&nbsp;定义stack的数据结构<br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">typedef struct stack_node&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">{</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;struct node&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">next</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>data<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">}</span>stack_node<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>栈顶指针<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">stack_node&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>top&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">=</span>&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">NULL</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span></li></ol></div><br style=\"word-wrap: break-word;\"></span><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">CAS的一个重要特性是其必须是原子操作。现在大多数CPU都支持指令级别的CAS操作。</span><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><br style=\"word-wrap: break-word;\"></span><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">GCC编译也提供了这样的接口:bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">有了这个原子的CAS后，我们就能实现自己的无锁数据结构了，下面我们就尝试着来实现一个无锁栈：</span><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><br style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\"><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">下面的代码中，我们假设malloc与free是线程安全的(至于malloc与free的可重入性与线程安全问题，可以看</span><a href=\"http://stackoverflow.com/questions/8869622/malloc-is-non-reentrant-but-thread-safe\" target=\"_blank\" style=\"font-size: 14px; word-wrap: break-word; text-decoration: none; color: rgb(51, 102, 153); font-family: song, Verdana; line-height: 22.383333206176758px;\">这里</a><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">和</span><a href=\"http://stackoverflow.com/questions/855763/malloc-thread-safe\" target=\"_blank\" style=\"font-size: 14px; word-wrap: break-word; text-decoration: none; color: rgb(51, 102, 153); font-family: song, Verdana; line-height: 22.383333206176758px;\">这里</a><span style=\"font-size: 14px; word-wrap: break-word; color: rgb(102, 102, 102); font-family: song, Verdana; line-height: 22.383333206176758px;\">)<br style=\"word-wrap: break-word;\"><br style=\"word-wrap: break-word;\">首先定义必要的数据结构:<br style=\"word-wrap: break-word;\"><div id=\"codeText\" class=\"codeText\" style=\"word-wrap: break-word; border: 1px solid rgb(221, 221, 221); width: 1109.1875px; overflow: auto; margin: 0px 0px 1.1em; padding: 0px; word-break: break-all; letter-spacing: 0.1px; font-size: 12px; line-height: normal; font-family: Consolas, monospace;\"><ol start=\"1\" class=\"dp-css\" style=\"word-wrap: break-word; margin: 0px 1px 0px 0px; padding: 0px 0px 0px 40px; list-style: none; color: rgb(92, 92, 92); line-height: 1.3;\"><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 0);\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>定义CAS操作<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><br style=\"word-wrap: break-word;\"></span></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">#define CAS __sync_bool_compare_and_swap<br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>&nbsp;定义stack的数据结构<br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">typedef struct stack_node&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">{</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;struct node&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">next</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">; /*指向下一个节点,即通过链表的形式实现栈*/</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>data<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;/*指向该节点的数据*/</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">}</span>stack_node<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>栈顶指针<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">stack_node&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>top&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">=</span>&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">NULL</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span></li></ol></div>接下来是<span style=\"word-wrap: break-word; font-family: Consolas, monospace; line-height: 15px;\">压</span>栈操作:<br style=\"word-wrap: break-word;\"><div id=\"codeText\" class=\"codeText\" style=\"word-wrap: break-word; border: 1px solid rgb(221, 221, 221); width: 1109.1875px; overflow: auto; margin: 0px 0px 1.1em; padding: 0px; word-break: break-all; letter-spacing: 0.1px; font-size: 12px; line-height: normal; font-family: Consolas, monospace;\"><ol start=\"1\" class=\"dp-css\" style=\"word-wrap: break-word; margin: 0px 1px 0px 0px; padding: 0px 0px 0px 40px; list-style: none; color: rgb(92, 92, 92); line-height: 1.3;\"><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 0);\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>压栈操作<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><br style=\"word-wrap: break-word;\"></span></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">void stack_push<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(</span>void&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>data<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">{</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;stack_node&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>new&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">=</span>&nbsp;malloc<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(</span>sizeof<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(</span>struct node<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;new<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">-</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">&gt;</span>data&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">=</span>&nbsp;data<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">do</span>&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">{</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">-</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">&gt;</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">next</span>&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">=</span>&nbsp;top<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;/*获取top的快照, 同时初始化了new的next指针*/</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">}</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">while</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(!</span>CAS<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">&amp;</span>top<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">,</span>&nbsp;new<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">-</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">&gt;</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">next</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">,</span>&nbsp;new<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">}</span></li></ol></div>在取得top的快照后后, 就通过CAS操作查看top的内容与line 7取得的快照是否一致，如果一致则将top的内容更换为new，CAS函数返回true。<br style=\"word-wrap: break-word;\">假设有线程A在<span style=\"word-wrap: break-word; color: rgb(92, 92, 92); font-family: Consolas, monospace; line-height: 15px;\">stack_push里获取top快照后暂时失去了执行权, 切换至另一个线程B, 而线程B完成了一次</span><span style=\"word-wrap: break-word; color: rgb(92, 92, 92); font-family: Consolas, monospace; line-height: 15px;\">stack_push操作，然后执行权再次回到线程A,</span><br style=\"word-wrap: break-word;\">线程A执行CAS操作, 发现top里的内容与快照里的内容已经不一致了，CAS返回false,&nbsp;估do...while语句重新执行。<br style=\"word-wrap: break-word;\"><br style=\"word-wrap: break-word;\">接下来是出栈操作:<br style=\"word-wrap: break-word;\"><div id=\"codeText\" class=\"codeText\" style=\"word-wrap: break-word; border: 1px solid rgb(221, 221, 221); width: 1109.1875px; overflow: auto; margin: 0px 0px 1.1em; padding: 0px; word-break: break-all; letter-spacing: 0.1px; font-size: 12px; line-height: normal; font-family: Consolas, monospace;\"><ol start=\"1\" class=\"dp-css\" style=\"word-wrap: break-word; margin: 0px 1px 0px 0px; padding: 0px 0px 0px 40px; list-style: none; color: rgb(92, 92, 92); line-height: 1.3;\"><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 0);\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>出栈操作<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">/</span><br style=\"word-wrap: break-word;\"></span></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">void&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>&nbsp;stack_pop<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(</span>void<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">{</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;stack_node&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>tmp<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">*</span>data<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;<br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">do</span>&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">{</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">=</span>&nbsp;top<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">if</span>&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">!</span>tmp<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span>&nbsp;return&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">NULL</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">}</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">while</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(</span>CAS<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">&amp;</span>top<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">,</span>&nbsp;tmp<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">,</span>&nbsp;tmp<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">-</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">&gt;</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">next</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span>&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">=</span>&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 255);\">true</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">=</span>&nbsp;tmp<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">-</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">&gt;</span>data<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;free<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">(</span>tmp<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">)</span><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\">&nbsp;&nbsp;&nbsp;&nbsp;return data<span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">;</span><br style=\"word-wrap: break-word;\"></li><li style=\"word-wrap: break-word; margin: 0px; padding: 0px 0px 0px 10px; list-style: decimal outside;\"><span style=\"word-wrap: break-word; color: rgb(0, 0, 204);\">}</span></li></ol></div>其免锁原理与入栈基本一样，估不再赘述。<br style=\"word-wrap: break-word;\"><br style=\"word-wrap: break-word;\">另外还有一点,&nbsp;在使用CAS实现免锁数据结构时, 容易出现ABA问题, 这里也暂时不作讨论, 可以从参考资料中得到更多的信息。</span>"
    }
  ]
}
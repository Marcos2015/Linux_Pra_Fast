{
  "title": "虚拟存储器--虚拟地址与物理地址",
  "cells": [
    {
      "type": "text",
      "data": "<br><div class=\"tag2box\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 10px 0px;\"></div><div id=\"article_content\" class=\"article_content\" style=\"color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; margin: 20px 0px 0px; line-height: 26px;\"><p style=\"color: rgb(54, 46, 43);\">计算机在运行程序时，需将代码加载入内存中，CPU读取内存中的代码并执行。</p><p style=\"color: rgb(54, 46, 43);\">早期的计算机在没有引入 虚拟存储器之前，需将整个待运行的程序加载到内存中，因为内存空间有限，当待加载的程序过大时就会出现问题（多进程，则需要占用更多的内存空间）。</p><p style=\"color: rgb(54, 46, 43);\">现代计算机引入虚拟存储器的概念，通过将对内存进行抽象，将其作为存储在硬盘上数据的高速缓存，只将当前进程部分代码缓存到主存中（当前进程的程序较少时，可以全部缓存在主存中），从而提高了主存的利用率，使其同时可以容纳更多的进程同时运行。</p><p style=\"color: rgb(54, 46, 43);\">简述<br>虚拟存储器是一个抽象概念，它为每个进程提供一个假象，即每个进程都在独立的使用主存。<br>每个进程看到的是一致的存储器，称为虚拟地址空间。<br>地址空间最上面的区域是为操作系统中的代码和数据保留的，对所有的进程一样。底部存放用户进程定义的代码和数据。<br>进程的虚拟地址空间如下图：</p><p style=\"color: rgb(54, 46, 43);\"><img src=\"quiver-image-url/EB7A82BCE6701F3223790C47EE13B19B.png\" alt=\"\" style=\"border: none;\" width=\"402\" height=\"327\"><br></p><p style=\"color: rgb(54, 46, 43);\">虚拟存储器是对主存的的一种抽象，基本思想：把一个进程虚拟存储器的数据存储在磁盘中，用主存作磁盘的缓存。即虚拟地址空间维护的是 磁盘中的数据，通过将要使用的数据缓存在主存中，使操作系统误以为数据一直在主存中（其实，只是在需要是在被缓存在主存中，如果长时间不需要则可能被swap出主存，存在磁盘中。ps：没有VM概念之前，运行的程序必须全部存储在主存中，引入之后，只需保证此时正被执行的代码在主存中即可。VM大大提高了，主存的利用率，是同时可以有更多的进程可以运行）。<br><br><br><br><br>寻址方式：物理和虚拟寻址<br>早期通过 物理寻址的方式访问主存，即主存中每个字节有一个唯一的物理地址，通过该物理地址，寻找该字节。<br>现在操作系统，通过虚拟寻址。CPU通过一个 虚拟地址来访问主存，该地址在访问主存之前被转换为一个物理地址。其中，转换过程由 位于CPU中的MMU单元，通过访问存储在主存中的页表完成。<br><br><br>地址空间的概念<br>线性地址空间：地址空间的数据是连续的<br>物理地址空间<br>虚拟地址空间<br>主存中每一个字节都有一个选自物理地址空间的物理地址和一个选自虚拟地址空间的虚拟地址。<br><br><br>数据映射：虚拟存储器与物理存储器中间的数据传输<br>虚拟存储器 (VM) 被组织为一个由存在在磁盘上的N个连续的字节大小单元组成的数组。每个字节都有一个唯一的虚拟地址作为到数组的索引。<br>磁盘上的内容被缓存在主存中。通过将地址空间的数据进行分块，利用块大小作为磁盘和主存之间的传输单元。其中，VM系统将VM（指被虚拟化的磁盘）分割为称为虚拟页（virtual page ）大小的块，物理存储器（指主存）被分割为称为物理页（也成为页帧）大小的块。物理页与虚拟页等大，通常为4k, 从而完成数据映射。<br>虚拟存储器将主存作为缓存：<br></p><p style=\"color: rgb(54, 46, 43);\"><img src=\"quiver-image-url/58D3150A9ADC3CFF6278E311F1FDA852.png\" alt=\"\" style=\"border: none;\" width=\"360\" height=\"174\"><br></p><p style=\"color: rgb(54, 46, 43);\">VM需要判断一个虚拟页是否被缓存在DRAM中；如果是，需确定存在哪个物理页中。<br>如果不命中，需判断这个虚拟页存在磁盘的哪个位置，在物理存储器中选择一个牺牲页，将虚拟页从磁盘拷贝到DRAM中，并替换该牺牲页，如果该牺牲页数据发生了改变，则需要将该牺牲页写回磁盘。 该过程称为swap。<br><br><br>上述功能有操作系统，MMU，以及存放在物理存储器中的页表（每一个进程都有一个页表，用于完成 虚拟地址到物理地址的映射）来完成。<br></p><p style=\"color: rgb(54, 46, 43);\"><img src=\"quiver-image-url/ACBCCA795DEE9038228268E914F4EB3F.png\" alt=\"\" style=\"border: none;\" width=\"347\" height=\"277\"><br></p><p style=\"color: rgb(54, 46, 43);\">页命中与缺页<br>即物理地址指数据在主存中的真实地址，虚拟地址是对主存的一种抽象，将存储在磁盘的数据，缓存在主存上。<br><br><br>页命中<br>CPU通过虚拟地址读取在VP2中的虚拟存储器中的数据（通过地址翻译将虚拟地址作为一个索引定位到PTE2，读取VP2相关信息），VP2被缓存在DRAM中，使用PTE中的物理存储器地址（该地址指向PP1缓存页的起始地址），构造这个字的物理地址。<br></p><p style=\"color: rgb(54, 46, 43);\"><img src=\"quiver-image-url/13921F133533847078A6A0FAD1F41322.png\" alt=\"\" style=\"border: none;\" width=\"394\" height=\"290\"><br></p><p style=\"color: rgb(54, 46, 43);\">缺页<br>DRAM缓存不命中称为缺页，触发缺页异常，调用内核中的缺页异常处理程序。在磁盘和存储器之间传送页的活动称之为交换（swapping）或页面调度.</p></div>"
    }
  ]
}